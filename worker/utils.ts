import type { Env } from './types';

export async function parseJsonBody(request: Request) {
  try {
    return await request.json();
  } catch {
    throw new Error("Invalid JSON");
  }
}

// Agent handles chat logging - no manual logging needed

// Agent handles matter questions - no manual storage needed

export async function createMatterRecord(
  env: Env,
  teamId: string,
  sessionId: string,
  service: string,
  description: string,
  urgency: string = 'normal',
  ctx?: ExecutionContext
): Promise<string> {
  try {
    // const matterId = crypto.randomUUID(); // REMOVE THIS LINE
    // Instead, expect matterId to be passed in or generated by DB. Example:
    const matterId = teamId ? teamId + '-' + Date.now() : Date.now().toString();
    const year = new Date().getFullYear();
    const matterNumberResult = await env.DB.prepare(`
      SELECT COUNT(*) as count FROM matters 
      WHERE team_id = ? AND strftime('%Y', created_at) = ?
    `).bind(teamId, year.toString()).first();
    const count = (matterNumberResult as any)?.count || 0;
    const matterNumber = `MAT-${year}-${(count + 1).toString().padStart(3, '0')}`;
    await env.DB.prepare(`
      INSERT INTO matters (
        id, team_id, client_name, matter_type, title, description, status, priority, 
        lead_source, matter_number, custom_fields, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, 'lead', ?, 'website', ?, ?, datetime('now'))
    `).bind(
      matterId,
      teamId,
      'Client (AI Intake)', // Default client name for AI-generated matters
      service,
      `${service} Matter`,
      description,
      urgency === 'urgent' ? 'high' : urgency === 'somewhat urgent' ? 'normal' : 'low',
      matterNumber,
      JSON.stringify({ sessionId, source: 'ai-intake' })
    ).run();
    
    // Create activity event for matter creation (non-blocking)
    const createActivityEvent = async () => {
      try {
        const { ActivityService } = await import('./services/ActivityService');
        const activityService = new ActivityService(env);
        
        // Use Promise.race with timeout to bound latency
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Activity event creation timeout')), 5000)
        );
        
        const activityPromise = activityService.createEvent({
          type: 'matter_event',
          eventType: 'matter_created',
          title: 'Matter Created',
          description: `New ${service} matter created: ${matterNumber}`,
          eventDate: new Date().toISOString(),
          actorType: 'system',
          actorId: sessionId, // Using sessionId as actorId for now
          metadata: {
            matterId,
            teamId,
            sessionId,
            service,
            description,
            urgency,
            matterNumber,
            source: 'ai-intake'
          }
        }, teamId);
        
        await Promise.race([activityPromise, timeoutPromise]);
        console.log('Activity event created for matter creation:', { matterId, matterNumber });
      } catch (error) {
        console.warn('Failed to create activity event for matter creation:', error);
        // Errors are swallowed - don't throw back to caller
      }
    };
    
    // Dispatch asynchronously (fire-and-forget)
    if (ctx) {
      // Use ctx.waitUntil if execution context is available
      ctx.waitUntil(createActivityEvent());
    } else {
      // Fallback to fire-and-forget without awaiting
      createActivityEvent().catch(error => {
        console.warn('Activity event creation failed in fire-and-forget mode:', error);
      });
    }
    
    return matterId;
  } catch (error) {
    console.warn('Failed to create matter record:', error);
    throw error;
  }
}

// Agent handles AI summaries - no manual storage needed

// Agent handles AI summary updates - no manual updates needed

// Agent handles matter updates - no manual updates needed

// Agent handles matter ID retrieval - no manual retrieval needed

// CORS headers moved to errorHandler.ts for consistency 