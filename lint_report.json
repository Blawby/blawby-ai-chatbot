[{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/config/vitest/vitest.config.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/config/vitest/vitest.config.frontend.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/config/vitest/vitest.config.i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/config/vitest/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/config/vitest/vitest.config.unit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/config/vitest/vitest.config.worker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/playwright.no-global.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/scripts/ai-gateway-smoke-test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/scripts/d1-bootstrap.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/scripts/run-tunnel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/scripts/validate-lawyer-api-migration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/__tests__/RTLSupport.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/__tests__/i18n.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/__tests__/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/__tests__/test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/__tests__/utils/test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/app/AppGuard.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":30,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":30,"endColumn":20,"suggestions":[{"fix":{"range":[991,1068],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":36,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":36,"endColumn":22,"suggestions":[{"fix":{"range":[1252,1319],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":44,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":44,"endColumn":20,"suggestions":[{"fix":{"range":[1626,1696],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentChildren } from 'preact';\nimport { useEffect, useRef } from 'preact/hooks';\nimport { usePracticeManagement } from '@/shared/hooks/usePracticeManagement';\n\ninterface AppGuardProps {\n  children: ComponentChildren;\n}\n\n/**\n * AppGuard handles high-level application state enforcement:\n * 1. Post-subscription data synchronization\n */\nexport function AppGuard({ children }: AppGuardProps) {\n  const { refetch: refetchPractices } = usePracticeManagement({ \n    autoFetchPractices: false // Handled manually here during sync\n  });\n  const subscriptionSuccessHandledRef = useRef(false);\n\n  // 1. Handle Subscription Success Sync\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    if (subscriptionSuccessHandledRef.current) return;\n    \n    const urlParams = new URLSearchParams(window.location.search);\n    if (urlParams.get('subscription') !== 'success') return;\n    \n    subscriptionSuccessHandledRef.current = true;\n    \n    if (import.meta.env.DEV) {\n      console.debug('[AppGuard][SUBSCRIPTION] Syncing data after Stripe checkout');\n    }\n    \n    // Refetch practices and session to ensure the frontend reflects the new subscription\n    void refetchPractices().then(() => {\n      if (import.meta.env.DEV) {\n        console.debug('[AppGuard][SUBSCRIPTION] Data synced successfully');\n      }\n      \n      // Clean up the URL to prevent re-triggering on refresh\n      const newUrl = new URL(window.location.href);\n      newUrl.searchParams.delete('subscription');\n      window.history.replaceState({}, '', `${newUrl.pathname}${newUrl.search}${newUrl.hash}`);\n    }).catch((error) => {\n      console.error('[AppGuard][SUBSCRIPTION] Failed to sync data:', error);\n    });\n  }, [refetchPractices]);\n\n  // 2. Onboarding enforcement removed (no automatic redirect).\n\n  return <>{children}</>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/app/ErrorBoundary.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":28,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":28,"endColumn":22,"suggestions":[{"fix":{"range":[585,651],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, ComponentChildren } from 'preact';\nimport { Button } from '@/shared/ui/Button';\n\ninterface Props {\n    children: ComponentChildren;\n    fallback?: ComponentChildren;\n}\n\ninterface State {\n    hasError: boolean;\n    error: Error | null;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n    state = {\n        hasError: false,\n        error: null\n    };\n\n    static getDerivedStateFromError(error: Error) {\n        return {\n            hasError: true,\n            error\n        };\n    }\n\n    componentDidCatch(error: Error, errorInfo: unknown) {\n        console.error('ErrorBoundary caught an error:', error, errorInfo);\n    }\n\n    render() {\n        if (this.state.hasError) {\n            return this.props.fallback || (\n                <div className=\"p-6 m-4 glass-panel border-red-500/20 shadow-xl\">\n                    <h2 className=\"text-xl font-bold text-red-400 mb-4\">Something went wrong</h2>\n                    <details className=\"my-4\">\n                        <summary className=\"cursor-pointer text-accent-500 font-medium hover:text-accent-400 transition-colors\">Error details</summary>\n                        <pre className=\"mt-2 p-4 bg-white/5 border border-white/10 rounded-xl overflow-x-auto text-sm text-red-200/80\">{this.state.error?.message}</pre>\n                    </details>\n                    <Button \n                        variant=\"primary\"\n                        onClick={() => {\n                            this.setState({ hasError: false, error: null });\n                        }}\n                    >\n                        Try again\n                    </Button>\n                </div>\n            );\n        }\n\n        return this.props.children;\n    }\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/app/MainApp.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":135,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":135,"endColumn":19,"suggestions":[{"fix":{"range":[6557,6692],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":232,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":232,"endColumn":18,"suggestions":[{"fix":{"range":[9788,9836],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":355,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":355,"endColumn":21,"suggestions":[{"fix":{"range":[14687,14759],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":439,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":439,"endColumn":19,"suggestions":[{"fix":{"range":[17284,17355],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":493,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":493,"endColumn":19,"suggestions":[{"fix":{"range":[18993,19072],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":522,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":522,"endColumn":19,"suggestions":[{"fix":{"range":[19948,20014],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":561,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":561,"endColumn":20,"suggestions":[{"fix":{"range":[21096,21139],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":602,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":602,"endColumn":24,"suggestions":[{"fix":{"range":[22624,22817],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":610,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":610,"endColumn":21,"suggestions":[{"fix":{"range":[22905,22980],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":684,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":684,"endColumn":19,"suggestions":[{"fix":{"range":[25342,25408],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":696,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":696,"endColumn":19,"suggestions":[{"fix":{"range":[25782,25832],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":818,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":818,"endColumn":19,"suggestions":[{"fix":{"range":[29113,29184],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":840,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":840,"endColumn":20,"suggestions":[{"fix":{"range":[29989,30047],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef, useMemo } from 'preact/hooks';\nimport type { ComponentChildren } from 'preact';\nimport ChatContainer from '@/features/chat/components/ChatContainer';\nimport DragDropOverlay from '@/features/media/components/DragDropOverlay';\nimport WorkspacePage from '@/features/chat/pages/WorkspacePage';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport type { UIPracticeConfig } from '@/shared/hooks/usePracticeConfig';\nimport type { WorkspaceType } from '@/shared/types/workspace';\nimport { useMessageHandling } from '@/shared/hooks/useMessageHandling';\nimport { useFileUploadWithContext } from '@/shared/hooks/useFileUpload';\nimport { setupGlobalKeyboardListeners } from '@/shared/utils/keyboard';\nimport type { FileAttachment } from '../../worker/types';\nimport { getConversationEndpoint, getConversationsEndpoint } from '@/config/api';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { getWorkspaceConversationsPath, getWorkspaceMattersPath } from '@/shared/utils/workspace';\nimport WelcomeModal from '@/features/modals/components/WelcomeModal';\nimport { useWelcomeModal } from '@/features/modals/hooks/useWelcomeModal';\nimport { getPreferencesCategory, updatePreferencesCategory } from '@/shared/lib/preferencesApi';\nimport type { OnboardingPreferences } from '@/shared/types/preferences';\nimport { BusinessWelcomePrompt } from '@/features/onboarding/components/BusinessWelcomePrompt';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { clearPendingPracticeInviteLink, readPendingPracticeInviteLink } from '@/shared/utils/practiceInvites';\nimport { usePracticeManagement } from '@/shared/hooks/usePracticeManagement';\nimport { usePracticeDetails } from '@/shared/hooks/usePracticeDetails';\nimport { useTranslation } from '@/shared/i18n/hooks';\n\nimport type { ConversationMetadata, ConversationMode } from '@/shared/types/conversation';\nimport { logConversationEvent } from '@/shared/lib/conversationApi';\nimport { hasLeadReviewPermission } from '@/shared/utils/leadPermissions';\nimport { normalizePracticeRole } from '@/shared/utils/practiceRoles';\nimport { PracticeMattersPage } from '@/features/matters/pages/PracticeMattersPage';\nimport { PracticeClientsPage } from '@/features/clients/pages/PracticeClientsPage';\nimport { ClientMattersPage } from '@/features/matters/pages/ClientMattersPage';\nimport { useConversationSystemMessages } from '@/features/chat/hooks/useConversationSystemMessages';\nimport WorkspaceConversationHeader from '@/features/chat/components/WorkspaceConversationHeader';\nimport BriefStrengthIndicator from '@/features/chat/components/BriefStrengthIndicator';\nimport PracticeConversationHeaderMenu from '@/features/chat/components/PracticeConversationHeaderMenu';\nimport { formatRelativeTime } from '@/features/matters/utils/formatRelativeTime';\nimport { initializeAccentColor } from '@/shared/utils/accentColors';\n\ntype WorkspaceView = 'home' | 'list' | 'conversation' | 'matters' | 'clients';\nexport type LayoutMode = 'embed' | 'mobile' | 'desktop';\n\n// Main application component (non-auth pages)\nexport function MainApp({\n  practiceId,\n  practiceConfig,\n  isPracticeView,\n  workspace,\n  chatContent,\n  routeConversationId,\n  publicPracticeSlug,\n  publicWorkspaceView,\n  practiceWorkspaceView,\n  clientWorkspaceView,\n  clientPracticeSlug,\n  practiceSlug\n}: {\n  practiceId: string;\n  practiceConfig: UIPracticeConfig;\n  isPracticeView: boolean;\n  workspace: WorkspaceType;\n  chatContent?: ComponentChildren;\n  routeConversationId?: string;\n  publicPracticeSlug?: string;\n  publicWorkspaceView?: WorkspaceView;\n  practiceWorkspaceView?: WorkspaceView;\n  clientWorkspaceView?: WorkspaceView;\n  clientPracticeSlug?: string;\n  practiceSlug?: string;\n}) {\n  // Core state\n  const [clearInputTrigger, setClearInputTrigger] = useState(0);\n  const [isRecording, setIsRecording] = useState(false);\n  const { navigate } = useNavigation();\n  const [showBusinessWelcome, setShowBusinessWelcome] = useState(false);\n  const [conversationId, setConversationId] = useState<string | null>(null);\n  const [isCreatingConversation, setIsCreatingConversation] = useState(false);\n  const [conversationMode, setConversationMode] = useState<ConversationMode | null>(null);\n  const [dismissedIntakeAuthFor, setDismissedIntakeAuthFor] = useState<string | null>(null);\n  const [isPaymentAuthPromptOpen, setIsPaymentAuthPromptOpen] = useState(false);\n  const conversationRestoreAttemptedRef = useRef(false);\n\n  // Data & Hooks (Moved up)\n  const { session, isPending: sessionIsPending, isAnonymous, activeMemberRole } = useSessionContext();\n  const {\n    currentPractice,\n    acceptMatter,\n    rejectMatter\n  } = usePracticeManagement({\n    autoFetchPractices: workspace !== 'public',\n    fetchInvitations: workspace !== 'public'\n  });\n\n  const isPublicWorkspace = workspace === 'public';\n  const resolvedPracticeLogo = isPublicWorkspace\n    ? (practiceConfig.profileImage ?? null)\n    : (currentPractice?.logo ?? practiceConfig?.profileImage ?? null);\n  const resolvedPracticeName = isPublicWorkspace\n    ? (practiceConfig.name ?? '')\n    : (currentPractice?.name ?? practiceConfig.name ?? '');\n  const resolvedPracticeSlug = practiceSlug\n    ?? currentPractice?.slug\n    ?? practiceConfig?.slug\n    ?? undefined;\n\n  const resolvedPublicPracticeSlug = useMemo(() => {\n    if (!isPublicWorkspace) return null;\n    return publicPracticeSlug ?? practiceConfig.slug ?? null;\n  }, [isPublicWorkspace, practiceConfig.slug, publicPracticeSlug]);\n  const resolvedClientPracticeSlug = useMemo(() => {\n    if (workspace !== 'client') return null;\n    return clientPracticeSlug ?? practiceConfig.slug ?? null;\n  }, [clientPracticeSlug, practiceConfig.slug, workspace]);\n  const publicConversationsBasePath = useMemo(() => {\n    if (!resolvedPublicPracticeSlug) return null;\n    return `/public/${encodeURIComponent(resolvedPublicPracticeSlug)}/conversations`;\n  }, [resolvedPublicPracticeSlug]);\n  const conversationResetKey = useMemo(() => {\n    if (isPublicWorkspace) return resolvedPublicPracticeSlug ?? '';\n    return practiceId;\n  }, [isPublicWorkspace, practiceId, resolvedPublicPracticeSlug]);\n\n  useEffect(() => {\n    setConversationId(null);\n    setConversationMode(null);\n    conversationRestoreAttemptedRef.current = false;\n  }, [conversationResetKey]);\n\n  const normalizedRouteConversationId = useMemo(() => {\n    if (!routeConversationId) return null;\n    try {\n      return decodeURIComponent(routeConversationId);\n    } catch (error) {\n      console.warn('[MainApp] Failed to decode conversation id from route params', {\n        id: routeConversationId,\n        error\n      });\n      return routeConversationId;\n    }\n  }, [routeConversationId]);\n\n  const activeConversationId = normalizedRouteConversationId ?? conversationId;\n\n  const isAnonymousUser = isAnonymous;\n  const isPracticeWorkspace = workspace === 'practice';\n  const isAuthenticatedClient = Boolean(\n    workspace === 'public' &&\n    session?.user &&\n    !session.user.isAnonymous &&\n    normalizePracticeRole(activeMemberRole) === 'client'\n  );\n  const conversationCacheKey = useMemo(() => {\n    if (isPublicWorkspace) {\n      return null;\n    }\n    if (!practiceId || !session?.user?.id) {\n      return null;\n    }\n    return `chat:lastConversation:${workspace}:${practiceId}:${session.user.id}`;\n  }, [isPublicWorkspace, practiceId, session?.user?.id, workspace]);\n  const effectivePracticeId = useMemo(() => {\n    if (isPublicWorkspace) {\n      if (\n        practiceConfig.id &&\n        resolvedPublicPracticeSlug &&\n        practiceConfig.slug === resolvedPublicPracticeSlug\n      ) {\n        return practiceConfig.id;\n      }\n      return practiceId || undefined;\n    }\n    return practiceId || undefined;\n  }, [isPublicWorkspace, practiceConfig.id, practiceConfig.slug, practiceId, resolvedPublicPracticeSlug]);\n\n  // Practice data is now passed as props\n\n  // Using our custom practice system instead of Better Auth's organization plugin\n  // Removed unused submitUpgrade\n  const { showError, showInfo } = useToastContext();\n  const showErrorRef = useRef(showError);\n  const practiceWelcomeCheckRef = useRef(false);\n  const isSelectingRef = useRef(false);\n  useEffect(() => {\n    showErrorRef.current = showError;\n  }, [showError]);\n\n\n  const practiceDetailsId = workspace === 'public'\n    ? (resolvedPublicPracticeSlug ?? practiceConfig.slug ?? practiceId ?? null)\n    : practiceId;\n  const practiceDetailsSlug = workspace === 'public'\n    ? resolvedPublicPracticeSlug\n    : workspace === 'client'\n      ? resolvedClientPracticeSlug\n      : (currentPractice?.slug ?? practiceConfig.slug ?? null);\n  const {\n    details: practiceDetails,\n    fetchDetails: fetchPracticeDetails,\n    hasDetails: hasPracticeDetails\n  } = usePracticeDetails(practiceDetailsId, practiceDetailsSlug);\n\n  useEffect(() => {\n    if (!practiceDetailsId || hasPracticeDetails) return;\n    void fetchPracticeDetails();\n  }, [fetchPracticeDetails, hasPracticeDetails, practiceDetailsId]);\n\n  useEffect(() => {\n    if (workspace === 'public' || workspace === 'client') {\n      initializeAccentColor(practiceConfig.accentColor);\n      return;\n    }\n    const practiceAccentColor = practiceDetails?.accentColor\n      ?? currentPractice?.accentColor\n      ?? practiceConfig.accentColor;\n    initializeAccentColor(practiceAccentColor);\n  }, [\n    currentPractice?.accentColor,\n    practiceConfig.accentColor,\n    practiceDetails?.accentColor,\n    workspace\n  ]);\n\n\n\n  const handleMessageError = useCallback((error: string | Error) => {\n    const message = typeof error === 'string' ? error : error.message;\n    const normalized = message.toLowerCase();\n    if (normalized.includes('chat connection closed')) {\n      return;\n    }\n    console.error('Message handling error:', error);\n    showErrorRef.current?.(message || 'We hit a snag sending that message.');\n  }, []);\n\n  const handleConversationMetadataUpdated = useCallback((metadata: ConversationMetadata | null) => {\n    if (metadata?.mode) {\n      setConversationMode(metadata.mode);\n    }\n  }, []);\n\n  const realMessageHandling = useMessageHandling({\n    practiceId: effectivePracticeId,\n    practiceSlug: practiceConfig.slug ?? undefined,\n    conversationId: activeConversationId ?? undefined,\n    mode: conversationMode,\n    onConversationMetadataUpdated: handleConversationMetadataUpdated,\n    onError: handleMessageError\n  });\n\n  const messages = realMessageHandling.messages;\n  const addMessage = realMessageHandling.addMessage;\n  const clearMessages = realMessageHandling.clearMessages;\n  const requestMessageReactions = realMessageHandling.requestMessageReactions;\n  const toggleMessageReaction = realMessageHandling.toggleMessageReaction;\n  const conversationMetadata = realMessageHandling.conversationMetadata;\n  const intakeStatus = realMessageHandling.intakeStatus;\n  const intakeConversationState = realMessageHandling.intakeConversationState;\n  const handleIntakeCtaResponse = realMessageHandling.handleIntakeCtaResponse;\n  const slimContactDraft = realMessageHandling.slimContactDraft;\n  const handleSlimFormContinue = realMessageHandling.handleSlimFormContinue;\n  const handleBuildBrief = realMessageHandling.handleBuildBrief;\n  const handleSubmitNow = realMessageHandling.handleSubmitNow;\n  const startConsultFlow = realMessageHandling.startConsultFlow;\n  const updateConversationMetadata = realMessageHandling.updateConversationMetadata;\n  const isConsultFlowActive = realMessageHandling.isConsultFlowActive;\n  const ingestServerMessages = realMessageHandling.ingestServerMessages;\n  const messagesReady = realMessageHandling.messagesReady;\n  const hasMoreMessages = realMessageHandling.hasMoreMessages;\n  const isLoadingMoreMessages = realMessageHandling.isLoadingMoreMessages;\n  const loadMoreMessages = realMessageHandling.loadMoreMessages;\n\n  const intakeUuid = intakeStatus?.intakeUuid ?? null;\n  const intakeAuthTarget = useMemo(() => {\n    if (!isPublicWorkspace) return null;\n    if (!intakeUuid) return null;\n    if (intakeStatus?.paymentRequired && !intakeStatus?.paymentReceived) return null;\n    return intakeUuid;\n  }, [\n    intakeUuid,\n    intakeStatus?.paymentReceived,\n    intakeStatus?.paymentRequired,\n    isPublicWorkspace\n  ]);\n\n  const { t } = useTranslation('common');\n  const shouldShowIntakeAuthPrompt = Boolean(\n    intakeAuthTarget && dismissedIntakeAuthFor !== intakeAuthTarget\n  );\n  const shouldShowAuthPrompt = shouldShowIntakeAuthPrompt || isPaymentAuthPromptOpen;\n\n  const intakeAuthTitle = t('intake.authTitle');\n  const intakeAuthDescription = resolvedPracticeName\n    ? t('intake.authDescription', { practice: resolvedPracticeName })\n    : t('intake.authDescriptionFallback');\n  const awaitingInvitePath = useMemo(() => {\n    if (!isPublicWorkspace || !intakeUuid) return null;\n    const resolvedPracticeSlugLocal = resolvedPublicPracticeSlug ?? practiceConfig.slug ?? '';\n    const params = new URLSearchParams();\n    params.set('intakeUuid', intakeUuid);\n    if (resolvedPracticeSlugLocal) params.set('practiceSlug', resolvedPracticeSlugLocal);\n    if (resolvedPracticeName) params.set('practiceName', resolvedPracticeName);\n    if (activeConversationId) params.set('conversationId', activeConversationId);\n    return `/auth/awaiting-invite?${params.toString()}`;\n  }, [\n    activeConversationId,\n    intakeUuid,\n    isPublicWorkspace,\n    practiceConfig.slug,\n    resolvedPracticeName,\n    resolvedPublicPracticeSlug\n  ]);\n\n  const handleIntakeAuthSuccess = useCallback(async () => {\n    if (!awaitingInvitePath) return;\n\n    if (intakeAuthTarget) {\n      setDismissedIntakeAuthFor(intakeAuthTarget);\n    }\n    navigate(awaitingInvitePath, true);\n  }, [\n    awaitingInvitePath,\n    intakeAuthTarget,\n    navigate\n  ]);\n\n  const handlePaymentAuthRequest = useCallback(() => {\n    setIsPaymentAuthPromptOpen(true);\n  }, []);\n\n  const handleAuthPromptClose = useCallback(() => {\n    if (isPaymentAuthPromptOpen) {\n      setIsPaymentAuthPromptOpen(false);\n    }\n    if (intakeAuthTarget) {\n      setDismissedIntakeAuthFor(intakeAuthTarget);\n    }\n  }, [intakeAuthTarget, isPaymentAuthPromptOpen]);\n\n  const handleAuthPromptSuccess = useCallback(async () => {\n    if (isPaymentAuthPromptOpen) {\n      setIsPaymentAuthPromptOpen(false);\n    }\n    await handleIntakeAuthSuccess();\n  }, [handleIntakeAuthSuccess, isPaymentAuthPromptOpen]);\n\n  useEffect(() => {\n    if (!awaitingInvitePath || !shouldShowAuthPrompt || typeof window === 'undefined') {\n      return;\n    }\n    try {\n      window.sessionStorage.setItem('intakeAwaitingInvitePath', awaitingInvitePath);\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.warn('[MainApp] Failed to persist intake awaiting path', error);\n      }\n    }\n  }, [awaitingInvitePath, shouldShowAuthPrompt]);\n\n  useEffect(() => {\n    clearMessages();\n  }, [practiceId, clearMessages]);\n\n  const createConversation = useCallback(async () => {\n    if (isPracticeWorkspace) return null;\n    if (!practiceId || !session?.user || isCreatingConversation) return null;\n\n    try {\n      setIsCreatingConversation(true);\n\n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json'\n      };\n      const params = new URLSearchParams({ practiceId });\n      const url = `${getConversationsEndpoint()}?${params.toString()}`;\n\n      const response = await fetch(url, {\n        method: 'POST',\n        headers,\n        credentials: 'include',\n        body: JSON.stringify({\n          participantUserIds: [session.user.id],\n          metadata: { source: 'chat' },\n          practiceId\n        })\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({})) as { error?: string };\n        throw new Error(errorData.error || `HTTP ${response.status}`);\n      }\n\n      const data = await response.json() as { success: boolean; error?: string; data?: { id: string } };\n      if (!data.success || !data.data?.id) {\n        throw new Error(data.error || 'Failed to start conversation');\n      }\n\n      setConversationId(data.data.id);\n      return data.data.id;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to start conversation';\n      throw new Error(message);\n    } finally {\n      setIsCreatingConversation(false);\n    }\n  }, [isPracticeWorkspace, practiceId, session?.user, isCreatingConversation]);\n\n  const restoreConversationFromCache = useCallback(async () => {\n    if (typeof window === 'undefined') {\n      return null;\n    }\n    if (!conversationCacheKey || !practiceId || !session?.user) {\n      return null;\n    }\n    const cached = window.localStorage.getItem(conversationCacheKey);\n    if (!cached) {\n      return null;\n    }\n    if (activeConversationId === cached) {\n      return cached;\n    }\n\n    try {\n      const params = new URLSearchParams({ practiceId });\n      const response = await fetch(\n        `${getConversationEndpoint(cached)}?${params.toString()}`,\n        {\n          method: 'GET',\n          credentials: 'include'\n        }\n      );\n      if (!response.ok) {\n        window.localStorage.removeItem(conversationCacheKey);\n        return null;\n      }\n      setConversationId(cached);\n      return cached;\n    } catch (error) {\n      console.warn('[MainApp] Failed to restore cached conversation', error);\n      return null;\n    }\n  }, [\n    conversationCacheKey,\n    activeConversationId,\n    practiceId,\n    session?.user\n  ]);\n\n  const applyConversationMode = useCallback(async (\n    nextMode: ConversationMode,\n    activeConversationId: string,\n    source: 'intro_gate' | 'composer_footer' | 'home_cta'\n  ) => {\n    if (!practiceId) return;\n    await updateConversationMetadata({\n      mode: nextMode\n    }, activeConversationId);\n    setConversationMode(nextMode);\n    void logConversationEvent(activeConversationId, practiceId, 'mode_selected', { mode: nextMode, source });\n    if (nextMode === 'REQUEST_CONSULTATION') {\n      startConsultFlow(activeConversationId);\n      void logConversationEvent(activeConversationId, practiceId, 'consult_flow_started', { source });\n    }\n  }, [\n    practiceId,\n    startConsultFlow,\n    updateConversationMetadata\n  ]);\n\n  const handleModeSelection = useCallback(async (\n    nextMode: ConversationMode,\n    source: 'intro_gate' | 'composer_footer'\n  ) => {\n    try {\n      if (isSelectingRef.current) {\n        return;\n      }\n      isSelectingRef.current = true;\n\n      let currentConversationId = activeConversationId;\n      if (!currentConversationId && !isCreatingConversation) {\n        currentConversationId = await createConversation();\n      }\n      if (!currentConversationId || !practiceId) {\n        return;\n      }\n\n      await applyConversationMode(nextMode, currentConversationId, source);\n    } catch (error) {\n      setConversationMode(null);\n      const message = error instanceof Error ? error.message : 'Unable to start conversation';\n      showErrorRef.current?.(message);\n      console.warn('[MainApp] Failed to persist conversation mode selection', error);\n    } finally {\n      isSelectingRef.current = false;\n    }\n  }, [\n    applyConversationMode,\n    activeConversationId,\n    createConversation,\n    isCreatingConversation,\n    practiceId\n  ]);\n\n  const handleStartNewConversation = useCallback(async (nextMode: ConversationMode): Promise<string> => {\n    try {\n      if (isSelectingRef.current) {\n        throw new Error('Conversation start already in progress');\n      }\n      isSelectingRef.current = true;\n      if (!practiceId) {\n        throw new Error('Practice context is required');\n      }\n      const newConversationId = await createConversation();\n      if (!newConversationId) {\n        throw new Error('Unable to create conversation');\n      }\n      await applyConversationMode(nextMode, newConversationId, 'home_cta');\n      return newConversationId;\n    } catch (error) {\n      setConversationMode(null);\n      console.warn('[MainApp] Failed to start new conversation', error);\n      throw error;\n    } finally {\n      isSelectingRef.current = false;\n    }\n  }, [applyConversationMode, createConversation, practiceId]);\n\n  const handleSendMessage = useCallback(async (\n    message: string,\n    attachments: FileAttachment[] = [],\n    replyToMessageId?: string | null\n  ) => {\n    if (!activeConversationId) {\n      showErrorRef.current?.('Setting up your conversation. Please try again momentarily.');\n      if (!isCreatingConversation) {\n        void createConversation();\n      }\n      return;\n    }\n\n    await realMessageHandling.sendMessage(message, attachments, replyToMessageId ?? null);\n  }, [activeConversationId, isCreatingConversation, createConversation, realMessageHandling]);\n\n  const {\n    previewFiles,\n    uploadingFiles,\n    isDragging,\n    setIsDragging,\n    handleCameraCapture,\n    handleFileSelect,\n    removePreviewFile,\n    clearPreviewFiles,\n    cancelUpload,\n    isReadyToUpload\n  } = useFileUploadWithContext({\n    conversationId: activeConversationId ?? undefined,\n    onError: (error) => {\n      // Handle file upload error\n\n      console.error('File upload error:', error);\n      showErrorRef.current?.(typeof error === 'string' ? error : 'File upload failed. Please try again.');\n    }\n  });\n\n  // Session error handling removed - no longer using sessions\n\n  // Welcome modal state via server-truth + session debounce\n  const { shouldShow: shouldShowWelcome, markAsShown: markWelcomeAsShown } = useWelcomeModal({\n    enabled: workspace !== 'public'\n  });\n  const showWelcomeModal = shouldShowWelcome && workspace !== 'public';\n\n  // Note: Auto-practice creation removed - clients don't need practices.\n  // Practice members (lawyers) will create practices through onboarding/upgrade flow.\n  // Clients chat with practices via widget (practiceId from URL), not their own practice.\n\n\n\n\n  // Check if we should show practice welcome modal\n  useEffect(() => {\n    if (workspace !== 'practice') {\n      practiceWelcomeCheckRef.current = false;\n      setShowBusinessWelcome(false);\n      return;\n    }\n    if (sessionIsPending || isAnonymous || !session?.user?.id) {\n      setShowBusinessWelcome(false);\n      return;\n    }\n    if (practiceWelcomeCheckRef.current) return;\n    practiceWelcomeCheckRef.current = true;\n\n    const checkPracticeWelcome = async () => {\n      try {\n        const prefs = await getPreferencesCategory<OnboardingPreferences>('onboarding');\n        const hasCompletedOnboarding = prefs?.completed === true;\n        const shouldShow = hasCompletedOnboarding && !prefs?.practice_welcome_shown;\n\n        if (import.meta.env.DEV) {\n          console.debug('[PRACTICE_WELCOME][CHECK] preferences', {\n            completed: prefs?.completed ?? null,\n            practice_welcome_shown: prefs?.practice_welcome_shown ?? null\n          });\n        }\n\n        setShowBusinessWelcome(shouldShow);\n      } catch (error) {\n        console.warn('[PRACTICE_WELCOME][CHECK] preferences fetch failed:', error);\n        practiceWelcomeCheckRef.current = false;\n        setShowBusinessWelcome(false);\n      }\n    };\n\n    void checkPracticeWelcome();\n  }, [isAnonymous, session?.user?.id, sessionIsPending, workspace]);\n\n  // Pricing modal removed; subscription tier derivation not needed here.\n\n  // User tier is now derived directly from practice - no need for custom event listeners\n\n  const shouldRequireModeSelection = workspace === 'public';\n  const isConversationReady = Boolean(activeConversationId && !isCreatingConversation);\n  const isAuthReady = Boolean(session?.user) && !sessionIsPending;\n  const isSessionReady = isConversationReady && isAuthReady;\n  const isSocketReady = isConversationReady && isAuthReady ? realMessageHandling.isSocketReady : false;\n  const isComposerDisabled = shouldRequireModeSelection && !conversationMode;\n  const canChat = Boolean(practiceId) && (!isPracticeWorkspace ? Boolean(isPracticeView) : Boolean(activeConversationId));\n\n  useEffect(() => {\n    if (isPublicWorkspace) return;\n    if (!isAuthReady) return;\n    if (!practiceId) return;\n    if (activeConversationId) return;\n    if (isCreatingConversation) return;\n    if (conversationRestoreAttemptedRef.current) return;\n    conversationRestoreAttemptedRef.current = true;\n\n    (async () => {\n      try {\n        const restored = await restoreConversationFromCache();\n        if (restored) {\n          return;\n        }\n      } catch {\n        conversationRestoreAttemptedRef.current = false;\n      }\n    })();\n  }, [\n    activeConversationId,\n    isAuthReady,\n    isCreatingConversation,\n    isPublicWorkspace,\n    practiceId,\n    restoreConversationFromCache,\n    session?.user?.id\n  ]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n    const inviteLink = readPendingPracticeInviteLink();\n    if (!inviteLink) {\n      return;\n    }\n\n    try {\n      const resolved = new URL(inviteLink, window.location.origin);\n      const sameOrigin = resolved.origin === window.location.origin;\n      if (sameOrigin) {\n        navigate(`${resolved.pathname}${resolved.search}${resolved.hash}`);\n        clearPendingPracticeInviteLink();\n        return;\n      }\n\n      const opened = window.open(resolved.toString(), '_blank', 'noopener');\n      if (opened) {\n        clearPendingPracticeInviteLink();\n        return;\n      }\n    } catch (error) {\n      console.warn('[Invite] Failed to navigate to invite link', error);\n    }\n\n    showInfo('Join your practice', 'Open your invite link to finish joining the practice.');\n  }, [navigate, showInfo]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    if (!conversationCacheKey || !activeConversationId) return;\n    try {\n      window.localStorage.setItem(conversationCacheKey, activeConversationId);\n    } catch (e) {\n      console.warn('Failed to save conversation ID', e);\n    }\n  }, [conversationCacheKey, activeConversationId]);\n\n  const currentUserRole = normalizePracticeRole(activeMemberRole) ?? 'member';\n  const canReviewLeads = hasLeadReviewPermission(currentUserRole, currentPractice?.metadata ?? null);\n  const leadReviewActions = useMemo(() => {\n    if (workspace !== 'practice') return undefined;\n    if (!practiceId || !activeConversationId) return undefined;\n    return {\n      practiceId,\n      practiceName: resolvedPracticeName,\n      conversationId: activeConversationId,\n      canReviewLeads,\n      acceptMatter,\n      rejectMatter\n    };\n  }, [\n    workspace,\n    practiceId,\n    activeConversationId,\n    resolvedPracticeName,\n    canReviewLeads,\n    acceptMatter,\n    rejectMatter\n  ]);\n\n\n  useConversationSystemMessages({\n    conversationId: activeConversationId,\n    practiceId: effectivePracticeId,\n    practiceConfig,\n    messagesReady,\n    messages,\n    conversationMode,\n    isConsultFlowActive,\n    shouldRequireModeSelection,\n    ingestServerMessages\n  });\n\n  // Create stable callback references for keyboard handlers\n  const handleEscape = useCallback(() => {\n    if (previewFiles.length > 0) {\n      clearPreviewFiles();\n      setClearInputTrigger(prev => prev + 1);\n    }\n  }, [previewFiles.length, clearPreviewFiles]);\n\n  const handleFocusInput = useCallback(() => {\n    const textarea = document.querySelector('.message-input') as HTMLTextAreaElement;\n    if (textarea) {\n      textarea.focus();\n    }\n  }, []);\n\n  // Setup global event handlers\n  useEffect(() => {\n    // Setup keyboard handlers\n    const cleanupKeyboard = setupGlobalKeyboardListeners({\n      onEscape: handleEscape,\n      onSubmit: () => {\n        // This will be handled by ChatContainer\n      },\n      onFocusInput: handleFocusInput\n    });\n\n    return () => {\n      cleanupKeyboard?.();\n    };\n  }, [handleEscape, handleFocusInput]);\n\n  // Setup scroll behavior\n  useEffect(() => {\n    if (typeof document === 'undefined') return;\n\n    const messageList = document.querySelector('.message-list');\n    if (!messageList) return;\n\n    let scrollTimer: number | null = null;\n\n    const handleScroll = () => {\n      // Add scrolling class when scrolling starts\n      messageList.classList.add('scrolling');\n\n      // Clear any existing timer\n      if (scrollTimer) {\n        clearTimeout(scrollTimer);\n        scrollTimer = null;\n      }\n\n      // Set a timer to remove the scrolling class after scrolling stops\n      scrollTimer = window.setTimeout(() => {\n        messageList.classList.remove('scrolling');\n      }, 1000); // Hide scrollbar 1 second after scrolling stops\n    };\n\n    messageList.addEventListener('scroll', handleScroll);\n\n    return () => {\n      messageList.removeEventListener('scroll', handleScroll);\n      if (scrollTimer) {\n        clearTimeout(scrollTimer);\n      }\n    };\n  }, []);\n\n  // Handle welcome modal using server-truth hook\n  const handleWelcomeComplete = async () => {\n    await markWelcomeAsShown();\n  };\n\n  const handleWelcomeClose = async () => {\n    await markWelcomeAsShown();\n  };\n\n  const handleBusinessWelcomeClose = async () => {\n    setShowBusinessWelcome(false);\n    try {\n      await updatePreferencesCategory('onboarding', {\n        practice_welcome_shown: true\n      });\n    } catch (error) {\n      console.warn('[PRACTICE_WELCOME] Failed to update preferences', error);\n      showError('Update failed', 'We could not save your preference. You may see this prompt again.');\n    }\n    navigate('/settings/practice');\n  };\n\n  // Handle media capture\n  const handleMediaCaptureWrapper = async (blob: Blob, type: 'audio' | 'video') => {\n    try {\n      // Create a File object from the blob\n      const fileName = `Recording_${new Date().toISOString()}.${type === 'audio' ? 'webm' : 'mp4'}`;\n      const file = new File([blob], fileName, { type: blob.type });\n\n      // Upload the file to backend and get metadata\n      const uploadedFiles = await handleFileSelect([file]);\n\n      // Send a message with the uploaded file metadata\n      await handleSendMessage(`I've recorded a ${type} message.`, uploadedFiles);\n\n    } catch (_error) {\n      // Handle media upload error\n\n      console.error('Failed to upload captured media:', _error);\n      showErrorRef.current?.('Failed to upload recording. Please try again.');\n    }\n  };\n\n  const resolvedPracticeDescription = practiceDetails?.description\n    ?? currentPractice?.description\n    ?? practiceConfig?.description\n    ?? '';\n  const filteredMessagesForHeader = useMemo(() => {\n    const base = messages.filter((message) =>\n      message.metadata?.systemMessageKey !== 'ask_question_help'\n    );\n    const hasNonSystemMessages = base.some((message) => message.role !== 'system');\n    return hasNonSystemMessages ? base.filter((message) => message.metadata?.systemMessageKey !== 'intro') : base;\n  }, [messages]);\n  const headerPresenceStatus = typeof isSocketReady === 'boolean'\n    ? (isSocketReady ? 'active' : 'inactive')\n    : undefined;\n  const headerActiveTimeLabel = useMemo(() => {\n    if (headerPresenceStatus === 'active') {\n      return 'Active';\n    }\n    const lastTimestamp = [...filteredMessagesForHeader]\n      .reverse()\n      .find((message) => typeof message.timestamp === 'number')?.timestamp;\n    if (!lastTimestamp) {\n      return 'Inactive';\n    }\n    const relative = formatRelativeTime(new Date(lastTimestamp).toISOString());\n    return relative ? `Active ${relative}` : 'Inactive';\n  }, [filteredMessagesForHeader, headerPresenceStatus]);\n  const conversationsBasePath = useMemo(() => {\n    if (workspace === 'practice') {\n      return getWorkspaceConversationsPath('practice', resolvedPracticeSlug);\n    }\n    if (workspace === 'client') {\n      return getWorkspaceConversationsPath('client', resolvedClientPracticeSlug);\n    }\n    return publicConversationsBasePath;\n  }, [publicConversationsBasePath, resolvedClientPracticeSlug, resolvedPracticeSlug, workspace]);\n  const conversationBackPath = useMemo(() => {\n    if (workspace === 'public') {\n      return resolvedPublicPracticeSlug\n        ? `/public/${encodeURIComponent(resolvedPublicPracticeSlug)}`\n        : '/public';\n    }\n    return conversationsBasePath;\n  }, [conversationsBasePath, resolvedPublicPracticeSlug, workspace]);\n  const headerRightSlot = useMemo(() => {\n    if (workspace === 'practice') {\n      return (\n        <PracticeConversationHeaderMenu\n          practiceId={practiceId}\n          conversationId={activeConversationId ?? undefined}\n        />\n      );\n    }\n    if (conversationMode === 'REQUEST_CONSULTATION') {\n      return <BriefStrengthIndicator intakeConversationState={intakeConversationState} />;\n    }\n    return undefined;\n  }, [workspace, practiceId, activeConversationId, conversationMode, intakeConversationState]);\n  const conversationHeaderContent = useMemo(() => {\n    if (!conversationsBasePath || !activeConversationId) return undefined;\n    return (\n      <WorkspaceConversationHeader\n        practiceName={resolvedPracticeName}\n        practiceLogo={resolvedPracticeLogo}\n        activeLabel={headerActiveTimeLabel}\n        presenceStatus={headerPresenceStatus}\n        onBack={() => navigate(conversationBackPath)}\n        rightSlot={headerRightSlot}\n      />\n    );\n  }, [\n    activeConversationId,\n    conversationBackPath,\n    conversationsBasePath,\n    headerActiveTimeLabel,\n    headerPresenceStatus,\n    headerRightSlot,\n    navigate,\n    resolvedPracticeLogo,\n    resolvedPracticeName\n  ]);\n\n  // Handle navigation to chats - removed since bottom nav is disabled\n  const shouldShowChatPlaceholder = workspace !== 'public' && !activeConversationId;\n\n  const layoutMode: LayoutMode = workspace === 'practice'\n    ? 'desktop'\n    : (workspace === 'client' ? 'mobile' : 'embed');\n\n  const chatPanel = chatContent ?? (\n    <div className=\"relative flex min-h-0 flex-1 flex-col\">\n      {shouldShowChatPlaceholder ? (\n        <div className=\"flex-1 flex items-center justify-center text-sm text-input-placeholder\">\n          {workspace === 'practice'\n            ? 'Select a conversation to view the thread.'\n            : 'Open a practice link to start chatting.'}\n        </div>\n      ) : (\n        <>\n          <div className=\"flex-1 min-h-0\">\n            <ChatContainer\n              messages={messages}\n              conversationTitle={conversationMetadata?.title ?? null}\n              onSendMessage={handleSendMessage}\n              onAddMessage={addMessage}\n              onSelectMode={handleModeSelection}\n              onToggleReaction={toggleMessageReaction}\n              onRequestReactions={requestMessageReactions}\n              composerDisabled={isComposerDisabled}\n              isPublicWorkspace={workspace === 'public'}\n              leadReviewActions={leadReviewActions}\n              messagesReady={messagesReady}\n              headerContent={conversationHeaderContent}\n              heightClassName={layoutMode === 'desktop' ? undefined : 'h-full'}\n              useFrame={layoutMode === 'desktop'}\n              layoutMode={layoutMode}\n              practiceConfig={{\n                name: resolvedPracticeName,\n                profileImage: resolvedPracticeLogo,\n                practiceId,\n                description: resolvedPracticeDescription,\n                slug: resolvedPracticeSlug,\n                introMessage: practiceConfig.introMessage\n              }}\n              onOpenSidebar={undefined}\n              practiceId={practiceId}\n              previewFiles={previewFiles}\n              uploadingFiles={uploadingFiles}\n              removePreviewFile={removePreviewFile}\n              clearPreviewFiles={clearPreviewFiles}\n              handleCameraCapture={handleCameraCapture}\n              handleFileSelect={async (files: File[]) => {\n                await handleFileSelect(files);\n              }}\n              cancelUpload={cancelUpload}\n              handleMediaCapture={handleMediaCaptureWrapper}\n              isRecording={isRecording}\n              setIsRecording={setIsRecording}\n              clearInput={clearInputTrigger}\n              isReadyToUpload={isReadyToUpload}\n              isSessionReady={isSessionReady}\n              isSocketReady={isSocketReady}\n              intakeStatus={intakeStatus}\n              intakeConversationState={intakeConversationState}\n              onIntakeCtaResponse={handleIntakeCtaResponse}\n              slimContactDraft={slimContactDraft}\n              onSlimFormContinue={handleSlimFormContinue}\n              onBuildBrief={handleBuildBrief}\n              onSubmitNow={handleSubmitNow}\n              isAnonymousUser={isAnonymousUser}\n              canChat={canChat}\n              hasMoreMessages={hasMoreMessages}\n              isLoadingMoreMessages={isLoadingMoreMessages}\n              onLoadMoreMessages={loadMoreMessages}\n              showAuthPrompt={shouldShowAuthPrompt}\n              authPromptTitle={intakeAuthTitle}\n              authPromptDescription={intakeAuthDescription}\n              authPromptCallbackUrl={awaitingInvitePath ?? undefined}\n              onAuthPromptRequest={isAnonymousUser ? handlePaymentAuthRequest : undefined}\n              onAuthPromptClose={handleAuthPromptClose}\n              onAuthPromptSuccess={handleAuthPromptSuccess}\n            />\n          </div>\n        </>\n      )}\n    </div>\n  );\n\n\n\n  const publicWorkspaceContent = workspace === 'public' ? (\n    <WorkspacePage\n      view={publicWorkspaceView ?? 'conversation'}\n      practiceId={practiceId}\n      practiceSlug={resolvedPublicPracticeSlug}\n      practiceName={resolvedPracticeName}\n      practiceLogo={resolvedPracticeLogo}\n      messages={messages}\n      layoutMode={layoutMode}\n      showClientTabs={isAuthenticatedClient}\n      onStartNewConversation={handleStartNewConversation}\n      chatView={chatPanel}\n    />\n  ) : null;\n\n  const resolvedClientWorkspaceView = useMemo<WorkspaceView | null>(() => {\n    if (workspace !== 'client') return null;\n    if (!clientWorkspaceView) return 'home';\n    if (clientWorkspaceView === 'conversation' && !activeConversationId) {\n      return 'list';\n    }\n    return clientWorkspaceView;\n  }, [activeConversationId, clientWorkspaceView, workspace]);\n\n  const clientWorkspaceContent = workspace === 'client' ? (\n    <WorkspacePage\n      view={resolvedClientWorkspaceView ?? 'home'}\n      practiceId={practiceId}\n      practiceSlug={clientPracticeSlug ?? resolvedClientPracticeSlug}\n      practiceName={resolvedPracticeName}\n      practiceLogo={resolvedPracticeLogo}\n      messages={messages}\n      layoutMode={layoutMode}\n      showClientTabs={true}\n      workspace=\"client\"\n      onStartNewConversation={handleStartNewConversation}\n      chatView={chatPanel}\n      mattersView={<ClientMattersPage />}\n    />\n  ) : null;\n\n  const resolvedPracticeWorkspaceView = useMemo<WorkspaceView | null>(() => {\n    if (workspace !== 'practice') return null;\n    if (!practiceWorkspaceView) return 'home';\n    if (practiceWorkspaceView === 'conversation' && !activeConversationId) {\n      return 'list';\n    }\n    return practiceWorkspaceView;\n  }, [activeConversationId, practiceWorkspaceView, workspace]);\n  const effectivePracticeSlug = practiceSlug ?? resolvedPracticeSlug ?? null;\n  const practiceMattersPath = useMemo(() => {\n    return getWorkspaceMattersPath('practice', effectivePracticeSlug);\n  }, [effectivePracticeSlug]);\n  const practiceWorkspaceContent = workspace === 'practice' ? (\n    <WorkspacePage\n      view={resolvedPracticeWorkspaceView ?? 'home'}\n      practiceId={practiceId}\n      practiceSlug={effectivePracticeSlug}\n      practiceName={resolvedPracticeName}\n      practiceLogo={resolvedPracticeLogo}\n      messages={messages}\n      layoutMode={layoutMode}\n      showPracticeTabs={true}\n      workspace=\"practice\"\n      onStartNewConversation={handleStartNewConversation}\n      chatView={chatPanel}\n      mattersView={\n        <PracticeMattersPage\n          basePath={practiceMattersPath ?? '/practice/matters'}\n        />\n      }\n      clientsView={<PracticeClientsPage />}\n    />\n  ) : null;\n\n  const mainContent = workspace === 'practice'\n    ? practiceWorkspaceContent\n    : (workspace === 'client' ? clientWorkspaceContent : publicWorkspaceContent);\n  // Render the main app\n  return (\n    <>\n      <DragDropOverlay isVisible={isDragging} onClose={() => setIsDragging(false)} />\n      <div className=\"min-h-dvh w-full\">\n        {mainContent}\n      </div>\n\n      {/* Welcome Modal */}\n      <WelcomeModal\n        isOpen={showWelcomeModal}\n        onClose={handleWelcomeClose}\n        onComplete={handleWelcomeComplete}\n        workspace={workspace === 'practice' ? 'practice' : 'client'}\n      />\n\n      {/* Business Welcome Modal */}\n      {showBusinessWelcome && (\n        <BusinessWelcomePrompt\n          isOpen={showBusinessWelcome}\n          onClose={handleBusinessWelcomeClose}\n        />\n      )}\n    </>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/app/SEOHead.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/config/api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/config/features.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/config/urls.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/AIThinkingIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/AuthGateOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/AuthPromptModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/BriefStrengthIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/ChatContainer.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":244,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":244,"endColumn":28,"suggestions":[{"fix":{"range":[8794,8853],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":359,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":359,"endColumn":22,"suggestions":[{"fix":{"range":[11802,11869],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":381,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":381,"endColumn":21,"suggestions":[{"fix":{"range":[12761,12830],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":384,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":384,"endColumn":19,"suggestions":[{"fix":{"range":[12889,12977],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":538,"column":33,"nodeType":"MemberExpression","messageId":"unexpected","endLine":538,"endColumn":46,"suggestions":[{"fix":{"range":[19961,20017],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport type { ComponentChildren } from 'preact';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport VirtualMessageList from './VirtualMessageList';\nimport MessageComposer from './MessageComposer';\nimport { ChatMessageUI } from '../../../../worker/types';\nimport { FileAttachment } from '../../../../worker/types';\nimport { ContactData, ContactForm } from '@/features/intake/components/ContactForm';\nimport { IntakePaymentModal } from '@/features/intake/components/IntakePaymentModal';\nimport { isValidStripePaymentLink, type IntakePaymentRequest } from '@/shared/utils/intakePayments';\nimport { createKeyPressHandler } from '@/shared/utils/keyboard';\nimport type { UploadingFile } from '@/shared/hooks/useFileUpload';\nimport { useMobileDetection } from '@/shared/hooks/useMobileDetection';\nimport AuthPromptModal from './AuthPromptModal';\nimport type { ConversationMode } from '@/shared/types/conversation';\nimport type { ReplyTarget } from '@/features/chat/types';\nimport { Button } from '@/shared/ui/Button';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { triggerIntakeInvitation } from '@/shared/lib/apiClient';\nimport type { MatterTransitionResult } from '@/shared/hooks/usePracticeManagement';\nimport type { LayoutMode } from '@/app/MainApp';\nimport type { IntakeConversationState } from '@/shared/types/intake';\nimport { getChatPatterns } from '../config/chatPatterns';\nimport { cn } from '@/shared/utils/cn';\n\nexport interface ChatContainerProps {\n  messages: ChatMessageUI[];\n  conversationTitle?: string | null;\n  onSendMessage: (message: string, attachments: FileAttachment[], replyToMessageId?: string | null) => void;\n  onAddMessage?: (message: ChatMessageUI) => void;\n  onSelectMode?: (mode: ConversationMode, source: 'intro_gate' | 'composer_footer') => void;\n  onToggleReaction?: (messageId: string, emoji: string) => void;\n  onRequestReactions?: (messageId: string) => void;\n  composerDisabled?: boolean;\n  isPublicWorkspace?: boolean;\n  practiceConfig?: {\n    name: string;\n    profileImage: string | null;\n    practiceId: string;\n    description?: string | null;\n    slug?: string | null;\n    introMessage?: string | null;\n  };\n  heightClassName?: string;\n  headerContent?: ComponentChildren;\n  useFrame?: boolean;\n  layoutMode?: LayoutMode;\n  onOpenSidebar?: () => void;\n  practiceId?: string;\n\n  // File handling props\n  previewFiles: FileAttachment[];\n  uploadingFiles: UploadingFile[];\n  removePreviewFile: (index: number) => void;\n  clearPreviewFiles: () => void;\n  handleFileSelect: (files: File[]) => Promise<void>;\n  handleCameraCapture: (file: File) => Promise<void>;\n  cancelUpload: (fileId: string) => void;\n  handleMediaCapture: (blob: Blob, type: 'audio' | 'video') => void;\n  isRecording: boolean;\n  setIsRecording: (v: boolean) => void;\n  isReadyToUpload?: boolean;\n  isSessionReady?: boolean;\n  isSocketReady?: boolean;\n  intakeStatus?: {\n    step: string;\n    decision?: string;\n    intakeUuid?: string | null;\n    paymentRequired?: boolean;\n    paymentReceived?: boolean;\n  };\n  intakeConversationState?: IntakeConversationState | null;\n  onIntakeCtaResponse?: (response: 'ready' | 'not_yet') => void;\n  onSlimFormContinue?: (data: ContactData) => void | Promise<void>;\n  onBuildBrief?: () => void;\n  onSubmitNow?: () => void | Promise<void>;\n  slimContactDraft?: {\n    name: string;\n    email: string;\n    phone: string;\n    city: string;\n    state: string;\n    opposingParty?: string;\n    description?: string;\n  } | null;\n  isAnonymousUser?: boolean;\n  canChat?: boolean;\n  hasMoreMessages?: boolean;\n  isLoadingMoreMessages?: boolean;\n  onLoadMoreMessages?: () => void | Promise<void>;\n  messagesReady?: boolean;\n  leadReviewActions?: {\n    practiceId: string;\n    practiceName: string;\n    conversationId: string;\n    canReviewLeads: boolean;\n    acceptMatter: (practiceId: string, matterId: string) => Promise<MatterTransitionResult>;\n    rejectMatter: (practiceId: string, matterId: string) => Promise<MatterTransitionResult>;\n    onLeadStatusChange?: () => void;\n  };\n\n  // Input control prop\n  clearInput?: number;\n\n  // Auth prompt overrides\n  showAuthPrompt?: boolean;\n  authPromptTitle?: string;\n  authPromptDescription?: string;\n  authPromptCallbackUrl?: string;\n  onAuthPromptRequest?: () => void;\n  onAuthPromptClose?: () => void;\n  onAuthPromptSuccess?: () => void;\n}\n\nconst ChatContainer: FunctionComponent<ChatContainerProps> = ({\n  messages,\n  conversationTitle,\n  onSendMessage,\n  onAddMessage: _onAddMessage,\n  isPublicWorkspace = false,\n  practiceConfig,\n  heightClassName,\n  headerContent,\n  useFrame = true,\n  layoutMode,\n  onOpenSidebar,\n  practiceId,\n  onToggleReaction,\n  onRequestReactions,\n  previewFiles,\n  uploadingFiles,\n  removePreviewFile,\n  clearPreviewFiles,\n  handleFileSelect,\n  handleCameraCapture,\n  cancelUpload,\n  handleMediaCapture,\n  isRecording,\n  setIsRecording,\n  isReadyToUpload,\n  isSessionReady,\n  isSocketReady,\n  intakeStatus,\n  intakeConversationState,\n  onIntakeCtaResponse,\n  onSlimFormContinue,\n  onBuildBrief,\n  onSubmitNow,\n  slimContactDraft,\n  clearInput,\n  isAnonymousUser,\n  canChat = true,\n  onSelectMode,\n  composerDisabled,\n  hasMoreMessages,\n  isLoadingMoreMessages,\n  onLoadMoreMessages,\n  messagesReady = true,\n  leadReviewActions,\n  showAuthPrompt = false,\n  authPromptTitle,\n  authPromptDescription,\n  authPromptCallbackUrl,\n  onAuthPromptRequest,\n  onAuthPromptClose,\n  onAuthPromptSuccess\n}) => {\n  const { t } = useTranslation('common');\n  const [inputValue, setInputValue] = useState('');\n  const textareaRef = useRef<HTMLTextAreaElement>(null);\n  const isMobile = useMobileDetection();\n  const [paymentRequest, setPaymentRequest] = useState<IntakePaymentRequest | null>(null);\n  const [pendingPaymentRequest, setPendingPaymentRequest] = useState<IntakePaymentRequest | null>(null);\n  const [isPaymentModalOpen, setIsPaymentModalOpen] = useState(false);\n  const [replyTarget, setReplyTarget] = useState<ReplyTarget | null>(null);\n  const isChatInputLocked = Boolean(composerDisabled) || isSessionReady === false || isSocketReady === false;\n  const baseMessages = isPublicWorkspace\n    ? messages.filter((message) => message.metadata?.systemMessageKey !== 'ask_question_help'\n      && message.metadata?.systemMessageKey !== 'intro')\n    : messages;\n  const hasNonSystemMessages = baseMessages.some((message) => message.role !== 'system');\n  const filteredMessages = hasNonSystemMessages\n    ? baseMessages.filter((message) => message.metadata?.systemMessageKey !== 'intro')\n    : baseMessages;\n  const shouldShowSlimForm = intakeStatus?.step === 'contact_form_slim';\n  // Simple resize handler for window size changes\n  useEffect(() => {\n    const handleResize = () => {\n      if (textareaRef.current) {\n        // Use the same improved auto-expand logic\n        textareaRef.current.style.height = 'auto';\n        const newHeight = Math.max(24, textareaRef.current.scrollHeight);\n        textareaRef.current.style.height = `${newHeight}px`;\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  // Initialize textarea height on mount\n  useEffect(() => {\n    if (textareaRef.current && textareaRef.current.value) {\n      textareaRef.current.style.height = 'auto';\n      const newHeight = Math.max(24, textareaRef.current.scrollHeight);\n      textareaRef.current.style.height = `${newHeight}px`;\n    }\n  }, []);\n\n  // Clear input when clearInput prop changes (numeric change counter)\n  useEffect(() => {\n    if (clearInput && clearInput > 0) {\n      setInputValue('');\n      if (textareaRef.current) {\n        textareaRef.current.value = '';\n        textareaRef.current.style.height = '24px';\n      }\n    }\n  }, [clearInput]);\n\n  const handleSubmit = () => {\n    if (isChatInputLocked) return;\n    if (!inputValue.trim() && previewFiles.length === 0) return;\n\n    const message = inputValue.trim();\n    const attachments = [...previewFiles];\n    const replyToMessageId = replyTarget?.messageId ?? null;\n\n    const lastMessage = filteredMessages[filteredMessages.length - 1];\n    const hasIntakeCta = Boolean(lastMessage?.metadata?.intakeReadyCta);\n    const canHandleCta = hasIntakeCta && intakeConversationState?.ctaResponse !== 'ready';\n    const normalized = message.trim();\n    const { affirmative, negative } = getChatPatterns('en'); // TODO: Pass actual language when available\n    const isAffirmative = affirmative.test(normalized);\n    const isNegative = negative.test(normalized);\n\n    if (canHandleCta && onIntakeCtaResponse) {\n      if (isAffirmative) {\n        (async () => {\n          if (onSubmitNow) {\n            try {\n              await onSubmitNow();\n            } catch (error) {\n              console.error('Failed to submit via chat shortcut', error);\n              onIntakeCtaResponse('ready');\n            }\n          } else {\n            onIntakeCtaResponse('ready');\n          }\n        })();\n        setInputValue('');\n        setReplyTarget(null);\n        if (textareaRef.current && isMobile) {\n          textareaRef.current.blur();\n        }\n        return;\n      }\n      if (isNegative) {\n        onIntakeCtaResponse('not_yet');\n        setInputValue('');\n        setReplyTarget(null);\n        if (textareaRef.current && isMobile) {\n          textareaRef.current.blur();\n        }\n        return;\n      }\n    }\n\n    // Send message to API\n    onSendMessage(message, attachments, replyToMessageId);\n\n    // Clear preview files after sending\n    clearPreviewFiles();\n\n    // Reset input\n    setInputValue('');\n    setReplyTarget(null);\n\n    // Only blur on mobile devices to collapse virtual keyboard\n    if (textareaRef.current && isMobile) {\n      textareaRef.current.blur();\n    }\n  };\n\n  const handleQuickReply = (text: string) => {\n    setInputValue(text);\n    if (textareaRef.current) {\n      textareaRef.current.focus();\n    }\n  };\n\n  const baseKeyHandler = createKeyPressHandler(handleSubmit);\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    // isComposing is not in TypeScript's KeyboardEvent but exists at runtime\n    if ((e as KeyboardEvent & { isComposing?: boolean }).isComposing || e.repeat) {\n      return;\n    }\n    if (isChatInputLocked) {\n      return;\n    }\n    baseKeyHandler(e);\n  };\n\n  const openPayment = (request: IntakePaymentRequest): boolean => {\n    const hasClientSecret = typeof request.clientSecret === 'string' &&\n      request.clientSecret.trim().length > 0;\n    if (!hasClientSecret &&\n      request.paymentLinkUrl &&\n      isValidStripePaymentLink(request.paymentLinkUrl) &&\n      typeof window !== 'undefined') {\n      window.open(request.paymentLinkUrl, '_blank', 'noopener');\n      return false;\n    }\n    setPaymentRequest(request);\n    setIsPaymentModalOpen(true);\n    return true;\n  };\n\n  const handleAuthPromptClose = () => {\n    setPendingPaymentRequest(null);\n    onAuthPromptClose?.();\n  };\n\n  const handleAuthSuccess = async () => {\n    let modalOpened = false;\n    if (pendingPaymentRequest) {\n      modalOpened = openPayment(pendingPaymentRequest);\n      setPendingPaymentRequest(null);\n    }\n    if (!modalOpened) {\n      onAuthPromptSuccess?.();\n    }\n  };\n\n  const handleOpenPayment = (request: IntakePaymentRequest) => {\n    if (isAnonymousUser) {\n      setPendingPaymentRequest(request);\n      onAuthPromptRequest?.();\n      return;\n    }\n    openPayment(request);\n  };\n\n  const handleClosePayment = () => {\n    setIsPaymentModalOpen(false);\n  };\n\n  const handlePaymentSuccess = async () => {\n    if (!paymentRequest) {\n      handleClosePayment();\n      return;\n    }\n\n    if (paymentRequest.intakeUuid && !isAnonymousUser) {\n      try {\n        await triggerIntakeInvitation(paymentRequest.intakeUuid);\n      } catch (error) {\n        console.error('[Chat] Failed to trigger intake invitation', error);\n      }\n    }\n\n    const isValidUuid = typeof paymentRequest.intakeUuid === 'string'\n      && (\n        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(paymentRequest.intakeUuid)\n        || /^[0-9A-HJKMNP-TV-Z]{26}$/i.test(paymentRequest.intakeUuid)\n      );\n\n    if (typeof window !== 'undefined' && isValidUuid && paymentRequest.intakeUuid) {\n      try {\n        const payload: Record<string, string> = {};\n        if (paymentRequest.practiceName) payload.practiceName = paymentRequest.practiceName;\n        if (paymentRequest.practiceId) payload.practiceId = paymentRequest.practiceId;\n        if (paymentRequest.conversationId) payload.conversationId = paymentRequest.conversationId;\n\n        window.sessionStorage.setItem(\n          `intakePaymentSuccess:${paymentRequest.intakeUuid}`,\n          JSON.stringify(payload)\n        );\n      } catch (error) {\n        console.warn('[Chat] Failed to persist payment success flag', error);\n      }\n    } else if (paymentRequest.intakeUuid) {\n      console.warn('[Chat] Skipped persisting invalid intakeUuid', paymentRequest.intakeUuid);\n    }\n    handleClosePayment();\n  };\n\n  const handleModeSelection = (mode: ConversationMode, source: 'intro_gate' | 'composer_footer') => {\n    if (!onSelectMode) return;\n    onSelectMode(mode, source);\n  };\n\n  const handleAskQuestion = () => {\n    handleModeSelection('ASK_QUESTION', 'intro_gate');\n  };\n\n  const handleRequestConsultation = () => {\n    handleModeSelection('REQUEST_CONSULTATION', 'intro_gate');\n  };\n\n  const resolvedLayoutMode: LayoutMode = layoutMode ?? (useFrame === false ? 'desktop' : 'embed');\n  const shouldFrame = resolvedLayoutMode !== 'desktop';\n  const containerClassName = `flex flex-col min-h-0 flex-1 ${heightClassName ?? 'h-full'} w-full m-0 p-0 relative overflow-hidden bg-transparent border-0 rounded-none shadow-none`;\n  const mainClassName = isPublicWorkspace && !shouldFrame\n    ? 'flex flex-col flex-1 min-h-0 w-full overflow-hidden relative'\n    : `flex flex-col flex-1 min-h-0 w-full overflow-hidden relative ${isPublicWorkspace ? 'items-center px-3 py-4' : 'bg-transparent'}`;\n  const frameClassName = !shouldFrame\n    ? 'flex flex-col flex-1 min-h-0 w-full'\n    : (isPublicWorkspace\n      ? 'flex flex-col flex-1 min-h-0 w-full max-w-[420px] mx-auto overflow-hidden bg-transparent border-0 rounded-none shadow-none'\n      : 'flex flex-col flex-1 min-h-0 w-full');\n\n  const handleReply = (target: ReplyTarget) => {\n    setReplyTarget(target);\n    textareaRef.current?.focus();\n  };\n\n  const handleCancelReply = () => {\n    setReplyTarget(null);\n  };\n\n  return (\n    <div\n      className={containerClassName}\n      data-testid=\"chat-container\"\n    >\n      <main className={mainClassName}>\n        {canChat ? (\n          <div className={frameClassName}>\n            {headerContent ? (\n              <div className=\"shrink-0\">\n                {headerContent}\n              </div>\n            ) : null}\n            <div className=\"flex flex-1 min-h-0 flex-col\">\n              {isPublicWorkspace && filteredMessages.length === 0 ? (\n                <div className={cn(\n                  'flex flex-col items-center justify-start px-6 text-center text-sm text-input-placeholder',\n                  shouldShowSlimForm ? 'pt-4 pb-2' : 'flex-1 pt-8'\n                )}>\n                  <p className=\"max-w-[300px]\">\n                    {typeof practiceConfig?.introMessage === 'string' && practiceConfig.introMessage.trim()\n                      ? practiceConfig.introMessage.trim()\n                      : t('chat.publicIntro')}\n                  </p>\n                </div>\n              ) : (\n                <>\n                  <VirtualMessageList\n                    messages={messagesReady ? filteredMessages : []}\n                    conversationTitle={conversationTitle}\n                    practiceConfig={practiceConfig}\n                    isPublicWorkspace={isPublicWorkspace}\n                    onOpenSidebar={onOpenSidebar}\n                    onOpenPayment={handleOpenPayment}\n                    practiceId={practiceId}\n                    onReply={handleReply}\n                    onToggleReaction={onToggleReaction}\n                    onRequestReactions={onRequestReactions}\n                    onAuthPromptRequest={onAuthPromptRequest}\n                    intakeStatus={intakeStatus}\n                    intakeConversationState={intakeConversationState}\n                    onQuickReply={handleQuickReply}\n                    onIntakeCtaResponse={onIntakeCtaResponse}\n                    onSubmitNow={onSubmitNow}\n                    onBuildBrief={onBuildBrief}\n                    modeSelectorActions={onSelectMode ? {\n                      onAskQuestion: handleAskQuestion,\n                      onRequestConsultation: handleRequestConsultation\n                    } : undefined}\n                    leadReviewActions={leadReviewActions}\n                    hasMoreMessages={hasMoreMessages}\n                    isLoadingMoreMessages={isLoadingMoreMessages}\n                    onLoadMoreMessages={onLoadMoreMessages}\n                    showSkeleton={!messagesReady}\n                    compactLayout={shouldShowSlimForm}\n                  />\n                </>\n              )}\n            </div>\n\n            <div className=\"sticky bottom-0 z-[1000] w-full\">\n              {shouldShowSlimForm && onSlimFormContinue ? (\n                <div className=\"pl-4 pr-4 pb-3 bg-transparent rounded-none border-0 h-auto flex flex-col w-full\">\n                  <ContactForm\n                    onSubmit={onSlimFormContinue}\n                    fields={['name', 'email', 'phone', 'city', 'state', 'opposingParty', 'description']}\n                    required={['name', 'email', 'phone', 'city', 'state']}\n                    initialValues={slimContactDraft ?? undefined}\n                    variant=\"plain\"\n                    showSubmitButton={true}\n                    submitFullWidth={true}\n                    submitLabel={t('chat.continue')}\n                  />\n                </div>\n              ) : (\n                <MessageComposer\n                  inputValue={inputValue}\n                  setInputValue={setInputValue}\n                  previewFiles={previewFiles}\n                  uploadingFiles={uploadingFiles}\n                  removePreviewFile={removePreviewFile}\n                  handleFileSelect={handleFileSelect}\n                  handleCameraCapture={handleCameraCapture}\n                  cancelUpload={cancelUpload}\n                  isRecording={isRecording}\n                  handleMediaCapture={handleMediaCapture}\n                  setIsRecording={setIsRecording}\n                  onSubmit={handleSubmit}\n                  onKeyDown={handleKeyDown}\n                  textareaRef={textareaRef}\n                  isReadyToUpload={isReadyToUpload}\n                  isSessionReady={isSessionReady}\n                  isSocketReady={isSocketReady}\n                  intakeStatus={intakeStatus}\n                  disabled={composerDisabled}\n                  showStatusMessage={!isPublicWorkspace}\n                  replyTo={replyTarget}\n                  onCancelReply={handleCancelReply}\n                  footerActions={(() => {\n                    if (!isPublicWorkspace) return null;\n                    if (!intakeConversationState) return null;\n                    if (intakeConversationState.ctaResponse === 'ready') return null;\n                    const MIN_NOT_YET_COUNT_FOR_CTA = 2;\n                    if ((intakeConversationState.notYetCount ?? 0) < MIN_NOT_YET_COUNT_FOR_CTA) return null;\n                    return (\n                      <div className=\"mt-2\">\n                        <Button\n                          variant=\"secondary\"\n                          size=\"sm\"\n                          className=\"w-full\"\n                          onClick={async () => {\n                            if (onSubmitNow) {\n                              try {\n                                await onSubmitNow();\n                              } catch (error) {\n                                console.error('Failed to submit via footer CTA', error);\n                                onIntakeCtaResponse?.('ready');\n                              }\n                              return;\n                            }\n                            onIntakeCtaResponse?.('ready');\n                          }}\n                        >\n                          {t('chat.submitRequest')}\n                        </Button>\n                      </div>\n                    );\n                  })()}\n                />\n              )}\n            </div>\n          </div>\n        ) : null}\n      </main>\n\n      <AuthPromptModal\n        isOpen={showAuthPrompt}\n        onClose={handleAuthPromptClose}\n        practiceName={practiceConfig?.name}\n        onSuccess={handleAuthSuccess}\n        title={authPromptTitle}\n        description={authPromptDescription}\n        callbackURL={authPromptCallbackUrl}\n      />\n\n      <IntakePaymentModal\n        isOpen={isPaymentModalOpen}\n        onClose={handleClosePayment}\n        paymentRequest={paymentRequest}\n        onSuccess={handlePaymentSuccess}\n      />\n    </div>\n  );\n};\n\nexport default ChatContainer; \n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/ChatMarkdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/ChatText.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/LinkMatterModal.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":77,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":77,"endColumn":23,"suggestions":[{"fix":{"range":[2684,2762],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport Modal from '@/shared/components/Modal';\nimport { Button } from '@/shared/ui/Button';\nimport { Combobox } from '@/shared/ui/input/Combobox';\nimport { FolderIcon } from '@heroicons/react/24/outline';\nimport { listMatters, getMatter } from '@/features/matters/services/mattersApi';\nimport { updateConversationMatter } from '@/shared/lib/apiClient';\nimport type { Conversation } from '@/shared/types/conversation';\n\ninterface WorkspaceMatterOption {\n  id: string;\n  title: string;\n  clientName?: string | null;\n  matterType?: string | null;\n  status?: string | null;\n}\n\ninterface LinkMatterModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  practiceId: string;\n  conversationId: string;\n  currentMatterId?: string | null;\n  onMatterUpdated?: (conversation: Conversation) => void;\n}\n\nexport const LinkMatterModal = ({\n  isOpen,\n  onClose,\n  practiceId,\n  conversationId,\n  currentMatterId = null,\n  onMatterUpdated\n}: LinkMatterModalProps) => {\n  const pageSize = 50;\n  const [matters, setMatters] = useState<WorkspaceMatterOption[]>([]);\n  const [selectedMatterId, setSelectedMatterId] = useState<string>(currentMatterId ?? '');\n  const [loadingState, setLoadingState] = useState<'idle' | 'loading' | 'loading-more'>('idle');\n  const [hasMore, setHasMore] = useState(false);\n  const [page, setPage] = useState(1);\n  const [saving, setSaving] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const controllerRef = useRef<AbortController | null>(null);\n\n  const [currentMatter, setCurrentMatter] = useState<WorkspaceMatterOption | null>(null);\n\n  useEffect(() => {\n    if (!isOpen) {\n      return;\n    }\n    const matterId = currentMatterId ?? '';\n    setSelectedMatterId(matterId);\n    setError(null);\n    setPage(1);\n    const controller = new AbortController();\n\n    // Fetch current matter specifically if we have an ID\n    if (matterId) {\n      setCurrentMatter(null);\n      const fetchCurrent = async () => {\n        try {\n          const m = await getMatter(practiceId, matterId, { signal: controller.signal });\n          if (m && !controller.signal.aborted) {\n            setCurrentMatter({\n              id: m.id,\n              title: m.title ?? 'Untitled Matter',\n              clientName: m.client_id ? `Client ${m.client_id.slice(0, 8)}` : null,\n              matterType: m.matter_type ?? null,\n              status: m.status ?? null\n            });\n          }\n        } catch (err) {\n          if ((err as DOMException).name === 'AbortError' || controller.signal.aborted) {\n            return;\n          }\n          setCurrentMatter(null);\n          console.warn('[LinkMatterModal] Failed to fetch current matter details', err);\n        }\n      };\n      void fetchCurrent();\n    } else {\n      setCurrentMatter(null);\n    }\n    return () => {\n      controller.abort();\n    };\n  }, [currentMatterId, isOpen, practiceId]);\n\n  const fetchMatters = useCallback(async (\n    pageToLoad: number,\n    { append }: { append: boolean }\n  ) => {\n    if (!practiceId) {\n      setMatters([]);\n      setHasMore(false);\n      return;\n    }\n\n    controllerRef.current?.abort();\n    const controller = new AbortController();\n    controllerRef.current = controller;\n    setLoadingState(append ? 'loading-more' : 'loading');\n    setError(null);\n    try {\n      const results = await listMatters(practiceId, {\n        page: pageToLoad,\n        limit: pageSize,\n        signal: controller.signal\n      });\n\n      const normalized = results.map((m) => ({\n        id: m.id,\n        title: m.title ?? 'Untitled Matter',\n        clientName: m.client_id ? `Client ${m.client_id.slice(0, 8)}` : null,\n        matterType: m.matter_type ?? null,\n        status: m.status ?? null\n      }));\n\n      // If we got fewer items than pageSize, we likely reached the end\n      const nextHasMore = results.length === pageSize;\n\n      setMatters((prev) => append ? [...prev, ...normalized] : normalized);\n      setHasMore(nextHasMore);\n      setPage(pageToLoad);\n    } catch (err) {\n      if ((err as DOMException).name !== 'AbortError') {\n        const message = err instanceof Error ? err.message : 'Failed to load matters';\n        setError(message);\n        if (!append) {\n          setMatters([]);\n        }\n      }\n    } finally {\n      // Only update state if this request wasn't superseded\n      if (controllerRef.current === controller) {\n        controllerRef.current = null;\n        setLoadingState('idle');\n      }\n    }\n\n  }, [practiceId, pageSize]);\n\n  useEffect(() => {\n    if (!isOpen) {\n      return;\n    }\n\n    void fetchMatters(1, { append: false });\n    return () => {\n      controllerRef.current?.abort();\n    };\n  }, [fetchMatters, isOpen, currentMatterId]);\n\n  const handleLoadMore = async () => {\n    if (loadingState !== 'idle' || !hasMore) return;\n    await fetchMatters(page + 1, { append: true });\n  };\n\n  const handleSave = async () => {\n    setSaving(true);\n    setError(null);\n    try {\n      const conversation = await updateConversationMatter(\n        conversationId,\n        selectedMatterId ? selectedMatterId : null\n      );\n      onMatterUpdated?.(conversation);\n      onClose();\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Failed to update matter link';\n      setError(message);\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  const handleUnlink = async () => {\n    setSaving(true);\n    setError(null);\n    try {\n      const conversation = await updateConversationMatter(conversationId, null);\n      onMatterUpdated?.(conversation);\n      onClose();\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Failed to unlink matter';\n      setError(message);\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  const isUnchanged = (currentMatterId ?? '') === selectedMatterId;\n\n  const matterOptions = useMemo(() => {\n    const list = matters.map((m) => ({\n      value: m.id,\n      label: m.title,\n      meta: m.clientName ?? undefined\n    }));\n\n    // Ensure current matter is always an option even if not in the first page of results\n    if (currentMatter && !matters.some((m) => m.id === currentMatter.id)) {\n      list.unshift({\n        value: currentMatter.id,\n        label: currentMatter.title,\n        meta: currentMatter.clientName ?? undefined\n      });\n    }\n\n    return list;\n  }, [matters, currentMatter]);\n\n  return (\n    <Modal\n      isOpen={isOpen}\n      onClose={onClose}\n      title=\"Link to matter\"\n      contentClassName=\"max-w-lg\"\n    >\n      <div className=\"space-y-4\">\n        <div className=\"text-sm text-gray-600 dark:text-gray-300\">\n          Choose a matter to associate with this conversation. Unlinking removes the association without deleting the\n          conversation.\n        </div>\n\n        <div className=\"space-y-4\">\n          <Combobox\n            label=\"Matter\"\n            placeholder={loadingState === 'loading' ? 'Loading matters...' : 'Select matter'}\n            value={selectedMatterId}\n            options={matterOptions}\n            onChange={setSelectedMatterId}\n            disabled={saving || loadingState === 'loading'}\n            leading={() => <FolderIcon className=\"h-4 w-4 text-input-placeholder\" />}\n            optionLeading={() => <FolderIcon className=\"h-4 w-4 text-input-placeholder\" />}\n          />\n          {loadingState === 'loading' && (\n            <div className=\"text-xs text-gray-500 dark:text-gray-400\">Loading matters</div>\n          )}\n          {loadingState !== 'loading' && hasMore && (\n            <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n              Showing {matters.length} results. Load more to see additional matters.\n            </div>\n          )}\n        </div>\n\n        {error && (\n          <div className=\"text-sm text-red-600 dark:text-red-400\">{error}</div>\n        )}\n\n        <div className=\"flex flex-wrap items-center gap-2\">\n          <Button\n            variant=\"primary\"\n            size=\"sm\"\n            onClick={handleSave}\n            disabled={saving || loadingState !== 'idle' || isUnchanged}\n          >\n            {saving ? 'Saving' : 'Save'}\n          </Button>\n          {currentMatterId && (\n            <Button\n              variant=\"danger\"\n              size=\"sm\"\n              onClick={handleUnlink}\n              disabled={loadingState !== 'idle' || saving}\n            >\n              Unlink\n            </Button>\n          )}\n          <Button\n            variant=\"secondary\"\n            size=\"sm\"\n            onClick={onClose}\n            disabled={saving}\n          >\n            Cancel\n          </Button>\n        </div>\n\n        {hasMore && (\n          <div>\n            <Button\n              variant=\"secondary\"\n              size=\"sm\"\n              onClick={handleLoadMore}\n              disabled={loadingState !== 'idle' || saving}\n            >\n              {loadingState === 'loading-more' ? 'Loading' : 'Load more'}\n            </Button>\n          </div>\n        )}\n      </div>\n    </Modal>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/Message.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/MessageActions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/MessageAttachments.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/MessageAvatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/MessageBubble.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/MessageComposer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/MessageContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/PracticeConversationHeaderMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/VirtualMessageList.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":99,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":99,"endColumn":25,"suggestions":[{"fix":{"range":[3511,3583],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":175,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":175,"endColumn":21,"suggestions":[{"fix":{"range":[6314,6629],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":293,"column":21,"nodeType":"MemberExpression","messageId":"unexpected","endLine":293,"endColumn":34,"suggestions":[{"fix":{"range":[11581,11657],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":356,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":356,"endColumn":25,"suggestions":[{"fix":{"range":[14127,14585],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":371,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":371,"endColumn":29,"suggestions":[{"fix":{"range":[14853,15053],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":397,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":397,"endColumn":29,"suggestions":[{"fix":{"range":[15827,15914],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":414,"column":21,"nodeType":"MemberExpression","messageId":"unexpected","endLine":414,"endColumn":34,"suggestions":[{"fix":{"range":[16699,16773],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":420,"column":25,"nodeType":"MemberExpression","messageId":"unexpected","endLine":420,"endColumn":37,"suggestions":[{"fix":{"range":[17028,17101],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":424,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":424,"endColumn":25,"suggestions":[{"fix":{"range":[17255,17616],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'showError'. Either include it or remove the dependency array.","line":431,"column":8,"nodeType":"ArrayExpression","endLine":436,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [startIndex, hasMoreMessages, isLoadingMoreMessages, onLoadMoreMessages, showError]","fix":{"range":[17634,17744],"text":"[startIndex, hasMoreMessages, isLoadingMoreMessages, onLoadMoreMessages, showError]"}}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":582,"column":21,"nodeType":"MemberExpression","messageId":"unexpected","endLine":582,"endColumn":33,"suggestions":[{"fix":{"range":[24021,24126],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport { useRef, useEffect, useState, useCallback, useLayoutEffect, useMemo } from 'preact/hooks';\nimport Message from './Message';\nimport { memo } from 'preact/compat';\nimport { debounce } from '@/shared/utils/debounce';\nimport { ErrorBoundary } from '@/app/ErrorBoundary';\nimport { ChatMessageUI } from '../../../../worker/types';\nimport type { IntakePaymentRequest } from '@/shared/utils/intakePayments';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { postSystemMessage } from '@/shared/lib/conversationApi';\nimport type { MatterTransitionResult } from '@/shared/hooks/usePracticeManagement';\nimport type { ReplyTarget } from '@/features/chat/types';\nimport type { IntakeConversationState } from '@/shared/types/intake';\n\ninterface VirtualMessageListProps {\n    messages: ChatMessageUI[];\n    conversationTitle?: string | null;\n    practiceConfig?: {\n        name: string;\n        profileImage: string | null;\n        practiceId: string;\n        description?: string | null;\n        slug?: string | null;\n    };\n    isPublicWorkspace?: boolean;\n    onOpenSidebar?: () => void;\n    onOpenPayment?: (request: IntakePaymentRequest) => void;\n    practiceId?: string;\n    onReply?: (target: ReplyTarget) => void;\n    onToggleReaction?: (messageId: string, emoji: string) => void;\n    onRequestReactions?: (messageId: string) => Promise<void> | void;\n    onAuthPromptRequest?: () => void;\n    intakeStatus?: {\n        step: string;\n        decision?: string;\n        intakeUuid?: string | null;\n        paymentRequired?: boolean;\n        paymentReceived?: boolean;\n    };\n    intakeConversationState?: IntakeConversationState | null;\n    onIntakeCtaResponse?: (response: 'ready' | 'not_yet') => void;\n    onSubmitNow?: () => void | Promise<void>;\n    onBuildBrief?: () => void;\n    onQuickReply?: (text: string) => void;\n    modeSelectorActions?: {\n        onAskQuestion: () => void;\n        onRequestConsultation: () => void;\n    };\n    leadReviewActions?: {\n        practiceId: string;\n        practiceName: string;\n        conversationId: string;\n        canReviewLeads: boolean;\n        acceptMatter: (practiceId: string, matterId: string) => Promise<MatterTransitionResult>;\n        rejectMatter: (practiceId: string, matterId: string) => Promise<MatterTransitionResult>;\n        onLeadStatusChange?: () => void;\n    };\n    hasMoreMessages?: boolean;\n    isLoadingMoreMessages?: boolean;\n    onLoadMoreMessages?: () => void | Promise<void>;\n    showSkeleton?: boolean;\n    compactLayout?: boolean;\n}\n\nconst BATCH_SIZE = 20;\nconst SCROLL_THRESHOLD = 100;\nconst DEBOUNCE_DELAY = 50;\nconst DEBUG_PAGINATION = typeof process !== 'undefined' && process.env.NODE_ENV === 'development';\n\nconst VirtualMessageList: FunctionComponent<VirtualMessageListProps> = ({\n    messages,\n    conversationTitle,\n    practiceConfig,\n    isPublicWorkspace = false,\n    onOpenSidebar,\n    onOpenPayment,\n    practiceId,\n    onReply,\n    onToggleReaction,\n    onRequestReactions,\n    onAuthPromptRequest,\n    intakeStatus: _intakeStatus,\n    intakeConversationState,\n    onIntakeCtaResponse,\n    onSubmitNow,\n    onBuildBrief,\n    onQuickReply,\n    modeSelectorActions,\n    leadReviewActions,\n    hasMoreMessages,\n    isLoadingMoreMessages,\n    onLoadMoreMessages,\n    showSkeleton = false,\n    compactLayout = false\n}) => {\n    useEffect(() => {\n        if (DEBUG_PAGINATION) {\n            console.info('[VirtualMessageList][pagination] instrumentation active');\n        }\n    }, []);\n\n    const { session, activeMemberRole } = useSessionContext();\n    const { showError, showSuccess } = useToastContext();\n    const dedupedMessages = useMemo(() => {\n        const seenPaymentConfirm = new Set<string>();\n        return messages.filter((message) => {\n            const intakePaymentUuid = typeof message.metadata?.intakePaymentUuid === 'string'\n                ? message.metadata.intakePaymentUuid\n                : null;\n            if (!intakePaymentUuid) {\n                return true;\n            }\n            const key = `${intakePaymentUuid}:${message.role}`;\n            if (seenPaymentConfirm.has(key)) {\n                return false;\n            }\n            seenPaymentConfirm.add(key);\n            return true;\n        });\n    }, [messages]);\n    const listRef = useRef<HTMLDivElement>(null);\n    const submittingRef = useRef<Record<string, boolean>>({});\n    const [startIndex, setStartIndex] = useState(Math.max(0, dedupedMessages.length - BATCH_SIZE));\n    const [endIndex, setEndIndex] = useState(dedupedMessages.length);\n    const isScrolledToBottomRef = useRef(true);\n    const isUserScrollingRef = useRef(false);\n    const isLoadingRef = useRef(false);\n    const loggedNoServerPaginationRef = useRef(false);\n    const prevHasMoreRef = useRef<boolean | undefined>(hasMoreMessages);\n    const currentUserName = session?.user?.name || session?.user?.email || 'You';\n    const currentUserAvatar = session?.user?.image || null;\n    const currentUserProfile = {\n        src: currentUserAvatar,\n        name: currentUserName\n    };\n\n    const practiceProfile = practiceConfig ? {\n        src: practiceConfig.profileImage,\n        name: practiceConfig.name\n    } : {\n        src: null,\n        name: 'Practice'\n    };\n    const clientProfile = {\n        src: null,\n        name: conversationTitle?.trim() || 'Client'\n    };\n    const blawbyProfile = {\n        src: '/blawby-favicon-iframe.png',\n        name: 'Blawby'\n    };\n    const isPracticeViewer = Boolean(activeMemberRole && activeMemberRole !== 'client');\n    const [leadActionState, setLeadActionState] = useState<Record<string, 'accept' | 'reject'>>({});\n    const isMountedRef = useRef(true);\n\n    useEffect(() => {\n        return () => {\n            isMountedRef.current = false;\n        };\n    }, []);\n\n    useEffect(() => {\n        if (!DEBUG_PAGINATION) return;\n        if (startIndex !== 0) {\n            loggedNoServerPaginationRef.current = false;\n            return;\n        }\n        if (hasMoreMessages) {\n            loggedNoServerPaginationRef.current = false;\n            return;\n        }\n        if (loggedNoServerPaginationRef.current) return;\n        loggedNoServerPaginationRef.current = true;\n        console.info('[VirtualMessageList][pagination] server pagination disabled for current state', {\n            startIndex,\n            hasMoreMessages: Boolean(hasMoreMessages),\n            isLoadingMoreMessages: Boolean(isLoadingMoreMessages),\n            hasOnLoadMoreHandler: Boolean(onLoadMoreMessages)\n        });\n    }, [startIndex, hasMoreMessages, isLoadingMoreMessages, onLoadMoreMessages]);\n\n    const resolveAvatar = (message: ChatMessageUI) => {\n        const mockAvatar = message.metadata?.avatar as { src?: string | null; name: string } | undefined;\n        const isSystemMessage = message.role === 'system';\n        const isAssistantMessage = message.role === 'assistant';\n        const isBotNotification = isSystemMessage\n            && typeof message.metadata?.notificationType === 'string';\n        const isBotMessage = isSystemMessage || isAssistantMessage || isBotNotification;\n\n        if (mockAvatar) {\n            return mockAvatar;\n        }\n        if (isBotMessage) {\n            return practiceProfile.src || practiceProfile.name !== 'Practice'\n                ? practiceProfile\n                : blawbyProfile;\n        }\n        if (message.isUser) {\n            return currentUserProfile;\n        }\n        return isPracticeViewer ? clientProfile : practiceProfile;\n    };\n\n    const resolveModeSelector = (message: ChatMessageUI) => {\n        if (!modeSelectorActions) {\n            return undefined;\n        }\n        const meta = message.metadata?.modeSelector;\n        if (!meta) {\n            return undefined;\n        }\n        if (meta === true) {\n            return {\n                onAskQuestion: modeSelectorActions.onAskQuestion,\n                onRequestConsultation: modeSelectorActions.onRequestConsultation\n            };\n        }\n        if (typeof meta === 'object') {\n            const metaConfig = meta as { showAskQuestion?: boolean; showRequestConsultation?: boolean };\n            return {\n                onAskQuestion: modeSelectorActions.onAskQuestion,\n                onRequestConsultation: modeSelectorActions.onRequestConsultation,\n                showAskQuestion: metaConfig.showAskQuestion,\n                showRequestConsultation: metaConfig.showRequestConsultation\n            };\n        }\n        return undefined;\n    };\n\n    const resolveLeadReview = (message: ChatMessageUI) => {\n        if (!leadReviewActions || !isPracticeViewer) {\n            return undefined;\n        }\n        const metadata = message.metadata;\n        if (!metadata || typeof metadata !== 'object') {\n            return undefined;\n        }\n        const systemKey = (metadata as Record<string, unknown>).systemMessageKey;\n        if (systemKey !== 'intake_summary') {\n            return undefined;\n        }\n        const leadId = typeof (metadata as Record<string, unknown>).leadId === 'string'\n            ? (metadata as Record<string, unknown>).leadId as string\n            : (typeof (metadata as Record<string, unknown>).matterId === 'string'\n                ? (metadata as Record<string, unknown>).matterId as string\n                : null);\n        if (!leadId || !leadReviewActions.practiceId || !leadReviewActions.conversationId) {\n            return undefined;\n        }\n\n        const isSubmittingState = Boolean(leadActionState[leadId]);\n\n        const runLeadAction = async (action: 'accept' | 'reject') => {\n            const isSubmittingNow = Boolean(leadActionState[leadId]);\n            if (!leadReviewActions.canReviewLeads || isSubmittingNow || submittingRef.current[leadId]) {\n                return;\n            }\n            submittingRef.current[leadId] = true;\n            setLeadActionState((prev) => ({ ...prev, [leadId]: action }));\n            try {\n                let result: MatterTransitionResult;\n                if (action === 'accept') {\n                    result = await leadReviewActions.acceptMatter(leadReviewActions.practiceId, leadId);\n                } else {\n                    result = await leadReviewActions.rejectMatter(leadReviewActions.practiceId, leadId);\n                }\n\n                if (result.error || result.success !== true) {\n                    throw new Error(result.error || 'The action could not be completed at this time.');\n                }\n\n                const practiceName = leadReviewActions.practiceName || 'The practice';\n                const content = action === 'accept'\n                    ? `${practiceName} has joined the conversation.`\n                    : `${practiceName} was unable to take your request at this time.`;\n\n                let systemMessageFailed = false;\n                try {\n                    await postSystemMessage(\n                        leadReviewActions.conversationId,\n                        leadReviewActions.practiceId,\n                        {\n                            clientId: action === 'accept' ? 'system-lead-accepted' : 'system-lead-declined',\n                            content,\n                            metadata: {\n                                systemMessageKey: action === 'accept' ? 'lead_accepted' : 'lead_declined',\n                                leadId\n                            }\n                        }\n                    );\n                } catch (msgErr) {\n                    console.error('[VirtualMessageList] Failed to post system message', msgErr);\n                    systemMessageFailed = true;\n                }\n\n                const notificationText = systemMessageFailed\n                    ? 'Attempted to notify client; notification failed.'\n                    : (action === 'accept' ? 'The client has been notified.' : 'The client has been notified of the decline.');\n\n                showSuccess(\n                    action === 'accept' ? 'Lead accepted' : 'Lead declined',\n                    notificationText\n                );\n                leadReviewActions.onLeadStatusChange?.();\n            } catch (err) {\n                const message = err instanceof Error ? err.message : 'Failed to update lead';\n                showError('Action failed', message);\n            } finally {\n                if (isMountedRef.current) {\n                    setLeadActionState((prev) => {\n                        const next = { ...prev };\n                        delete next[leadId];\n                        return next;\n                    });\n                    delete submittingRef.current[leadId];\n                }\n            }\n        };\n\n        return {\n            canReview: leadReviewActions.canReviewLeads,\n            isSubmitting: isSubmittingState,\n            onAccept: () => void runLeadAction('accept'),\n            onReject: () => void runLeadAction('reject')\n        };\n    };\n\n    const resolveAuthCta = useCallback((message: ChatMessageUI) => {\n        const metadata = message.metadata;\n        if (!metadata || typeof metadata !== 'object') {\n            return undefined;\n        }\n        const authCta = (metadata as Record<string, unknown>).authCta;\n        if (!authCta || typeof authCta !== 'object' || Array.isArray(authCta)) {\n            return undefined;\n        }\n        const label = typeof (authCta as Record<string, unknown>).label === 'string'\n            ? String((authCta as Record<string, unknown>).label)\n            : '';\n        const trimmedLabel = label.trim();\n        if (!trimmedLabel) return undefined;\n        return { label: trimmedLabel };\n    }, []);\n\n    const checkIfScrolledToBottom = useCallback((element: HTMLElement) => {\n        const { scrollTop, scrollHeight, clientHeight } = element;\n        return Math.abs(scrollHeight - scrollTop - clientHeight) < 10;\n    }, []);\n\n    const handleScrollLoadMore = useCallback(() => {\n        if (!listRef.current) return;\n\n        const element = listRef.current;\n        if (DEBUG_PAGINATION) {\n            console.info('[VirtualMessageList][pagination] scroll check', {\n                scrollTop: element.scrollTop,\n                threshold: SCROLL_THRESHOLD,\n                startIndex,\n                hasMoreMessages: Boolean(hasMoreMessages),\n                isLoadingMoreMessages: Boolean(isLoadingMoreMessages),\n                internalLoading: Boolean(isLoadingRef.current),\n                hasOnLoadMoreHandler: Boolean(onLoadMoreMessages)\n            });\n        }\n\n        // Load more messages when scrolling up (client-side)\n        if (element.scrollTop < SCROLL_THRESHOLD && startIndex > 0) {\n            const newStartIndex = Math.max(0, startIndex - BATCH_SIZE);\n            if (DEBUG_PAGINATION) {\n                console.info('[VirtualMessageList][pagination] revealing buffered messages', {\n                    previousStartIndex: startIndex,\n                    nextStartIndex: newStartIndex\n                });\n            }\n            setStartIndex(newStartIndex);\n\n            // Maintain scroll position when loading more messages\n            requestAnimationFrame(() => {\n                if (listRef.current) {\n                    const newScrollTop = listRef.current.scrollHeight - element.scrollHeight;\n                    if (newScrollTop > 0) {\n                        listRef.current.scrollTop = newScrollTop;\n                    }\n                }\n            });\n        }\n        if (\n            element.scrollTop < SCROLL_THRESHOLD &&\n            startIndex === 0 &&\n            hasMoreMessages &&\n            !isLoadingMoreMessages &&\n            !isLoadingRef.current &&\n            onLoadMoreMessages\n        ) {\n            if (DEBUG_PAGINATION) {\n                console.info('[VirtualMessageList][pagination] requesting older messages from server');\n            }\n            isLoadingRef.current = true;\n            const previousScrollHeight = element.scrollHeight;\n            const previousScrollTop = element.scrollTop;\n            void Promise.resolve(onLoadMoreMessages())\n                .then(() => {\n                    requestAnimationFrame(() => {\n                        if (!listRef.current) return;\n                        const newScrollHeight = listRef.current.scrollHeight;\n                        const heightDiff = newScrollHeight - previousScrollHeight;\n                        if (heightDiff > 0) {\n                            listRef.current.scrollTop = previousScrollTop + heightDiff;\n                        }\n                    });\n                })\n                .catch((error) => {\n                    console.error('[VirtualMessageList] Failed to load more messages', error);\n                    showError('Failed to load more messages', 'Please try again.');\n                })\n                .finally(() => {\n                    isLoadingRef.current = false;\n                    if (DEBUG_PAGINATION) {\n                        console.info('[VirtualMessageList][pagination] server request finished');\n                    }\n                });\n        } else if (DEBUG_PAGINATION && element.scrollTop < SCROLL_THRESHOLD && startIndex === 0) {\n            console.info('[VirtualMessageList][pagination] at top but not loading from server', {\n                hasMoreMessages: Boolean(hasMoreMessages),\n                isLoadingMoreMessages: Boolean(isLoadingMoreMessages),\n                internalLoading: Boolean(isLoadingRef.current),\n                hasOnLoadMoreHandler: Boolean(onLoadMoreMessages)\n            });\n        }\n    }, [\n        startIndex,\n        hasMoreMessages,\n        isLoadingMoreMessages,\n        onLoadMoreMessages\n    ]);\n\n    const debouncedHandleScroll = useMemo(() => {\n        return debounce(handleScrollLoadMore, DEBOUNCE_DELAY);\n    }, [handleScrollLoadMore]);\n\n    const handleScrollImmediate = useCallback(() => {\n        if (!listRef.current) return;\n\n        const element = listRef.current;\n        const isBottom = checkIfScrolledToBottom(element);\n        isScrolledToBottomRef.current = isBottom;\n        isUserScrollingRef.current = !isBottom;\n\n        // Dispatch scroll event for navbar visibility\n        const currentScrollTop = element.scrollTop;\n        const lastScrollTop = (element as HTMLElement & { lastScrollTop?: number }).lastScrollTop || 0;\n        const scrollDelta = Math.abs(currentScrollTop - lastScrollTop);\n        \n        if (scrollDelta > 0) {\n            window.dispatchEvent(new CustomEvent('chat-scroll', {\n                detail: { scrollTop: currentScrollTop, scrollDelta }\n            }));\n        }\n        \n        (element as HTMLElement & { lastScrollTop?: number }).lastScrollTop = currentScrollTop;\n\n        debouncedHandleScroll();\n    }, [checkIfScrolledToBottom, debouncedHandleScroll]);\n\n    useEffect(() => {\n        const list = listRef.current;\n        if (list) {\n            list.addEventListener('scroll', handleScrollImmediate, { passive: true });\n        }\n        return () => {\n            if (list) {\n                list.removeEventListener('scroll', handleScrollImmediate);\n            }\n            // Cancel any pending debounced calls to prevent delayed state updates after unmount\n            debouncedHandleScroll.cancel();\n        };\n    }, [debouncedHandleScroll, handleScrollImmediate]);\n\n    useEffect(() => {\n        // Update indices when new messages are added\n        if (isScrolledToBottomRef.current) {\n            setEndIndex(dedupedMessages.length);\n            setStartIndex(Math.max(0, dedupedMessages.length - BATCH_SIZE));\n        }\n    }, [dedupedMessages.length]);\n\n    useEffect(() => {\n        // If server pagination is exhausted, show full local history instead of\n        // keeping a virtualized window that implies more content is loading.\n        // Only fire when hasMoreMessages transitions from true to false.\n        if (prevHasMoreRef.current === true && hasMoreMessages === false) {\n            setStartIndex(0);\n            setEndIndex(dedupedMessages.length);\n        }\n        prevHasMoreRef.current = hasMoreMessages;\n    }, [hasMoreMessages, dedupedMessages.length]);\n\n    useEffect(() => {\n        const lastMessage = dedupedMessages[dedupedMessages.length - 1];\n        if (!lastMessage?.paymentRequest) return;\n        setEndIndex(dedupedMessages.length);\n        setStartIndex(Math.max(0, dedupedMessages.length - BATCH_SIZE));\n        if (listRef.current) {\n            listRef.current.scrollTo({ top: listRef.current.scrollHeight, behavior: 'auto' });\n        }\n    }, [dedupedMessages]);\n\n    useLayoutEffect(() => {\n        // Scroll to bottom when new messages are added and we're at the bottom\n        if (listRef.current && isScrolledToBottomRef.current && !isUserScrollingRef.current) {\n            listRef.current.scrollTo({ top: listRef.current.scrollHeight, behavior: 'auto' });\n        }\n    }, [dedupedMessages, endIndex]);\n\n\n    const visibleMessages = useMemo(\n        () => dedupedMessages.slice(startIndex, endIndex),\n        [dedupedMessages, startIndex, endIndex]\n    );\n    const messageMap = useMemo(() => {\n        return new Map(dedupedMessages.map((message) => [message.id, message]));\n    }, [dedupedMessages]);\n\n    const scrollToMessage = useCallback((messageId: string) => {\n        if (!messageId) {\n            return;\n        }\n        const targetIndex = dedupedMessages.findIndex((message) => message.id === messageId);\n        if (targetIndex === -1) {\n            return;\n        }\n\n        const nextStart = Math.max(0, targetIndex - Math.floor(BATCH_SIZE / 2));\n        const nextEnd = Math.min(dedupedMessages.length, nextStart + BATCH_SIZE);\n        setStartIndex(nextStart);\n        setEndIndex(nextEnd);\n        isScrolledToBottomRef.current = false;\n        isUserScrollingRef.current = true;\n\n        requestAnimationFrame(() => {\n            requestAnimationFrame(() => {\n                const element = document.getElementById(`message-${messageId}`);\n                if (element) {\n                    element.scrollIntoView({ block: 'center', behavior: 'smooth' });\n                }\n            });\n        });\n    }, [dedupedMessages]);\n\n    // Track which message IDs we've already dispatched a reactions request for.\n    // This is separate from the reactionLoadedRef in useMessageHandling  it prevents\n    // the effect below from firing duplicate requests during the window between calling\n    // onRequestReactions and the reactions state update propagating back to this component.\n    const reactionRequestedRef = useRef(new Set<string>());\n\n    useEffect(() => {\n        if (!onRequestReactions || visibleMessages.length === 0) {\n            return;\n        }\n        \n        const requestVisibleReactions = () => {\n            const messagesToRequest = visibleMessages.filter(message => {\n                if (!message.id) return false;\n                // Skip if reactions are already loaded on the message object.\n                if (message.reactions !== undefined) return false;\n                // Skip if we've already dispatched a request for this message ID.\n                if (reactionRequestedRef.current.has(message.id)) return false;\n                return true;\n            });\n            \n            if (messagesToRequest.length === 0) return;\n            \n            messagesToRequest.forEach((message) => {\n                if (!message.id) return;\n                reactionRequestedRef.current.add(message.id);\n                // Fire and forget with error handling cleanup\n                // Wrap in Promise.resolve to handle both async and sync returns, though void returns won't trigger catch\n                Promise.resolve(onRequestReactions(message.id)).catch((error) => {\n                    // Only log if really needed, to avoid noise. The user asked to remove message.id on failure.\n                    // We'll log a warning to be helpful for debugging but keep it minimal.\n                    console.warn('[VirtualMessageList] Failed to load reactions, allowing retry', { id: message.id, error });\n                    reactionRequestedRef.current.delete(message.id);\n                });\n            });\n        };\n        \n        requestVisibleReactions();\n    }, [onRequestReactions, visibleMessages]);\n\n    return (\n        <div\n            className={`message-list ${compactLayout ? 'flex-none' : 'flex-1'} overflow-y-auto p-4 ${isPublicWorkspace ? 'pt-0' : 'pt-2'} lg:pt-4 ${compactLayout ? 'pb-4' : 'pb-20'} scroll-smooth w-full scrollbar-thin scrollbar-track-transparent scrollbar-thumb-gray-300 dark:scrollbar-thumb-gray-600`}\n            ref={listRef}\n        >\n            {startIndex > 0 && (\n                <div className=\"flex justify-center items-center py-4\">\n                    <div className=\"text-gray-500 dark:text-gray-400 text-xs sm:text-sm lg:text-base\">Loading more messages...</div>\n                </div>\n            )}\n            {startIndex === 0 && hasMoreMessages && (\n                <div className=\"flex justify-center items-center py-4\">\n                    <button\n                        type=\"button\"\n                        className=\"text-xs sm:text-sm lg:text-base text-brand-purple hover:text-brand-purple-dark disabled:opacity-60\"\n                        onClick={() => onLoadMoreMessages?.()}\n                        disabled={isLoadingMoreMessages}\n                    >\n                        {isLoadingMoreMessages ? 'Loading older messages...' : 'Load older messages'}\n                    </button>\n                </div>\n            )}\n            {showSkeleton && (\n                <div className=\"mt-4 space-y-5\">\n                    <div className=\"flex items-start gap-3\">\n                        <div className=\"h-9 w-9 rounded-full bg-gray-200 dark:bg-white/10\" />\n                        <div className=\"space-y-2\">\n                            <div className=\"h-3 w-36 rounded bg-gray-200 dark:bg-white/10\" />\n                            <div className=\"h-3 w-60 rounded bg-gray-200 dark:bg-white/10\" />\n                        </div>\n                    </div>\n                    <div className=\"flex items-start gap-3\">\n                        <div className=\"h-9 w-9 rounded-full bg-gray-200 dark:bg-white/10\" />\n                        <div className=\"space-y-2\">\n                            <div className=\"h-3 w-44 rounded bg-gray-200 dark:bg-white/10\" />\n                            <div className=\"h-3 w-72 rounded bg-gray-200 dark:bg-white/10\" />\n                        </div>\n                    </div>\n                    <div className=\"flex items-start gap-3\">\n                        <div className=\"h-9 w-9 rounded-full bg-gray-200 dark:bg-white/10\" />\n                        <div className=\"space-y-2\">\n                            <div className=\"h-3 w-32 rounded bg-gray-200 dark:bg-white/10\" />\n                            <div className=\"h-3 w-56 rounded bg-gray-200 dark:bg-white/10\" />\n                        </div>\n                    </div>\n                </div>\n            )}\n            <ErrorBoundary>\n                {visibleMessages.map((message, _index) => {\n                    const avatar = resolveAvatar(message);\n                    const replyId = typeof message.reply_to_message_id === 'string'\n                        ? message.reply_to_message_id\n                        : null;\n                    const replySource = replyId ? messageMap.get(replyId) : null;\n                    const replyAvatar = replySource ? resolveAvatar(replySource) : undefined;\n                    const replyPreview: ReplyTarget | null = replyId ? {\n                        messageId: replyId,\n                        authorName: replyAvatar?.name ?? 'Original message',\n                        content: replySource?.content ?? '',\n                        avatar: replyAvatar,\n                        isMissing: !replySource\n                    } : null;\n                    const canReply = Boolean(onReply && message.id);\n\n                    const modeSelector = resolveModeSelector(message);\n                    const leadReview = resolveLeadReview(message);\n                    const authCta = resolveAuthCta(message);\n\n                    const quickReplies = Array.isArray(message.metadata?.quickReplies)\n                        ? message.metadata.quickReplies.filter((value: unknown): value is string => typeof value === 'string')\n                        : undefined;\n                    const stableClientId = typeof message.metadata?.__client_id === 'string'\n                        ? message.metadata.__client_id\n                        : null;\n                    // Provide a guaranteed fallback key when both stableClientId and message.id are missing.\n                    // Use the visible list index + startIndex so the fallback is stable across re-renders\n                    // as long as the slice window doesn't change. This avoids undefined/null keys.\n                    const fallbackIndexKey = `idx-${startIndex + _index}`;\n                    const renderKey = stableClientId\n                        ? `client-${stableClientId}`\n                        : (message.id ? `message-${message.id}` : fallbackIndexKey);\n\n                    return (\n                            <Message\n                                key={renderKey}\n                                content={message.content}\n                                isUser={message.isUser}\n                                files={message.files}\n                                avatar={avatar}\n                                authorName={avatar?.name}\n                                timestamp={message.timestamp}\n                            replyPreview={replyPreview ?? undefined}\n                            onReplyPreviewClick={replyPreview ? () => scrollToMessage(replyPreview.messageId) : undefined}\n                            reactions={message.reactions}\n                            onReply={canReply ? () => {\n                                if (!onReply) return;\n                                onReply({\n                                    messageId: message.id,\n                                    authorName: avatar?.name || 'Unknown',\n                                    content: message.content,\n                                    avatar\n                                });\n                            } : undefined}\n                            onToggleReaction={onToggleReaction ? (emoji: string) => {\n                                if (!message.id) return;\n                                onToggleReaction(message.id, emoji);\n                            } : undefined}\n                            matterCanvas={message.matterCanvas}\n                            generatedPDF={message.generatedPDF}\n                            paymentRequest={message.paymentRequest}\n                            practiceConfig={practiceConfig}\n                            onOpenSidebar={onOpenSidebar}\n                            onOpenPayment={onOpenPayment}\n                            isLoading={message.isLoading}\n                            // REMOVED: aiState - AI functionality removed\n                            toolMessage={message.toolMessage}\n                            id={message.id}\n                            practiceId={practiceId}\n                            assistantRetry={message.assistantRetry}\n                            modeSelector={modeSelector}\n                            leadReview={leadReview}\n                            authCta={authCta}\n                                onAuthPromptRequest={onAuthPromptRequest}\n                                intakeStatus={_intakeStatus}\n                                intakeConversationState={intakeConversationState}\n                                quickReplies={quickReplies}\n                                onQuickReply={onQuickReply}\n                                showIntakeCta={Boolean(message.metadata?.intakeReadyCta)}\n                                showIntakeDecisionPrompt={message.metadata?.intakeDecisionPrompt === true}\n                                onIntakeCtaResponse={onIntakeCtaResponse}\n                                onSubmitNow={onSubmitNow}\n                                onBuildBrief={onBuildBrief}\n                            />\n                        );\n                    })}\n            </ErrorBoundary>\n        </div>\n    );\n};\n\nexport default memo(VirtualMessageList); \n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/components/WorkspaceConversationHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/config/chatPatterns.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/hooks/useConversationSystemMessages.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":82,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":82,"endColumn":21,"suggestions":[{"fix":{"range":[2663,2751],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useRef } from 'preact/hooks';\nimport type { ChatMessageUI } from '../../../../worker/types';\nimport type { UIPracticeConfig } from '@/shared/hooks/usePracticeConfig';\nimport type { ConversationMessage, ConversationMode } from '@/shared/types/conversation';\nimport { postSystemMessage } from '@/shared/lib/conversationApi';\n\nconst buildIntroMessage = (\n  introMessage: string | null | undefined,\n  practiceName: string | null | undefined\n): string => {\n  const trimmedIntro = typeof introMessage === 'string' ? introMessage.trim() : '';\n  if (trimmedIntro) {\n    return trimmedIntro;\n  }\n  const trimmedName = typeof practiceName === 'string' ? practiceName.trim() : '';\n  if (trimmedName) {\n    return `Hi! Welcome to ${trimmedName}. How can we help?`;\n  }\n  return 'Hi! How can we help?';\n};\n\nconst hasSystemMessage = (messages: ChatMessageUI[], key: string): boolean => (\n  messages.some((message) => message.metadata?.systemMessageKey === key)\n);\n\ninterface ConversationSystemMessagesOptions {\n  conversationId?: string | null;\n  practiceId?: string;\n  practiceConfig: UIPracticeConfig;\n  messagesReady: boolean;\n  messages: ChatMessageUI[];\n  conversationMode?: ConversationMode | null;\n  isConsultFlowActive: boolean;\n  shouldRequireModeSelection: boolean;\n  ingestServerMessages: (messages: ConversationMessage[]) => void;\n}\n\nexport const useConversationSystemMessages = ({\n  conversationId,\n  practiceId,\n  practiceConfig,\n  messagesReady,\n  messages,\n  conversationMode,\n  isConsultFlowActive,\n  shouldRequireModeSelection,\n  ingestServerMessages\n}: ConversationSystemMessagesOptions): void => {\n  const inFlightRef = useRef(new Set<string>());\n  const completedRef = useRef(new Set<string>());\n\n  const persistSystemMessage = useCallback(async (\n    clientId: string,\n    content: string,\n    metadata?: Record<string, unknown>\n  ) => {\n    if (!conversationId || !practiceId) return;\n    const trimmedContent = content.trim();\n    const shouldAllowEmpty = clientId === 'system-contact-form';\n    if (!trimmedContent && !shouldAllowEmpty) return;\n    const key = `${conversationId}:${clientId}`;\n    if (completedRef.current.has(key) || inFlightRef.current.has(key)) {\n      return;\n    }\n    inFlightRef.current.add(key);\n    try {\n      const message = await postSystemMessage(\n        conversationId,\n        practiceId,\n        {\n          clientId,\n          content: shouldAllowEmpty ? '' : trimmedContent,\n          metadata\n        }\n      );\n      completedRef.current.add(key);\n      if (message) {\n        ingestServerMessages([message]);\n      }\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.warn('[useConversationSystemMessages] Failed to persist system message', error);\n      }\n    } finally {\n      inFlightRef.current.delete(key);\n    }\n  }, [conversationId, ingestServerMessages, practiceId]);\n\n  useEffect(() => {\n    if (!messagesReady || !conversationId || !practiceId) {\n      return;\n    }\n    if (!shouldRequireModeSelection) {\n      return;\n    }\n    if (hasSystemMessage(messages, 'intro')) {\n      return;\n    }\n    const shouldShowModeSelector =\n      shouldRequireModeSelection && !conversationMode && !isConsultFlowActive;\n    const metadata = {\n      systemMessageKey: 'intro',\n      ...(shouldShowModeSelector ? { modeSelector: true } : {})\n    };\n    void persistSystemMessage(\n      'system-intro',\n      buildIntroMessage(practiceConfig.introMessage, practiceConfig.name),\n      metadata\n    );\n  }, [\n    conversationId,\n    conversationMode,\n    isConsultFlowActive,\n    messages,\n    messagesReady,\n    practiceConfig.introMessage,\n    practiceConfig.name,\n    practiceId,\n    persistSystemMessage,\n    shouldRequireModeSelection\n  ]);\n\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/pages/WorkspacePage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":475,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":475,"endColumn":19,"suggestions":[{"fix":{"range":[19591,19660],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":613,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":613,"endColumn":20,"suggestions":[{"fix":{"range":[24674,24744],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport type { ComponentChildren } from 'preact';\nimport { useMemo, useRef, useState, useEffect, useCallback } from 'preact/hooks';\nimport axios from 'axios';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport WorkspaceHomeView from '@/features/chat/views/WorkspaceHomeView';\nimport WorkspaceNav, { type WorkspaceNavTab } from '@/features/chat/views/WorkspaceNav';\nimport ConversationListView from '@/features/chat/views/ConversationListView';\nimport { SplitView } from '@/shared/ui/layout/SplitView';\nimport { AppShell } from '@/shared/ui/layout/AppShell';\nimport { Page } from '@/shared/ui/layout/Page';\nimport { Button } from '@/shared/ui/Button';\nimport { SegmentedToggle } from '@/shared/ui/input';\nimport { cn } from '@/shared/utils/cn';\nimport { useConversations } from '@/shared/hooks/useConversations';\nimport { fetchLatestConversationMessage } from '@/shared/lib/conversationApi';\nimport { formatRelativeTime } from '@/features/matters/utils/formatRelativeTime';\nimport { usePracticeManagement } from '@/shared/hooks/usePracticeManagement';\nimport { usePracticeDetails } from '@/shared/hooks/usePracticeDetails';\nimport { PracticeSetup, type BasicsFormValues, type ContactFormValues } from '@/features/practice-setup/components/PracticeSetup';\nimport { resolvePracticeSetupStatus } from '@/features/practice-setup/utils/status';\nimport { ContactForm } from '@/features/intake/components/ContactForm';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { ServicesEditor } from '@/features/services/components/ServicesEditor';\nimport { SERVICE_CATALOG } from '@/features/services/data/serviceCatalog';\nimport type { Service } from '@/features/services/types';\nimport { resolveServiceDetails as resolveServiceEditorDetails } from '@/features/services/utils/serviceNormalization';\nimport { getServiceDetailsForSave } from '@/features/services/utils';\nimport { StripeOnboardingStep } from '@/features/onboarding/steps/StripeOnboardingStep';\nimport { extractStripeStatusFromPayload } from '@/features/onboarding/utils';\nimport type { StripeConnectStatus } from '@/features/onboarding/types';\nimport { createConnectedAccount, getOnboardingStatusPayload } from '@/shared/lib/apiClient';\nimport { getValidatedStripeOnboardingUrl } from '@/shared/utils/stripeOnboarding';\nimport { uploadPracticeLogo } from '@/shared/utils/practiceLogoUpload';\nimport { normalizeAccentColor } from '@/shared/utils/accentColors';\nimport type { ChatMessageUI } from '../../../../worker/types';\nimport type { ConversationMode } from '@/shared/types/conversation';\nimport type { LayoutMode } from '@/app/MainApp';\n\ntype WorkspaceView = 'home' | 'list' | 'conversation' | 'matters' | 'clients';\ntype PreviewTab = 'home' | 'messages' | 'intake';\n\ninterface WorkspacePageProps {\n  view: WorkspaceView;\n  practiceId: string;\n  practiceSlug: string | null;\n  practiceName?: string | null;\n  practiceLogo?: string | null;\n  messages: ChatMessageUI[];\n  layoutMode: LayoutMode;\n  showClientTabs?: boolean;\n  showPracticeTabs?: boolean;\n  workspace?: 'public' | 'practice' | 'client';\n  onStartNewConversation: (mode: ConversationMode) => Promise<string>;\n  chatView: ComponentChildren;\n  mattersView?: ComponentChildren;\n  clientsView?: ComponentChildren;\n  header?: ComponentChildren;\n  headerClassName?: string;\n}\n\nconst filterWorkspaceMessages = (messages: ChatMessageUI[]) => {\n  const base = messages.filter(\n    (message) =>\n      message.metadata?.systemMessageKey !== 'ask_question_help'\n  );\n  const hasNonSystemMessages = base.some((message) => message.role !== 'system');\n  return hasNonSystemMessages ? base.filter((message) => message.metadata?.systemMessageKey !== 'intro') : base;\n};\n\nconst WorkspacePage: FunctionComponent<WorkspacePageProps> = ({\n  view,\n  practiceId,\n  practiceSlug,\n  practiceName,\n  practiceLogo,\n  messages,\n  layoutMode,\n  showClientTabs = false,\n  showPracticeTabs = false,\n  workspace = 'public',\n  onStartNewConversation,\n  chatView,\n  mattersView,\n  clientsView,\n  header,\n  headerClassName,\n}) => {\n  const { navigate } = useNavigation();\n  const [previewTab, setPreviewTab] = useState<PreviewTab>('home');\n  const [, setDraftBasics] = useState<BasicsFormValues | null>(null);\n  const filteredMessages = useMemo(() => filterWorkspaceMessages(messages), [messages]);\n  const isPracticeWorkspace = workspace === 'practice';\n  const isClientFacingWorkspace = workspace === 'public' || workspace === 'client';\n\n  const workspaceBasePath = useMemo(() => {\n    if (workspace === 'practice') {\n      return practiceSlug ? `/practice/${encodeURIComponent(practiceSlug)}` : '/practice';\n    }\n    if (workspace === 'client') {\n      return practiceSlug ? `/client/${encodeURIComponent(practiceSlug)}` : '/client';\n    }\n    return practiceSlug ? `/public/${encodeURIComponent(practiceSlug)}` : '/public';\n  }, [workspace, practiceSlug]);\n  const conversationsPath = `${workspaceBasePath}/conversations`;\n  const previewBaseUrl = useMemo(() => {\n    const path = practiceSlug ? `/public/${encodeURIComponent(practiceSlug)}` : '/public';\n    if (typeof window !== 'undefined' && window.location?.origin) {\n      return `${window.location.origin}${path}`;\n    }\n    return path;\n  }, [practiceSlug]);\n  const previewTabOptions: Array<{ id: PreviewTab; label: string }> = [\n    { id: 'home', label: 'Home' },\n    { id: 'messages', label: 'Messages' },\n    { id: 'intake', label: 'Intake form' }\n  ];\n  const previewUrls = useMemo(() => {\n    const trimmed = previewBaseUrl.endsWith('/')\n      ? previewBaseUrl.slice(0, -1)\n      : previewBaseUrl;\n    return {\n      home: trimmed,\n      messages: `${trimmed}/conversations`\n    };\n  }, [previewBaseUrl]);\n\n  const isPracticeOnly = useMemo(() => ['clients'].includes(view), [view]);\n  const isSharedGuarded = useMemo(() => ['matters'].includes(view), [view]);\n  const allowed = useMemo(() => {\n    if (isPracticeOnly) return showPracticeTabs;\n    if (isSharedGuarded) return showClientTabs || showPracticeTabs;\n    return true;\n  }, [isPracticeOnly, isSharedGuarded, showClientTabs, showPracticeTabs]);\n\n  useEffect(() => {\n    if (!allowed) {\n      navigate(workspaceBasePath, true);\n    }\n  }, [allowed, workspaceBasePath, navigate]);\n\n  const shouldListConversations = isPracticeWorkspace ? true : view !== 'conversation';\n  const {\n    conversations,\n    isLoading: isConversationsLoading,\n    error: conversationsError,\n    refresh: refreshConversations\n  } = useConversations({\n    practiceId,\n    scope: 'practice',\n    list: shouldListConversations,\n    enabled: shouldListConversations && Boolean(practiceId)\n  });\n\n  const [conversationPreviews, setConversationPreviews] = useState<Record<string, {\n    content: string;\n    role: string;\n    createdAt: string;\n  }>>({});\n  const fetchedPreviewIds = useRef<Set<string>>(new Set());\n  const previewFailureCounts = useRef<Record<string, number>>({});\n  const MAX_PREVIEW_ATTEMPTS = 2;\n\n  useEffect(() => {\n    fetchedPreviewIds.current = new Set();\n    previewFailureCounts.current = {};\n    setConversationPreviews({});\n  }, [practiceId]);\n\n  useEffect(() => {\n    if (view === 'conversation' || conversations.length === 0 || !practiceId) {\n      return;\n    }\n    let isMounted = true;\n    const loadPreviews = async () => {\n      const updates: Record<string, { content: string; role: string; createdAt: string }> = {};\n      const toFetch = conversations.slice(0, 10).filter(\n        (conversation) => !fetchedPreviewIds.current.has(conversation.id)\n      );\n      await Promise.all(toFetch.map(async (conversation) => {\n        const message = await fetchLatestConversationMessage(\n          conversation.id,\n          practiceId\n        ).catch(() => null);\n        if (message?.content) {\n          fetchedPreviewIds.current.add(conversation.id);\n          updates[conversation.id] = {\n            content: message.content,\n            role: message.role,\n            createdAt: message.created_at\n          };\n          return;\n        }\n        const currentFailures = previewFailureCounts.current[conversation.id] ?? 0;\n        const nextFailures = currentFailures + 1;\n        previewFailureCounts.current[conversation.id] = nextFailures;\n        if (nextFailures >= MAX_PREVIEW_ATTEMPTS) {\n          fetchedPreviewIds.current.add(conversation.id);\n        }\n      }));\n      if (isMounted && Object.keys(updates).length > 0) {\n        setConversationPreviews((prev) => ({ ...prev, ...updates }));\n      }\n    };\n    void loadPreviews();\n    return () => {\n      isMounted = false;\n    };\n  }, [practiceId, conversations, view]);\n\n  const recentMessage = useMemo(() => {\n    const fallbackPracticeName = typeof practiceName === 'string'\n      ? practiceName.trim()\n      : '';\n    if (conversations.length > 0) {\n      const sorted = [...conversations].sort((a, b) => {\n        const aTime = new Date(a.last_message_at ?? a.updated_at ?? a.created_at).getTime() || 0;\n        const bTime = new Date(b.last_message_at ?? b.updated_at ?? b.created_at).getTime() || 0;\n        return bTime - aTime;\n      });\n      const top = sorted.find((conversation) => {\n        const preview = conversationPreviews[conversation.id];\n        return typeof preview?.content === 'string' && preview.content.trim().length > 0;\n      });\n      if (top) {\n        const preview = conversationPreviews[top.id];\n        const previewText = typeof preview?.content === 'string' ? preview.content.trim() : '';\n        const clipped = previewText\n          ? (previewText.length > 90 ? `${previewText.slice(0, 90)}` : previewText)\n          : 'Open to view messages.';\n        const title = typeof top.user_info?.title === 'string' ? top.user_info?.title.trim() : '';\n        const timestampLabel = preview?.createdAt\n          ? formatRelativeTime(preview.createdAt)\n          : (top.last_message_at ? formatRelativeTime(top.last_message_at) : '');\n        return {\n          preview: clipped,\n          timestampLabel,\n          senderLabel: title || fallbackPracticeName,\n          avatarSrc: practiceLogo ?? null,\n          conversationId: top.id\n        };\n      }\n    }\n    if (filteredMessages.length === 0) {\n      return null;\n    }\n    const candidate = [...filteredMessages]\n      .reverse()\n      .find((message) => message.role !== 'system' && typeof message.content === 'string' && message.content.trim().length > 0);\n    if (!candidate) {\n      return null;\n    }\n    const trimmedContent = candidate.content.trim();\n    const preview = trimmedContent.length > 90\n      ? `${trimmedContent.slice(0, 90)}`\n      : trimmedContent;\n    const timestampLabel = candidate.timestamp\n      ? formatRelativeTime(new Date(candidate.timestamp).toISOString())\n      : '';\n    return {\n      preview,\n      timestampLabel,\n      senderLabel: fallbackPracticeName,\n      avatarSrc: practiceLogo ?? null,\n      conversationId: null\n    };\n  }, [practiceLogo, practiceName, conversationPreviews, conversations, filteredMessages]);\n\n  const { currentPractice, updatePractice } = usePracticeManagement();\n  const { session } = useSessionContext();\n  const { details: setupDetails, updateDetails: updateSetupDetails } = usePracticeDetails(currentPractice?.id ?? null);\n  const setupStatus = resolvePracticeSetupStatus(currentPractice, setupDetails ?? null);\n  const { showSuccess, showError } = useToastContext();\n  const [logoUploadProgress, setLogoUploadProgress] = useState<number | null>(null);\n  const [logoUploading, setLogoUploading] = useState(false);\n  const [justSavedServices, setJustSavedServices] = useState(false);\n  const [previewReloadKey, setPreviewReloadKey] = useState(0);\n\n  const forcePreviewReload = useCallback(() => {\n    setPreviewReloadKey(prev => prev + 1);\n  }, []);\n\n  const handleSaveBasics = async (values: BasicsFormValues) => {\n    if (!currentPractice) {\n      const error = new Error('No active practice selected');\n      showError('Select a practice first', 'Choose a practice before editing basics.');\n      throw error;\n    }\n    const trimmedName = values.name.trim();\n    const trimmedSlug = values.slug.trim();\n    const trimmedIntro = values.introMessage.trim();\n    const normalizedAccentColor = normalizeAccentColor(values.accentColor);\n    if (!normalizedAccentColor) {\n      const error = new Error('Accent color must be a valid hex value (for example #3B82F6).');\n      showError('Invalid accent color', error.message);\n      throw error;\n    }\n    const practiceUpdates: Record<string, string> = {};\n\n    if (trimmedName && trimmedName !== (currentPractice.name ?? '')) {\n      practiceUpdates.name = trimmedName;\n    }\n    if (trimmedSlug && trimmedSlug !== (currentPractice.slug ?? '')) {\n      practiceUpdates.slug = trimmedSlug;\n    }\n    const introSource = setupDetails?.introMessage ?? currentPractice?.introMessage ?? '';\n    const introChanged = trimmedIntro !== introSource;\n    const accentSource = normalizeAccentColor(setupDetails?.accentColor ?? currentPractice?.accentColor);\n    const accentChanged = normalizedAccentColor !== accentSource;\n\n    try {\n      if (Object.keys(practiceUpdates).length > 0) {\n        await updatePractice(currentPractice.id, practiceUpdates);\n      }\n      if (introChanged || accentChanged) {\n        await updateSetupDetails({\n          ...(introChanged ? { introMessage: trimmedIntro.length > 0 ? trimmedIntro : null } : {}),\n          ...(accentChanged ? { accentColor: normalizedAccentColor } : {})\n        });\n      }\n      if (Object.keys(practiceUpdates).length > 0 || introChanged || accentChanged) {\n        showSuccess('Basics updated', 'Your public profile reflects the newest info.');\n        forcePreviewReload();\n      } else {\n        showSuccess('Up to date', 'Your firm basics already match these details.');\n      }\n    } catch (error) {\n      showError('Basics update failed', error instanceof Error ? error.message : 'Unable to save basics.');\n      throw error;\n    }\n  };\n\n  const handleSaveContact = async (values: ContactFormValues) => {\n    if (!currentPractice) {\n      const error = new Error('No active practice selected');\n      showError('Select a practice first', 'Choose a practice before editing contact info.');\n      throw error;\n    }\n    const normalize = (value: string) => {\n      const trimmed = value.trim();\n      return trimmed.length > 0 ? trimmed : null;\n    };\n    const address = values.address ?? {\n      address: '',\n      apartment: '',\n      city: '',\n      state: '',\n      postalCode: '',\n      country: ''\n    };\n    try {\n      await updateSetupDetails({\n        website: normalize(values.website),\n        businessEmail: normalize(values.businessEmail),\n        businessPhone: normalize(values.businessPhone),\n        address: normalize(address.address ?? ''),\n        apartment: normalize(address.apartment ?? ''),\n        city: normalize(address.city ?? ''),\n        state: normalize(address.state ?? ''),\n        postalCode: normalize(address.postalCode ?? ''),\n        country: normalize(address.country ?? '')\n      });\n      showSuccess('Contact info updated', 'Clients and receipts will use your latest details.');\n      forcePreviewReload();\n    } catch (error) {\n      showError('Contact update failed', error instanceof Error ? error.message : 'Unable to save contact info.');\n      throw error;\n    }\n  };\n\n  const handleLogoChange = async (files: FileList | File[]) => {\n    if (!currentPractice) return;\n    const nextFiles = Array.from(files || []);\n    if (nextFiles.length === 0) return;\n    setLogoUploading(true);\n    setLogoUploadProgress(0);\n    try {\n      const uploaded = await uploadPracticeLogo(nextFiles[0], currentPractice.id, (progress) => {\n        setLogoUploadProgress(progress);\n      });\n      await updatePractice(currentPractice.id, { logo: uploaded });\n      forcePreviewReload();\n    } catch (error) {\n      showError('Logo upload failed', error instanceof Error ? error.message : 'Unable to upload logo.');\n    } finally {\n      setLogoUploading(false);\n      setLogoUploadProgress(null);\n    }\n  };\n\n  const initialServiceDetails = useMemo(\n    () => resolveServiceEditorDetails(setupDetails ?? undefined, currentPractice ?? undefined),\n    [setupDetails, currentPractice]\n  );\n  const [servicesDraft, setServicesDraft] = useState<Service[]>(initialServiceDetails);\n  useEffect(() => {\n    if (justSavedServices) {\n      const draftKey = JSON.stringify(getServiceDetailsForSave(servicesDraft));\n      const initialKey = JSON.stringify(getServiceDetailsForSave(initialServiceDetails));\n      if (draftKey === initialKey) {\n        setJustSavedServices(false);\n      }\n      return;\n    }\n    setServicesDraft(initialServiceDetails);\n  }, [initialServiceDetails, justSavedServices, servicesDraft]);\n  const servicesSaveKeyRef = useRef('');\n  const servicesToastAtRef = useRef(0);\n  const [servicesError, setServicesError] = useState<string | null>(null);\n  const [servicesSaving, setServicesSaving] = useState(false);\n  const servicesToastCooldownMs = 4000;\n\n  const saveServices = useCallback(async (nextServices: Service[]) => {\n    if (!currentPractice) return;\n    const details = getServiceDetailsForSave(nextServices);\n    const apiServices = details\n      .map(({ id, title, description }) => ({\n        id: id.trim(),\n        name: title.trim(),\n        ...(description.trim() ? { description: description.trim() } : {})\n      }))\n      .filter((service) => service.id && service.name);\n    const payloadKey = JSON.stringify(apiServices);\n    if (payloadKey === servicesSaveKeyRef.current) {\n      return;\n    }\n    setServicesSaving(true);\n    try {\n      await updateSetupDetails({ services: apiServices });\n      servicesSaveKeyRef.current = payloadKey;\n      setServicesError(null);\n      const now = Date.now();\n      if (now - servicesToastAtRef.current > servicesToastCooldownMs) {\n        showSuccess('Services updated', 'Clients will now see these intake options.');\n        servicesToastAtRef.current = now;\n        forcePreviewReload();\n        setJustSavedServices(true);\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to update services';\n      setServicesError(message);\n      showError('Services update failed', message);\n    } finally {\n      setServicesSaving(false);\n    }\n  }, [currentPractice, forcePreviewReload, showError, showSuccess, updateSetupDetails]);\n\n  const handleServicesEditorChange = useCallback((nextServices: Service[]) => {\n    setServicesDraft(nextServices);\n    void saveServices(nextServices);\n  }, [saveServices]);\n\n  const organizationId = currentPractice?.id ?? null;\n  const [stripeStatus, setStripeStatus] = useState<StripeConnectStatus | null>(null);\n  const [isStripeLoading, setIsStripeLoading] = useState(false);\n  const [isStripeSubmitting, setIsStripeSubmitting] = useState(false);\n\n  const refreshStripeStatus = useCallback(async (options?: { signal?: AbortSignal }) => {\n    if (!organizationId) {\n      setStripeStatus(null);\n      return;\n    }\n    setIsStripeLoading(true);\n    try {\n      const payload = await getOnboardingStatusPayload(organizationId, { signal: options?.signal });\n      const status = extractStripeStatusFromPayload(payload);\n      setStripeStatus(status ?? null);\n    } catch (error) {\n      if (axios.isCancel(error) || (error instanceof Error && error.name === 'AbortError')) return;\n      if (axios.isAxiosError(error) && error.response?.status === 404) {\n        setStripeStatus(null);\n        return;\n      }\n      console.warn('[WorkspacePage] Failed to load payout status:', error);\n      showError('Payouts', 'Unable to load payout account status.');\n    } finally {\n      setIsStripeLoading(false);\n    }\n  }, [organizationId, showError]);\n\n  useEffect(() => {\n    const controller = new AbortController();\n    void refreshStripeStatus({ signal: controller.signal });\n    return () => controller.abort();\n  }, [refreshStripeStatus]);\n\n  const handleStartStripeOnboarding = useCallback(async () => {\n    if (!organizationId) {\n      showError('Payouts', 'Missing active practice.');\n      return;\n    }\n    const email = currentPractice?.businessEmail || session?.user?.email || '';\n    if (!email) {\n      showError('Payouts', 'Add a business email before submitting details.');\n      return;\n    }\n    if (typeof window === 'undefined') {\n      showError('Payouts', 'Unable to start Stripe onboarding in this environment.');\n      return;\n    }\n    const baseUrl = window.location.origin + window.location.pathname;\n    const returnUrl = new URL(baseUrl);\n    returnUrl.searchParams.set('stripe', 'return');\n    const refreshUrl = new URL(baseUrl);\n    refreshUrl.searchParams.set('stripe', 'refresh');\n    setIsStripeSubmitting(true);\n    try {\n      const connectedAccount = await createConnectedAccount({\n        practiceEmail: email,\n        practiceUuid: organizationId,\n        returnUrl: returnUrl.toString(),\n        refreshUrl: refreshUrl.toString()\n      });\n      if (connectedAccount.onboardingUrl) {\n        const validated = getValidatedStripeOnboardingUrl(connectedAccount.onboardingUrl);\n        if (validated) {\n          window.open(validated, '_blank');\n          return;\n        }\n        showError('Payouts', 'Received an invalid Stripe onboarding link. Please try again.');\n        return;\n      }\n      showError('Payouts', 'Stripe onboarding link was not provided. Please try again.');\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to start Stripe onboarding';\n      showError('Payouts', message);\n    } finally {\n      setIsStripeSubmitting(false);\n    }\n\n  }, [organizationId, currentPractice?.businessEmail, session?.user?.email, showError]);\n\n  const handleIntakePreviewSubmit = useCallback(async () => {\n    showSuccess('Intake preview submitted', 'This submission is for preview only.');\n    forcePreviewReload();\n  }, [showSuccess, forcePreviewReload]);\n\n  const servicesSlot = (\n    <div className=\"space-y-4 text-input-text\">\n      <div>\n        <p className=\"text-xs font-semibold uppercase tracking-[0.35em] text-input-placeholder\">Services & intake</p>\n        <p className=\"text-xl font-semibold\">What can clients request?</p>\n      </div>\n      <ServicesEditor\n        services={servicesDraft}\n        onChange={handleServicesEditorChange}\n        catalog={SERVICE_CATALOG}\n      />\n      {servicesError ? (\n        <p className=\"text-sm text-red-600 dark:text-red-300\">{servicesError}</p>\n      ) : (\n        <p className=\"text-xs text-input-placeholder\">\n          {servicesSaving ? 'Saving changes' : 'Updates apply automatically to your public intake form.'}\n        </p>\n      )}\n    </div>\n  );\n\n  const payoutDetailsSubmitted = stripeStatus?.details_submitted === true;\n  const payoutsSlot = (\n    <div className=\"space-y-4 text-input-text\">\n      <div>\n        <p className=\"text-xs font-semibold uppercase tracking-[0.35em] text-input-placeholder\">Payouts</p>\n        <p className=\"text-xl font-semibold\">Connect Stripe to accept payments</p>\n        <p className=\"text-sm text-input-placeholder\">\n          Verification takes about 5 minutes and unlocks consultation fees.\n        </p>\n      </div>\n      <div className=\"glass-panel p-4\">\n        {payoutDetailsSubmitted ? (\n          <p className=\"text-sm text-input-text\">\n            Your Stripe account is connected. Clients can pay consultation fees before intake.\n          </p>\n        ) : (\n          <>\n            <Button\n              variant=\"primary\"\n              size=\"sm\"\n              onClick={handleStartStripeOnboarding}\n              disabled={isStripeSubmitting || isStripeLoading}\n            >\n              {isStripeSubmitting ? 'Preparing Stripe' : 'Start Stripe onboarding'}\n            </Button>\n            <p className=\"mt-2 text-xs text-input-placeholder\">\n              Well open Stripes secure verification flow in a new tab.\n            </p>\n          </>\n        )}\n        {stripeStatus && !payoutDetailsSubmitted && (\n          <div className=\"mt-4 glass-panel p-3\">\n            <StripeOnboardingStep\n              status={stripeStatus}\n              loading={isStripeLoading}\n              showIntro={false}\n              showInfoCard={false}\n            />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n\n  if (!allowed) {\n    return null;\n  }\n\n  const handleStartConversation = async (mode: ConversationMode) => {\n    try {\n      const conversationId = await onStartNewConversation(mode);\n      navigate(`${conversationsPath}/${encodeURIComponent(conversationId)}`);\n    } catch (error) {\n      console.error('[WorkspacePage] Failed to start conversation:', error);\n      showError('Unable to start conversation', 'Please try again in a moment.');\n    }\n  };\n\n  const handleOpenRecentMessage = () => {\n    if (recentMessage?.conversationId) {\n      navigate(`${conversationsPath}/${encodeURIComponent(recentMessage.conversationId)}`);\n      return;\n    }\n    navigate(conversationsPath);\n  };\n\n  const renderContent = () => {\n    if (workspace === 'practice' && view === 'home') {\n      const renderPreviewContent = () => {\n        if (previewTab === 'intake') {\n          return (\n            <div className=\"flex h-full w-full flex-col overflow-y-auto bg-transparent p-4\">\n              <ContactForm\n                onSubmit={handleIntakePreviewSubmit}\n                message=\"Tell us about your matter and we will follow up shortly.\"\n              />\n            </div>\n          );\n        }\n\n        return (\n          <iframe\n            key={`${previewTab}-${previewReloadKey}`}\n            title=\"Public workspace preview\"\n            src={previewTab === 'messages' ? previewUrls.messages : previewUrls.home}\n            className=\"h-full w-full border-0\"\n            loading=\"lazy\"\n          />\n        );\n      };\n\n      return (\n        <div className=\"flex min-h-0 w-full flex-col lg:h-full lg:flex-row lg:overflow-hidden\">\n          {/* Left column */}\n          <div className=\"relative flex w-full flex-col bg-transparent lg:min-h-0 lg:flex-1 lg:overflow-hidden\">\n            <div className=\"relative z-10 flex min-h-0 flex-1 flex-col lg:overflow-y-auto\">\n              <Page className=\"mx-auto w-full max-w-3xl flex-1\">\n                <PracticeSetup\n                  status={setupStatus}\n                  practice={currentPractice}\n                  details={setupDetails ?? null}\n                  onSaveBasics={handleSaveBasics}\n                  onSaveContact={handleSaveContact}\n                  servicesSlot={servicesSlot}\n                  payoutsSlot={payoutsSlot}\n                  logoUploading={logoUploading}\n                  logoUploadProgress={logoUploadProgress}\n                  onLogoChange={handleLogoChange}\n                  onBasicsDraftChange={setDraftBasics}\n                />\n              </Page>\n            </div>\n          </div>\n\n          {/* Right: Public Preview */}\n          <div className=\"relative flex w-full flex-col items-center gap-5 border-t border-line-glass/30 bg-transparent px-4 py-6 lg:w-[420px] lg:shrink-0 lg:border-t-0 lg:border-l lg:border-l-line-glass/30\">\n            <div className=\"relative flex w-full flex-col items-center gap-5\">\n            <div className=\"text-xs font-semibold uppercase tracking-[0.35em] text-input-placeholder\">\n              Public preview\n            </div>\n            <SegmentedToggle<PreviewTab>\n              value={previewTab}\n              options={previewTabOptions.map((option) => ({\n                value: option.id,\n                label: option.label\n              }))}\n              onChange={setPreviewTab}\n              ariaLabel=\"Public preview tabs\"\n            />\n            <div className=\"relative aspect-[9/19.5] w-full max-w-[360px] overflow-hidden glass-card shadow-glass\">\n              {renderPreviewContent()}\n              <div className=\"pointer-events-none absolute inset-0 rounded-3xl ring-1 ring-white/10\" aria-hidden=\"true\" />\n            </div>\n            <p className=\"max-w-xs text-center text-xs text-input-placeholder\">\n              This live preview matches exactly what clients see on your public link.\n            </p>\n            </div>\n          </div>\n        </div>\n      );\n    }\n\n    switch (view) {\n      case 'home':\n        return (\n          <WorkspaceHomeView\n            practiceName={practiceName}\n            practiceLogo={practiceLogo}\n            onSendMessage={() => handleStartConversation('ASK_QUESTION')}\n            onRequestConsultation={() => handleStartConversation('REQUEST_CONSULTATION')}\n            recentMessage={recentMessage}\n            onOpenRecentMessage={handleOpenRecentMessage}\n            consultationTitle={undefined}\n            consultationDescription={undefined}\n            consultationCta={undefined}\n          />\n        );\n      case 'list':\n        return (\n          <ConversationListView\n            conversations={conversations}\n            previews={conversationPreviews}\n            practiceName={practiceName}\n            practiceLogo={practiceLogo}\n            isLoading={isConversationsLoading}\n            error={conversationsError}\n            onClose={() => navigate(workspaceBasePath)}\n            onSelectConversation={(conversationId) => {\n              navigate(`${conversationsPath}/${encodeURIComponent(conversationId)}`);\n            }}\n            onSendMessage={() => handleStartConversation('ASK_QUESTION')}\n            showSendMessageButton={isClientFacingWorkspace}\n          />\n        );\n      case 'matters':\n        return mattersView ?? (\n          <div className=\"flex flex-1 flex-col glass-card\">\n            <div className=\"px-6 py-6\">\n              <h2 className=\"text-lg font-semibold text-input-text\">Matters</h2>\n              <p className=\"mt-2 text-sm text-input-placeholder\">\n                Your active matters will appear here once a practice connects them to your account.\n              </p>\n            </div>\n            <div className=\"mx-6 mb-6 glass-panel p-5\">\n              <div className=\"text-sm font-semibold text-input-text\">No matters yet</div>\n              <div className=\"mt-2 text-sm text-input-placeholder\">\n                Start a conversation to open a new matter with the practice.\n              </div>\n            </div>\n          </div>\n        );\n      case 'clients':\n        return clientsView ?? (\n          <div className=\"flex flex-1 flex-col glass-card\">\n            <div className=\"px-6 py-6\">\n              <h2 className=\"text-lg font-semibold text-input-text\">Clients</h2>\n              <p className=\"mt-2 text-sm text-input-placeholder\">\n                Manage your practice clients here.\n              </p>\n            </div>\n          </div>\n        );\n      case 'conversation':\n      default:\n        return (\n          <div className=\"flex h-full min-h-0 flex-1 flex-col\">\n            {chatView}\n          </div>\n        );\n    }\n  };\n\n  const hideBottomNav = isClientFacingWorkspace && (view === 'list' || view === 'conversation');\n  const showBottomNav = workspace !== 'practice'\n    ? !hideBottomNav\n    : (showClientTabs || showPracticeTabs || view === 'home' || view === 'list' || view === 'matters' || view === 'clients');\n  const activeTab = view === 'list' || view === 'conversation'\n    ? 'messages'\n    : view === 'matters'\n    ? 'matters'\n    : view === 'clients'\n    ? 'clients'\n    : view;\n  const handleSelectTab = (tab: WorkspaceNavTab) => {\n    if (tab === 'messages') {\n      void refreshConversations();\n      navigate(conversationsPath);\n      return;\n    }\n    if (tab === 'matters') {\n      navigate(`${workspaceBasePath}/matters`);\n      return;\n    }\n    if (tab === 'clients') {\n      navigate(`${workspaceBasePath}/clients`);\n      return;\n    }\n    if (tab === 'settings') {\n      navigate('/settings');\n      return;\n    }\n    navigate(workspaceBasePath);\n  };\n\n  const bottomNav = showBottomNav ? (\n    <WorkspaceNav\n      variant=\"bottom\"\n      activeTab={activeTab}\n      showClientTabs={showClientTabs}\n      showPracticeTabs={showPracticeTabs}\n      onSelectTab={handleSelectTab}\n    />\n  ) : undefined;\n\n  const sidebarNav = showBottomNav ? (\n    <WorkspaceNav\n      variant=\"sidebar\"\n      activeTab={activeTab}\n      showClientTabs={showClientTabs}\n      showPracticeTabs={showPracticeTabs}\n      onSelectTab={handleSelectTab}\n    />\n  ) : undefined;\n\n  const conversationListView = (\n    <div className=\"flex h-full min-h-0 flex-1 flex-col\">\n      <ConversationListView\n        conversations={conversations}\n        previews={conversationPreviews}\n        practiceName={practiceName}\n        practiceLogo={practiceLogo}\n        isLoading={isConversationsLoading}\n        error={conversationsError}\n        onClose={() => navigate(workspaceBasePath)}\n        onSelectConversation={(conversationId) => {\n          navigate(`${conversationsPath}/${encodeURIComponent(conversationId)}`);\n        }}\n        onSendMessage={() => handleStartConversation('ASK_QUESTION')}\n        showBackButton={false}\n        showSendMessageButton={isClientFacingWorkspace}\n      />\n    </div>\n  );\n\n  const showListOnMobile = view === 'list';\n  const showChatOnMobile = view === 'conversation';\n  const isSplitView = isPracticeWorkspace && (view === 'list' || view === 'conversation');\n  const shouldAllowMainScroll = view !== 'conversation' && view !== 'list';\n  const mainContent = isSplitView\n    ? (\n      <SplitView\n        className=\"h-full min-h-0 w-full\"\n        primary={conversationListView}\n        secondary={chatView}\n        primaryClassName={cn(\n          'min-h-0',\n          showListOnMobile ? 'block' : 'hidden',\n          'md:block'\n        )}\n        secondaryClassName={cn(\n          'min-h-0',\n          showChatOnMobile ? 'block' : 'hidden',\n          'md:block'\n        )}\n      />\n    )\n    : (\n      <div className={cn('min-h-0 h-full flex flex-1 flex-col', shouldAllowMainScroll ? 'overflow-y-auto' : 'overflow-hidden')}>\n        {renderContent()}\n      </div>\n    );\n\n  const isPublicShell = layoutMode !== 'desktop';\n\n  const publicShellFrameClass = workspace === 'public' || workspace === 'client'\n    ? 'bg-transparent border-line-glass/30'\n    : 'bg-surface-glass/40 border-line-glass/30 backdrop-blur-xl shadow-glass';\n\n  const mainShell = isPublicShell ? (\n    <div className=\"flex h-full min-h-0 w-full flex-1 flex-col\">\n      <div className={cn(\n        'flex h-full min-h-0 flex-1 flex-col rounded-3xl border overflow-hidden',\n        publicShellFrameClass\n      )}>\n        {header && (\n          <div className={cn('w-full', headerClassName)}>\n            {header}\n          </div>\n        )}\n        <div className=\"min-h-0 h-full flex-1\">{mainContent}</div>\n        {bottomNav && (\n          <div className=\"mt-auto\">\n            {bottomNav}\n          </div>\n        )}\n      </div>\n    </div>\n  ) : (\n    <div className=\"flex h-full min-h-0 w-full flex-1 flex-col\">\n      {header && (\n        <div className={cn('w-full', headerClassName)}>\n          {header}\n        </div>\n      )}\n      {mainContent}\n    </div>\n  );\n\n  return (\n    <AppShell\n      className=\"bg-transparent h-dvh\"\n      accentBackdropVariant=\"workspace\"\n      sidebar={sidebarNav}\n      main={mainShell}\n      mainClassName={cn('min-h-0 h-full overflow-hidden', !isPublicShell && showBottomNav ? 'pb-20 md:pb-0' : undefined)}\n      bottomBar={isPublicShell ? undefined : bottomNav}\n      bottomBarClassName={!isPublicShell && showBottomNav ? 'md:hidden fixed inset-x-0 bottom-0 z-40 bg-transparent' : undefined}\n    />\n  );\n};\n\nexport default WorkspacePage;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/styles/chatTypography.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/utils/fileUtils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/views/ConversationListView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/views/WorkspaceHomeView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/chat/views/WorkspaceNav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/clients/pages/PracticeClientsPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":368,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":368,"endColumn":19,"suggestions":[{"fix":{"range":[12990,13092],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":441,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":441,"endColumn":20,"suggestions":[{"fix":{"range":[15226,15288],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":466,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":466,"endColumn":22,"suggestions":[{"fix":{"range":[15871,15933],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":483,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":483,"endColumn":20,"suggestions":[{"fix":{"range":[16489,16545],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":498,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":498,"endColumn":20,"suggestions":[{"fix":{"range":[17134,17190],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":515,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":515,"endColumn":20,"suggestions":[{"fix":{"range":[17833,17889],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":591,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":591,"endColumn":20,"suggestions":[{"fix":{"range":[20186,20249],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":623,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":623,"endColumn":20,"suggestions":[{"fix":{"range":[21370,21428],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":641,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":641,"endColumn":20,"suggestions":[{"fix":{"range":[22197,22255],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":672,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":672,"endColumn":20,"suggestions":[{"fix":{"range":[23355,23413],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Fragment } from 'preact';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { PageHeader } from '@/shared/ui/layout/PageHeader';\nimport { Page } from '@/shared/ui/layout/Page';\nimport { Panel } from '@/shared/ui/layout/Panel';\nimport { SplitView } from '@/shared/ui/layout/SplitView';\nimport { Button } from '@/shared/ui/Button';\nimport Modal from '@/shared/components/Modal';\nimport { Avatar } from '@/shared/ui/profile';\nimport { FormActions } from '@/shared/ui/form';\nimport { AddressExperienceForm } from '@/shared/ui/address/AddressExperienceForm';\nimport { useMobileDetection } from '@/shared/hooks/useMobileDetection';\nimport { cn } from '@/shared/utils/cn';\nimport { ActivityTimeline, type TimelineItem } from '@/shared/ui/activity/ActivityTimeline';\nimport { formatDate } from '@/shared/utils/dateTime';\nimport { usePracticeManagement } from '@/shared/hooks/usePracticeManagement';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport type { Address } from '@/shared/types/address';\nimport {\n  listUserDetails,\n  listUserDetailMemos,\n  createUserDetailMemo,\n  updateUserDetailMemo,\n  deleteUserDetailMemo,\n  createUserDetail,\n  updateUserDetail,\n  deleteUserDetail,\n  getUserDetail,\n  type UserDetailRecord,\n  type UserDetailStatus,\n  type UserDetailMemoRecord\n} from '@/shared/lib/apiClient';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger\n} from '@/shared/ui/dropdown';\nimport {\n  ArrowUpTrayIcon,\n  ChatBubbleLeftRightIcon,\n  EllipsisVerticalIcon,\n  PlusIcon,\n  UserIcon,\n  DocumentTextIcon as DocumentTextOutlineIcon\n} from '@heroicons/react/24/outline';\n\nconst STATUS_LABELS: Record<UserDetailStatus, string> = {\n  lead: 'Lead',\n  active: 'Active',\n  inactive: 'Inactive',\n  archived: 'Archived',\n};\n\ntype ClientRecord = {\n  id: string;\n  name: string;\n  email: string;\n  phone?: string | null;\n  status: UserDetailStatus;\n};\n\ntype ClientFormState = {\n  name: string;\n  email: string;\n  phone: string;\n  status: UserDetailStatus;\n  currency: string;\n  address?: Address;  // Now uses Address object like intake form!\n};\n\ntype EditClientFormState = ClientFormState & { id: string };\n\nconst formatPhoneNumber = (phone?: string | null) => {\n  if (!phone) return 'Not provided';\n  const cleaned = phone.replace(/\\D/g, '');\n  if (cleaned.length === 10) {\n    return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;\n  }\n  if (cleaned.length === 11) {\n    return `+${cleaned.slice(0, 1)} (${cleaned.slice(1, 4)}) ${cleaned.slice(4, 7)}-${cleaned.slice(7)}`;\n  }\n  return phone;\n};\n\nconst splitName = (fullName: string) => {\n  const parts = fullName.trim().split(/\\s+/).filter(Boolean);\n  if (parts.length === 0) {\n    return { first: '', last: '' };\n  }\n  if (parts.length === 1) {\n    return { first: '', last: parts[0] };\n  }\n  const last = parts[parts.length - 1];\n  const first = parts.slice(0, -1).join(' ');\n  return { first, last };\n};\n\nconst EmptyState = ({ onAddClient }: { onAddClient: () => void }) => (\n  <div className=\"flex h-full items-center justify-center p-6\">\n    <div className=\"max-w-md text-center\">\n      <div className=\"mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-white/5 border border-white/10\">\n        <UserIcon className=\"h-6 w-6 text-input-placeholder\" aria-hidden=\"true\" />\n      </div>\n      <h3 className=\"mt-4 text-sm font-semibold text-input-text\">No clients yet</h3>\n      <p className=\"mt-2 text-sm text-input-placeholder\">\n        Get started by creating a new client or importing your existing clients.\n      </p>\n      <div className=\"mt-6 flex flex-col gap-3 sm:flex-row sm:justify-center\">\n        <Button size=\"sm\" icon={<PlusIcon className=\"h-4 w-4\" />} onClick={onAddClient}>\n          Add Client\n        </Button>\n        <Button size=\"sm\" variant=\"secondary\" icon={<ArrowUpTrayIcon className=\"h-4 w-4\" />} disabled>\n          Import Clients\n        </Button>\n      </div>\n    </div>\n  </div>\n);\n\nconst StatusPill = ({ status }: { status: UserDetailStatus }) => (\n  <span\n    className={cn(\n      'inline-flex items-center rounded-full px-2.5 py-1 text-xs font-medium',\n      status === 'active'\n        ? 'bg-emerald-500/10 text-emerald-400'\n        : status === 'lead'\n          ? 'bg-amber-500/10 text-amber-400'\n          : status === 'inactive'\n            ? 'glass-panel text-input-placeholder px-2 py-0.5'\n            : 'glass-panel opacity-60 text-input-placeholder px-2 py-0.5'\n    )}\n  >\n    {STATUS_LABELS[status]}\n  </span>\n);\n\nconst CLIENT_FIELDS = ['name', 'email', 'phone', 'status', 'currency', 'address'] as const;\nconst CLIENT_REQUIRED = ['name', 'email'] as const;\n\nconst ClientForm = ({\n  values,\n  onChange,\n  disabled = false\n}: {\n  values: ClientFormState;\n  onChange: <K extends keyof ClientFormState>(field: K, value: ClientFormState[K]) => void;\n  disabled?: boolean;\n}) => (\n  <AddressExperienceForm\n    initialValues={values}\n    fields={[...CLIENT_FIELDS]}\n    required={[...CLIENT_REQUIRED]}\n    onValuesChange={(updates) => {\n      Object.entries(updates).forEach(([key, value]) => {\n        onChange(key as keyof ClientFormState, value as ClientFormState[keyof ClientFormState]);\n      });\n    }}\n    showSubmitButton={false}\n    variant=\"plain\"\n    disabled={disabled}\n  />\n);\n\nconst ClientDetailPanel = ({\n  client,\n  activity,\n  practiceId,\n  onAddMemo,\n  memoSubmitting = false,\n  onEditMemo,\n  onDeleteMemo,\n  memoActionId,\n  onEditClient,\n  onDeleteClient,\n  paddingClassName = ''\n}: {\n  client: ClientRecord;\n  activity: TimelineItem[];\n  practiceId?: string | null;\n  onAddMemo?: (value: string) => void | Promise<void>;\n  memoSubmitting?: boolean;\n  onEditMemo?: (memoId: string, value: string) => void | Promise<void>;\n  onDeleteMemo?: (memoId: string) => void | Promise<void>;\n  memoActionId?: string | null;\n  onEditClient?: () => void;\n  onDeleteClient?: () => void;\n  paddingClassName?: string;\n}) => (\n  <div className={cn('h-full overflow-y-auto px-6 py-6', paddingClassName)}>\n    <div className=\"divide-y divide-line-default\">\n      <div className=\"pb-6\">\n        <div>\n          <h2 className=\"text-xl font-semibold text-input-text\">{client.name}</h2>\n          <p className=\"text-sm text-input-placeholder\">{client.email}</p>\n        </div>\n        <div className=\"mt-4 flex flex-wrap items-center gap-2\">\n          <Button size=\"sm\" icon={<DocumentTextOutlineIcon className=\"h-4 w-4\" />}>\n            Generate Invoice\n          </Button>\n          <Button\n            variant=\"secondary\"\n            size=\"sm\"\n            icon={<ChatBubbleLeftRightIcon className=\"h-4 w-4\" />}\n            disabled={!client.phone}\n          >\n            Send message\n          </Button>\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <Button\n                variant=\"secondary\"\n                size=\"icon\"\n                icon={<EllipsisVerticalIcon className=\"h-5 w-5\" />}\n                aria-label=\"Open client actions\"\n              />\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\">\n              <div className=\"py-1\">\n                <DropdownMenuItem onSelect={onEditClient} disabled={!onEditClient}>\n                  Edit\n                </DropdownMenuItem>\n                <DropdownMenuItem\n                  onSelect={onDeleteClient}\n                  disabled={!onDeleteClient}\n                  className=\"text-red-600 dark:text-red-400\"\n                >\n                  Delete\n                </DropdownMenuItem>\n              </div>\n            </DropdownMenuContent>\n          </DropdownMenu>\n        </div>\n      </div>\n      <div className=\"py-6\">\n        <dl className=\"divide-y divide-line-default\">\n          <div className=\"py-4\">\n            <dt className=\"text-sm font-medium text-input-placeholder\">Email</dt>\n            <dd className=\"mt-1 text-sm text-input-text\">{client.email}</dd>\n          </div>\n          <div className=\"py-4\">\n            <dt className=\"text-sm font-medium text-input-placeholder\">Phone</dt>\n            <dd className=\"mt-1 text-sm text-input-text\">{formatPhoneNumber(client.phone)}</dd>\n          </div>\n          <div className=\"py-4\">\n            <dt className=\"text-sm font-medium text-input-placeholder\">Status</dt>\n            <dd className=\"mt-2\">\n              <StatusPill status={client.status} />\n            </dd>\n          </div>\n        </dl>\n      </div>\n      <div className=\"pt-6\">\n        <h3 className=\"text-sm font-semibold text-input-text\">Recent activity</h3>\n        <div className=\"mt-4\">\n          <ActivityTimeline\n            items={activity}\n            showComposer\n            composerDisabled={!onAddMemo}\n            composerSubmitting={memoSubmitting}\n            onComposerSubmit={onAddMemo}\n            composerLabel=\"Comment\"\n            composerPlaceholder=\"Add your comment...\"\n            composerPracticeId={practiceId}\n            onEditComment={onEditMemo}\n            onDeleteComment={onDeleteMemo}\n            commentActionsDisabled={memoSubmitting || Boolean(memoActionId)}\n          />\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\nexport const PracticeClientsPage = () => {\n  const isMobile = useMobileDetection();\n  const { currentPractice } = usePracticeManagement();\n  const { showError, showSuccess } = useToastContext();\n  const [clients, setClients] = useState<ClientRecord[]>([]);\n  const [clientsLoading, setClientsLoading] = useState(false);\n  const [clientsError, setClientsError] = useState<string | null>(null);\n  const [clientsPage, setClientsPage] = useState(1);\n  const [clientsHasMore, setClientsHasMore] = useState(true);\n  const [clientsLoadingMore, setClientsLoadingMore] = useState(false);\n  const [memoTimeline, setMemoTimeline] = useState<Record<string, TimelineItem[]>>({});\n  const [memoSubmitting, setMemoSubmitting] = useState(false);\n  const [memoActionId, setMemoActionId] = useState<string | null>(null);\n  const [isAddClientOpen, setIsAddClientOpen] = useState(false);\n  const [addClientSubmitting, setAddClientSubmitting] = useState(false);\n  const [addClientError, setAddClientError] = useState<string | null>(null);\n  const [isEditClientOpen, setIsEditClientOpen] = useState(false);\n  const [editClientSubmitting, setEditClientSubmitting] = useState(false);\n  const [editClientError, setEditClientError] = useState<string | null>(null);\n\n  const defaultClientFormState: ClientFormState = {\n    name: '',\n    email: '',\n    phone: '',\n    status: 'lead' as UserDetailStatus,\n    currency: 'usd',\n    address: undefined,  // Now uses Address object like intake form!\n  };\n\n  const [addClientForm, setAddClientForm] = useState<ClientFormState>(defaultClientFormState);\n  const [editClientForm, setEditClientForm] = useState<EditClientFormState>({\n    id: '',\n    name: '',\n    email: '',\n    phone: '',\n    status: 'lead' as UserDetailStatus,\n    currency: 'usd',\n    address: undefined,  // Now uses Address object like intake form!\n  });\n\n  const sortedClients = useMemo(\n    () => [...clients].sort((a, b) => a.name.localeCompare(b.name)),\n    [clients]\n  );\n  const groupedClients = useMemo(() => {\n    return sortedClients.reduce<Record<string, ClientRecord[]>>((acc, client) => {\n      const letter = client.name.charAt(0).toUpperCase();\n      if (!acc[letter]) {\n        acc[letter] = [];\n      }\n      acc[letter].push(client);\n      return acc;\n    }, {});\n  }, [sortedClients]);\n  const letters = useMemo(() => Object.keys(groupedClients).sort(), [groupedClients]);\n\n  const [selectedClientId, setSelectedClientId] = useState(() => sortedClients[0]?.id ?? '');\n  const [isDrawerOpen, setIsDrawerOpen] = useState(false);\n  const [currentLetter, setCurrentLetter] = useState(() => letters[0] ?? '');\n  const listRef = useRef<HTMLDivElement>(null);\n  const loadMoreRef = useRef<HTMLLIElement>(null);\n  const pageSize = 50;\n\n  const selectedClient = useMemo(() => {\n    return sortedClients.find((client) => client.id === selectedClientId) ?? sortedClients[0] ?? null;\n  }, [selectedClientId, sortedClients]);\n\n  const selectedClientActivity = useMemo(() => {\n    if (!selectedClient) return [];\n    return memoTimeline[selectedClient.id] ?? [];\n  }, [memoTimeline, selectedClient]);\n\n  const handleSelectClient = useCallback((clientId: string) => {\n    setSelectedClientId(clientId);\n    if (isMobile) {\n      setIsDrawerOpen(true);\n    }\n  }, [isMobile]);\n\n  const buildClientRecord = useCallback((detail: UserDetailRecord): ClientRecord => {\n    const name = detail.user?.name?.trim() || detail.user?.email?.trim() || 'Unknown Client';\n    return {\n      id: detail.id,\n      name,\n      email: detail.user?.email ?? 'Unknown email',\n      phone: detail.user?.phone ?? null,\n      status: detail.status\n    };\n  }, []);\n\n  const mapMemosToTimeline = useCallback((client: ClientRecord, memos: UserDetailMemoRecord[]): TimelineItem[] => {\n    const withoutId = memos.filter((memo) => !memo.id);\n    if (withoutId.length > 0) {\n      console.warn('[Clients] Skipping memos without id', { clientId: client.id, count: withoutId.length });\n    }\n\n    return memos.filter((memo) => Boolean(memo.id)).map((memo) => {\n      const rawDate =\n        memo.event_time ||\n        memo.created_at ||\n        memo.createdAt ||\n        memo.updated_at ||\n        memo.updatedAt ||\n        new Date().toISOString();\n      const comment = memo.content ?? '';\n      const personName =\n        memo.user?.name ??\n        memo.user?.email ??\n        'Team member';\n      const date = formatDate(rawDate);\n      return {\n        id: memo.id as string,\n        type: 'commented',\n        person: {\n          name: personName || 'Team member'\n        },\n        date,\n        dateTime: rawDate,\n        comment\n      };\n    });\n  }, []);\n\n  const refreshClientMemos = useCallback(async (client: ClientRecord) => {\n    if (!currentPractice?.id) return;\n    const memos = await listUserDetailMemos(currentPractice.id, client.id);\n    setMemoTimeline((prev) => ({\n      ...prev,\n      [client.id]: mapMemosToTimeline(client, memos)\n    }));\n  }, [currentPractice?.id, mapMemosToTimeline]);\n\n  const fetchClientsPage = useCallback(async (page: number, options?: { replace?: boolean }) => {\n    if (!currentPractice?.id) {\n      setClients([]);\n      setClientsHasMore(true);\n      setClientsPage(1);\n      return;\n    }\n\n    if (options?.replace) {\n      setClientsLoading(true);\n      setClientsError(null);\n      setClientsHasMore(true);\n      setClientsPage(1);\n    }\n\n    try {\n      const offset = (page - 1) * pageSize;\n      const response = await listUserDetails(currentPractice.id, { limit: pageSize, offset });\n      const nextClients = response.data.map(buildClientRecord);\n      if (options?.replace) {\n        setClients(nextClients);\n      } else {\n        setClients((prev) => [...prev, ...nextClients]);\n      }\n      setClientsHasMore(nextClients.length === pageSize);\n      setClientsPage(page);\n      if (options?.replace) {\n        if (nextClients.length > 0) {\n          setSelectedClientId((prev) => (prev && nextClients.some(c => c.id === prev) ? prev : nextClients[0].id));\n        } else {\n          setSelectedClientId('');\n        }\n      }\n    } catch (error) {\n      console.error('[Clients] Failed to load user details', error);\n      setClientsError('Failed to load clients');\n      setClientsHasMore(false);\n    } finally {\n      if (options?.replace) {\n        setClientsLoading(false);\n      }\n      setClientsLoadingMore(false);\n    }\n  }, [\n    buildClientRecord,\n    currentPractice?.id,\n    pageSize\n  ]);\n\n  useEffect(() => {\n    void fetchClientsPage(1, { replace: true });\n  }, [fetchClientsPage]);\n\n  useEffect(() => {\n    if (!currentPractice?.id || !selectedClient) return;\n    if (memoTimeline[selectedClient.id]) return;\n\n    refreshClientMemos(selectedClient)\n      .catch((error) => {\n        console.error('[Clients] Failed to load client memos', error);\n        setMemoTimeline((prev) => ({\n          ...prev,\n          [selectedClient.id]: []\n        }));\n      });\n  }, [currentPractice?.id, memoTimeline, refreshClientMemos, selectedClient]);\n\n  const handleMemoSubmit = useCallback(async (text: string) => {\n    if (!currentPractice?.id || !selectedClient) return;\n    if (memoSubmitting) return;\n\n    setMemoSubmitting(true);\n    try {\n      await createUserDetailMemo(currentPractice.id, selectedClient.id, { content: text });\n      await refreshClientMemos(selectedClient);\n    } catch (error) {\n      console.error('[Clients] Failed to create memo', error);\n      showError('Could not add memo', 'Please try again.');\n    } finally {\n      setMemoSubmitting(false);\n    }\n  }, [currentPractice?.id, memoSubmitting, refreshClientMemos, selectedClient, showError]);\n\n  const handleMemoEdit = useCallback(async (memoId: string, text: string) => {\n    if (!currentPractice?.id || !selectedClient) return;\n    if (memoActionId) return;\n    setMemoActionId(memoId);\n    try {\n      await updateUserDetailMemo(currentPractice.id, selectedClient.id, memoId, { content: text });\n      await refreshClientMemos(selectedClient);\n    } catch (error) {\n      console.error('[Clients] Failed to update memo', error);\n      showError('Could not update memo', 'Please try again.');\n    } finally {\n      setMemoActionId(null);\n    }\n  }, [currentPractice?.id, memoActionId, refreshClientMemos, selectedClient, showError]);\n\n  const handleMemoDelete = useCallback(async (memoId: string) => {\n    if (!currentPractice?.id || !selectedClient) return;\n    if (memoActionId) return;\n    const confirmed = window.confirm('Delete this memo?');\n    if (!confirmed) return;\n    setMemoActionId(memoId);\n    try {\n      await deleteUserDetailMemo(currentPractice.id, selectedClient.id, memoId);\n      await refreshClientMemos(selectedClient);\n    } catch (error) {\n      console.error('[Clients] Failed to delete memo', error);\n      showError('Could not delete memo', 'Please try again.');\n    } finally {\n      setMemoActionId(null);\n    }\n  }, [currentPractice?.id, memoActionId, refreshClientMemos, selectedClient, showError]);\n\n  const handleOpenAddClient = useCallback(() => {\n    setAddClientError(null);\n    setIsAddClientOpen(true);\n  }, []);\n\n  const updateAddClientField = useCallback(<K extends keyof ClientFormState>(\n    field: K,\n    value: ClientFormState[K]\n  ) => {\n    setAddClientForm((prev) => ({ ...prev, [field]: value }));\n  }, []);\n\n  const resetAddClientForm = useCallback(() => {\n    setAddClientForm({\n      name: '',\n      email: '',\n      phone: '',\n      status: 'lead',\n      currency: 'usd',\n      address: undefined,  // Now uses Address object like intake form!\n    });\n  }, []);\n\n  const handleCloseAddClient = useCallback(() => {\n    setIsAddClientOpen(false);\n    setAddClientError(null);\n  }, []);\n\n  const updateEditClientField = useCallback(<K extends keyof ClientFormState>(\n    field: K,\n    value: ClientFormState[K]\n  ) => {\n    setEditClientForm((prev) => ({ ...prev, [field]: value }));\n  }, []);\n\n  const resetEditClientForm = useCallback(() => {\n    setEditClientForm({\n      id: '',\n      name: '',\n      email: '',\n      phone: '',\n      status: 'lead',\n      currency: 'usd',\n      address: undefined,  // Now uses Address object like intake form!\n    });\n  }, []);\n\n  const handleCloseEditClient = useCallback(() => {\n    setIsEditClientOpen(false);\n    setEditClientError(null);\n  }, []);\n\n  const handleOpenEditClient = useCallback(async () => {\n    if (!currentPractice?.id || !selectedClient) return;\n    setEditClientError(null);\n    try {\n      const detail = await getUserDetail(currentPractice.id, selectedClient.id);\n      const name = detail?.user?.name?.trim() || detail?.user?.email?.trim() || selectedClient.name;\n      setEditClientForm({\n        id: selectedClient.id,\n        name,\n        email: detail?.user?.email ?? selectedClient.email,\n        phone: detail?.user?.phone ?? selectedClient.phone ?? '',\n        status: detail?.status ?? selectedClient.status,\n        currency: detail?.currency ?? 'usd',\n        address: undefined,  // Now uses Address object like intake form!\n      });\n      setIsEditClientOpen(true);\n    } catch (error) {\n      console.error('[Clients] Failed to load client detail', error);\n      setEditClientError('Failed to load client');\n      setIsEditClientOpen(true);\n    }\n  }, [currentPractice?.id, selectedClient]);\n\n  const handleSubmitEditClient = useCallback(async () => {\n    if (!currentPractice?.id || !editClientForm.id) return;\n    const name = editClientForm.name.trim();\n    const email = editClientForm.email.trim();\n    if (!name || !email) {\n      setEditClientError('Name and email are required');\n      return;\n    }\n    if (editClientSubmitting) return;\n    setEditClientSubmitting(true);\n    setEditClientError(null);\n    try {\n      await updateUserDetail(currentPractice.id, editClientForm.id, {\n        name,\n        email,\n        phone: editClientForm.phone.trim() || undefined,\n        status: editClientForm.status,\n        currency: editClientForm.currency.trim() || 'usd',\n        event_name: 'Invite Client',\n        address: editClientForm.address\n      });\n      await fetchClientsPage(1, { replace: true });\n      showSuccess('Client updated', 'Client details have been saved.');\n      resetEditClientForm();\n      setIsEditClientOpen(false);\n    } catch (error) {\n      console.error('[Clients] Failed to update client', error);\n      setEditClientError('Failed to update client');\n      showError('Could not update client', 'Please try again.');\n    } finally {\n      setEditClientSubmitting(false);\n    }\n  }, [currentPractice?.id, editClientForm, editClientSubmitting, fetchClientsPage, resetEditClientForm, showError, showSuccess]);\n\n  const handleDeleteClient = useCallback(async () => {\n    if (!currentPractice?.id || !selectedClient) return;\n    const confirmed = window.confirm('Delete this client?');\n    if (!confirmed) return;\n    try {\n      await deleteUserDetail(currentPractice.id, selectedClient.id);\n      await fetchClientsPage(1, { replace: true });\n      showSuccess('Client deleted', 'The client has been removed.');\n      setIsDrawerOpen(false);\n    } catch (error) {\n      console.error('[Clients] Failed to delete client', error);\n      showError('Could not delete client', 'Please try again.');\n    }\n  }, [currentPractice?.id, fetchClientsPage, selectedClient, showError, showSuccess]);\n\n  const handleSubmitAddClient = useCallback(async () => {\n    if (!currentPractice?.id) return;\n    const name = addClientForm.name.trim();\n    const email = addClientForm.email.trim();\n    if (!name || !email) {\n      setAddClientError('Name and email are required');\n      return;\n    }\n    if (addClientSubmitting) return;\n    setAddClientSubmitting(true);\n    setAddClientError(null);\n    try {\n      await createUserDetail(currentPractice.id, {\n        name,\n        email,\n        phone: addClientForm.phone.trim() || undefined,\n        status: addClientForm.status,\n        currency: addClientForm.currency.trim() || 'usd',\n        address: addClientForm.address,\n        event_name: 'Invite Client'\n      });\n      await fetchClientsPage(1, { replace: true });\n      showSuccess('Client added', 'The client has been added to your practice.');\n      resetAddClientForm();\n      setIsAddClientOpen(false);\n    } catch (error) {\n      console.error('[Clients] Failed to create client', error);\n      setAddClientError('Failed to create client');\n      showError('Could not add client', 'Please try again.');\n    } finally {\n      setAddClientSubmitting(false);\n    }\n  }, [\n    addClientForm,\n    addClientSubmitting,\n    currentPractice?.id,\n    fetchClientsPage,\n    resetAddClientForm,\n    showError,\n    showSuccess\n  ]);\n\n  const updateCurrentLetter = useCallback(() => {\n    const container = listRef.current;\n    if (!container) return;\n    const sections = Array.from(container.querySelectorAll<HTMLElement>('[data-letter]'));\n    if (sections.length === 0) return;\n    const scrollPosition = container.scrollTop + 4;\n    let nextLetter = sections[0].dataset.letter ?? '';\n    for (const section of sections) {\n      if (section.offsetTop <= scrollPosition) {\n        nextLetter = section.dataset.letter ?? nextLetter;\n      } else {\n        break;\n      }\n    }\n    setCurrentLetter((prev) => (prev === nextLetter ? prev : nextLetter));\n  }, []);\n\n  useEffect(() => {\n    const container = listRef.current;\n    if (!container) return;\n    let rafId: number | null = null;\n    const handleScroll = () => {\n      if (rafId !== null) return;\n      rafId = window.requestAnimationFrame(() => {\n        rafId = null;\n        updateCurrentLetter();\n      });\n    };\n    container.addEventListener('scroll', handleScroll);\n    updateCurrentLetter();\n    return () => {\n      container.removeEventListener('scroll', handleScroll);\n      if (rafId !== null) {\n        window.cancelAnimationFrame(rafId);\n      }\n    };\n  }, [updateCurrentLetter]);\n\n  const scrollToLetter = useCallback((letter: string) => {\n    const container = listRef.current;\n    if (!container) return;\n    const target = container.querySelector<HTMLElement>(`[data-letter=\"${letter}\"]`);\n    if (target) {\n      container.scrollTo({ top: target.offsetTop, behavior: 'smooth' });\n    }\n  }, []);\n\n  const loadMoreClients = useCallback(async () => {\n    if (!clientsHasMore || clientsLoading || clientsLoadingMore) {\n      return;\n    }\n    const nextPage = clientsPage + 1;\n    setClientsLoadingMore(true);\n    await fetchClientsPage(nextPage);\n  }, [clientsHasMore, clientsLoading, clientsLoadingMore, clientsPage, fetchClientsPage]);\n\n  useEffect(() => {\n    const target = loadMoreRef.current;\n    const root = listRef.current;\n    if (!target || !root) return;\n    if (!clientsHasMore || clientsLoading || clientsLoadingMore) return;\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        const entry = entries[0];\n        if (entry?.isIntersecting) {\n          void loadMoreClients();\n        }\n      },\n      { root, rootMargin: '200px' }\n    );\n\n    observer.observe(target);\n    return () => observer.disconnect();\n  }, [clientsHasMore, clientsLoading, clientsLoadingMore, loadMoreClients]);\n\n  const addClientModal = (\n    <Modal\n      isOpen={isAddClientOpen}\n      onClose={handleCloseAddClient}\n      title=\"Add Client\"\n      type=\"modal\"\n    >\n      <div className=\"space-y-4\">\n        {addClientError && (\n          <div className=\"glass-panel p-3 border-red-500/20 text-sm text-red-200\">\n            {addClientError}\n          </div>\n        )}\n        <ClientForm\n          values={addClientForm}\n          onChange={updateAddClientField}\n          disabled={addClientSubmitting}\n        />\n        <FormActions\n          className=\"justify-end gap-2\"\n          onCancel={handleCloseAddClient}\n          onSubmit={handleSubmitAddClient}\n          submitType=\"button\"\n          submitText={addClientSubmitting ? 'Saving...' : 'Add Client'}\n          disabled={addClientSubmitting}\n        />\n      </div>\n    </Modal>\n  );\n\n  const editClientModal = (\n    <Modal\n      isOpen={isEditClientOpen}\n      onClose={handleCloseEditClient}\n      title=\"Edit Client\"\n      type=\"modal\"\n    >\n      <div className=\"space-y-4\">\n        {editClientError && (\n          <div className=\"glass-panel p-3 border-red-500/20 text-sm text-red-200\">\n            {editClientError}\n          </div>\n        )}\n        <ClientForm\n          values={editClientForm}\n          onChange={updateEditClientField}\n          disabled={editClientSubmitting}\n        />\n        <FormActions\n          className=\"justify-end gap-2\"\n          onCancel={handleCloseEditClient}\n          onSubmit={handleSubmitEditClient}\n          submitType=\"button\"\n          submitText={editClientSubmitting ? 'Saving...' : 'Save Changes'}\n          disabled={editClientSubmitting}\n        />\n      </div>\n    </Modal>\n  );\n\n  if (clientsLoading) {\n    return (\n      <>\n        <Page className=\"h-full\">\n          <div className=\"max-w-6xl mx-auto h-full\">\n            <PageHeader\n              title=\"Clients\"\n              subtitle=\"A unified list of client relationships tied to conversations and matters.\"\n            />\n            <Panel className=\"mt-6 min-h-[520px] flex items-center justify-center\">\n              <p className=\"text-sm text-input-placeholder\">Loading clients...</p>\n            </Panel>\n          </div>\n        </Page>\n        {addClientModal}\n        {editClientModal}\n      </>\n    );\n  }\n\n  if (clientsError) {\n    return (\n      <>\n        <Page className=\"h-full\">\n          <div className=\"max-w-6xl mx-auto h-full\">\n            <PageHeader\n              title=\"Clients\"\n              subtitle=\"A unified list of client relationships tied to conversations and matters.\"\n            />\n            <Panel className=\"mt-6 min-h-[520px] flex items-center justify-center\">\n              <p className=\"text-sm text-input-placeholder\">{clientsError}</p>\n            </Panel>\n          </div>\n        </Page>\n        {addClientModal}\n        {editClientModal}\n      </>\n    );\n  }\n\n  if (sortedClients.length === 0) {\n    return (\n      <>\n        <Page className=\"h-full\">\n          <div className=\"max-w-6xl mx-auto h-full\">\n            <PageHeader\n              title=\"Clients\"\n              subtitle=\"A unified list of client relationships tied to conversations and matters.\"\n              actions={(\n                <div className=\"flex items-center gap-2\">\n                  <Button size=\"sm\" icon={<PlusIcon className=\"h-4 w-4\" />} onClick={handleOpenAddClient}>\n                    Add Client\n                  </Button>\n                  <Button size=\"sm\" variant=\"secondary\" icon={<ArrowUpTrayIcon className=\"h-4 w-4\" />} disabled>\n                    Import\n                  </Button>\n                </div>\n              )}\n            />\n            <Panel className=\"mt-6 min-h-[520px]\">\n              <EmptyState onAddClient={handleOpenAddClient} />\n            </Panel>\n          </div>\n        </Page>\n        {addClientModal}\n        {editClientModal}\n      </>\n    );\n  }\n\n  return (\n    <>\n      <Page className=\"h-full\">\n        <div className=\"max-w-6xl mx-auto flex h-full min-h-0 flex-col gap-6\">\n          <PageHeader\n            title=\"Clients\"\n            subtitle=\"A unified list of client relationships tied to conversations and matters.\"\n            actions={(\n              <div className=\"flex items-center gap-2\">\n                <Button size=\"sm\" icon={<PlusIcon className=\"h-4 w-4\" />} onClick={handleOpenAddClient}>\n                  Add Client\n                </Button>\n                <Button size=\"sm\" variant=\"secondary\" icon={<ArrowUpTrayIcon className=\"h-4 w-4\" />}>\n                  Import\n                </Button>\n              </div>\n            )}\n          />\n          <div className=\"flex-1 min-h-0 overflow-hidden bg-transparent\">\n            <SplitView\n              className=\"h-full min-h-[560px]\"\n              primary={(\n                <div className=\"relative h-full\">\n                  <div\n                    ref={listRef}\n                    className=\"h-full overflow-y-auto\"\n                  >\n                    <ul>\n                      {letters.map((letter) => (\n                        <Fragment key={letter}>\n                          <li\n                            data-letter={letter}\n                            className=\"sticky top-0 z-10 bg-transparent px-4 py-2 text-xs font-semibold text-input-placeholder\"\n                          >\n                            {letter}\n                          </li>\n                          <li aria-hidden=\"true\" className=\"border-b border-line-glass/20\" />\n                          {groupedClients[letter].map((client, index) => {\n                            const isActive = client.id === selectedClient?.id;\n                            const nameParts = splitName(client.name);\n                            const isLastInLetterGroup = index === groupedClients[letter].length - 1;\n                            return (\n                              <li key={client.id}>\n                                <Button\n                                  variant=\"ghost\"\n                                  onClick={() => handleSelectClient(client.id)}\n                                  aria-current={isActive ? 'true' : undefined}\n                                  className={cn(\n                                    'w-full justify-start px-4 py-3.5 h-auto rounded-none transition-colors duration-150',\n                                    isActive\n                                      ? 'bg-white/5'\n                                      : 'hover:bg-white/[0.03]'\n                                  )}\n                                >\n                                  <div className=\"flex items-center gap-4 w-full\">\n                                    <Avatar\n                                      name={client.name}\n                                      size=\"sm\"\n                                      className=\"text-input-text\"\n                                    />\n                                    <div className=\"min-w-0 flex-1 text-left\">\n                                      <p className=\"text-sm text-input-text truncate\">\n                                        {nameParts.first ? (\n                                          <>\n                                            <span>{nameParts.first} </span>\n                                            <span className=\"font-semibold\">{nameParts.last}</span>\n                                          </>\n                                        ) : (\n                                          <span className=\"font-semibold\">{nameParts.last}</span>\n                                        )}\n                                      </p>\n                                    </div>\n                                  </div>\n                                </Button>\n                                {!isLastInLetterGroup && (\n                                  <div aria-hidden=\"true\" className=\"border-b border-line-glass/20\" />\n                                )}\n                              </li>\n                            );\n                          })}\n                        </Fragment>\n                      ))}\n                      <li\n                        ref={loadMoreRef}\n                        className=\"px-4 py-3 text-xs text-input-placeholder text-center\"\n                      >\n                        {clientsLoadingMore\n                          ? 'Loading more clients...'\n                          : clientsHasMore\n                            ? 'Scroll to load more'\n                            : 'No more clients'}\n                      </li>\n                    </ul>\n                  </div>\n                  <div className=\"absolute right-1 top-1/2 z-20 -translate-y-1/2 hidden md:flex flex-col items-center gap-1 text-[11px] font-medium text-input-placeholder\">\n                    {letters.map((letter) => (\n                      <Button\n                        key={letter}\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={() => scrollToLetter(letter)}\n                        className={cn(\n                          'relative h-4 w-4 min-h-0 min-w-0 p-0 text-[11px] flex items-center justify-center rounded-full transition-colors',\n                          // Increase interactive hit area to at least 44x44\n                          \"before:absolute before:-inset-3.5 before:content-['']\",\n                          currentLetter === letter\n                            ? 'text-accent-500 font-bold bg-accent-500/10'\n                            : 'text-input-placeholder hover:text-input-text hover:bg-white/10'\n                        )}\n                      >\n                        {letter}\n                      </Button>\n                    ))}\n                  </div>\n                </div>\n              )}\n              secondary={selectedClient ? (\n                <ClientDetailPanel\n                  client={selectedClient}\n                  activity={selectedClientActivity}\n                  practiceId={currentPractice?.id}\n                  onAddMemo={handleMemoSubmit}\n                  memoSubmitting={memoSubmitting}\n                  onEditMemo={handleMemoEdit}\n                  onDeleteMemo={handleMemoDelete}\n                  memoActionId={memoActionId}\n                  onEditClient={handleOpenEditClient}\n                  onDeleteClient={handleDeleteClient}\n                />\n              ) : (\n                <div className=\"h-full flex items-center justify-center\">\n                  <div className=\"text-center\">\n                    <div className=\"mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-light-hover dark:bg-dark-hover\">\n                      <UserIcon className=\"h-6 w-6 text-input-text/70\" aria-hidden=\"true\" />\n                    </div>\n                    <h3 className=\"mt-4 text-sm font-semibold text-input-text\">Select a client</h3>\n                    <p className=\"mt-2 text-sm text-input-placeholder\">\n                      Choose a client from the list to view their details.\n                    </p>\n                  </div>\n                </div>\n              )}\n              secondaryClassName=\"hidden md:block\"\n            />\n          </div>\n        </div>\n\n        {selectedClient && (\n          <Modal\n            isOpen={isMobile && isDrawerOpen}\n            onClose={() => setIsDrawerOpen(false)}\n            type=\"drawer\"\n            title=\"Client Details\"\n          >\n            <ClientDetailPanel\n              client={selectedClient}\n              activity={selectedClientActivity}\n              practiceId={currentPractice?.id}\n              onAddMemo={handleMemoSubmit}\n              memoSubmitting={memoSubmitting}\n              onEditMemo={handleMemoEdit}\n              onDeleteMemo={handleMemoDelete}\n              memoActionId={memoActionId}\n              onEditClient={handleOpenEditClient}\n              onDeleteClient={handleDeleteClient}\n              paddingClassName=\"px-0 py-0\"\n            />\n          </Modal>\n        )}\n      </Page>\n      {addClientModal}\n      {editClientModal}\n    </>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/intake/api/intakesApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/intake/components/ContactForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/intake/components/DocumentChecklist.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/intake/components/IntakePaymentCard.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":19,"suggestions":[{"fix":{"range":[2850,2917],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":104,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":104,"endColumn":23,"suggestions":[{"fix":{"range":[3894,3974],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":107,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":107,"endColumn":23,"suggestions":[{"fix":{"range":[4020,4112],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":124,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":124,"endColumn":29,"suggestions":[{"fix":{"range":[4904,4977],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":153,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":153,"endColumn":21,"suggestions":[{"fix":{"range":[5888,5959],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":156,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":156,"endColumn":21,"suggestions":[{"fix":{"range":[6071,6138],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport { useMemo, useState, useEffect } from 'preact/hooks';\nimport { Button } from '@/shared/ui/Button';\nimport { formatCurrency } from '@/shared/utils/currencyFormatter';\nimport { toMajorUnits, type MinorAmount } from '@/shared/utils/money';\nimport {\n  buildIntakePaymentUrl,\n  isValidStripePaymentLink,\n  isValidStripeCheckoutSessionUrl,\n  type IntakePaymentRequest\n} from '@/shared/utils/intakePayments';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\n\ninterface IntakePaymentCardProps {\n  paymentRequest: IntakePaymentRequest;\n  onOpenPayment?: (request: IntakePaymentRequest) => void;\n}\n\nconst resolveDisplayAmount = (amount?: MinorAmount, currency?: string, locale?: string) => {\n  if (typeof amount !== 'number' || !Number.isFinite(amount)) return null;\n  const normalizedCurrency = typeof currency === 'string' ? currency.toUpperCase() : 'USD';\n  const displayAmount = toMajorUnits(amount) ?? 0;\n  return formatCurrency(displayAmount, normalizedCurrency, locale || 'en');\n};\n\nexport const IntakePaymentCard: FunctionComponent<IntakePaymentCardProps> = ({ paymentRequest, onOpenPayment }) => {\n  const { navigate } = useNavigation();\n  const { showError, showInfo } = useToastContext();\n  const [isClient, setIsClient] = useState(false);\n  const [isPaying, setIsPaying] = useState(false);\n  const paymentUnavailableId = useMemo(\n    () => `payment-unavailable-${Math.random().toString(36).slice(2, 8)}`,\n    []\n  );\n\n  useEffect(() => {\n    setIsClient(true);\n  }, []);\n\n  const locale = typeof navigator !== 'undefined' ? navigator.language : 'en';\n  const formattedAmount = useMemo(\n    () => resolveDisplayAmount(paymentRequest.amount, paymentRequest.currency, locale),\n    [paymentRequest.amount, paymentRequest.currency, locale]\n  );\n  const hasClientSecret = typeof paymentRequest.clientSecret === 'string' &&\n    paymentRequest.clientSecret.trim().length > 0;\n  const hasCheckoutSession = typeof paymentRequest.checkoutSessionUrl === 'string' &&\n    paymentRequest.checkoutSessionUrl.trim().length > 0;\n\n  const paymentUrl = buildIntakePaymentUrl(paymentRequest);\n  const buttonLabel = formattedAmount ? `Pay ${formattedAmount}` : 'Pay consultation fee';\n\n  const openPaymentLink = () => {\n    if (!paymentRequest.paymentLinkUrl) return false;\n    if (!isValidStripePaymentLink(paymentRequest.paymentLinkUrl)) {\n      return false;\n    }\n    if (typeof window !== 'undefined') {\n      window.open(paymentRequest.paymentLinkUrl, '_blank', 'noopener');\n      return true;\n    }\n    return false;\n  };\n\n  const openPayment = async (request: IntakePaymentRequest) => {\n    if (!onOpenPayment) return false;\n    try {\n      await Promise.resolve(onOpenPayment(request));\n      return true;\n    } catch (error) {\n      console.warn('[IntakePayment] Failed to open payment flow', error);\n      return false;\n    }\n  };\n\n  const handlePay = async () => {\n    if (isPaying) {\n      return;\n    }\n    setIsPaying(true);\n    try {\n      if (hasClientSecret && onOpenPayment) {\n        const opened = await openPayment(paymentRequest);\n        if (!opened) {\n          showError('Payment unavailable', 'Payment is currently unavailable.');\n        }\n        return;\n      }\n      if (hasCheckoutSession && paymentRequest.checkoutSessionUrl) {\n        const isValid = isValidStripeCheckoutSessionUrl(paymentRequest.checkoutSessionUrl);\n        if (isValid) {\n          if (onOpenPayment) {\n            const opened = await openPayment(paymentRequest);\n            if (!opened) {\n              showError('Payment unavailable', 'Payment is currently unavailable.');\n            }\n            return;\n          }\n          if (typeof window !== 'undefined') {\n            window.location.assign(paymentRequest.checkoutSessionUrl);\n            return;\n          }\n          console.warn('[IntakePayment] Cannot open checkout session in SSR environment');\n          return;\n        } else {\n          console.warn('[IntakePayment] Invalid Stripe checkout session URL detected. Redacted url.');\n          \n          // Attempt fallback methods\n          let fallbackSucceeded = false;\n          if (!hasClientSecret && paymentRequest.paymentLinkUrl && openPaymentLink()) {\n            fallbackSucceeded = true;\n          } else if (onOpenPayment) {\n            const sanitizedRequest = { ...paymentRequest };\n            delete sanitizedRequest.checkoutSessionUrl;\n            fallbackSucceeded = await openPayment(sanitizedRequest);\n          } else {\n            // Try simple navigation to payment URL as last resort if it differs from checkout session\n            if (paymentUrl && paymentUrl !== paymentRequest.checkoutSessionUrl) {\n              try {\n                navigate(paymentUrl);\n                fallbackSucceeded = true;\n              } catch (error) {\n                console.warn('[IntakePayment] Failed to navigate to payment URL', error);\n              }\n            }\n          }\n\n          if (fallbackSucceeded) {\n            // Using showInfo instead of showError to avoid alarming the user during fallback flow\n            showInfo('Payment info', 'The checkout link was invalid; proceeding via an alternative method.');\n          } else {\n            showError('Payment unavailable', 'The payment link is invalid and no alternative methods are available.');\n          }\n          return;\n        }\n      }\n      if (!hasClientSecret && paymentRequest.paymentLinkUrl && openPaymentLink()) {\n        return;\n      }\n      if (onOpenPayment) {\n        const opened = await openPayment(paymentRequest);\n        if (!opened) {\n          showError('Payment unavailable', 'Payment is currently unavailable.');\n        }\n        return;\n      }\n      try {\n        if (paymentUrl) {\n          navigate(paymentUrl);\n          return;\n        }\n        console.warn('[IntakePayment] Payment URL unavailable for navigation');\n        showError('Payment unavailable', 'Payment is currently unavailable.');\n      } catch (error) {\n        console.warn('[IntakePayment] Catch-all navigation failed', error);\n        showError('Payment unavailable', 'Payment is currently unavailable.');\n      }\n    } finally {\n      setIsPaying(false);\n    }\n  };\n\n  return (\n    <div className=\"mt-4\">\n      <Button\n        variant=\"primary\"\n        onClick={handlePay}\n        className=\"w-full\"\n        disabled={!isClient || isPaying}\n        aria-busy={isPaying ? 'true' : undefined}\n        aria-disabled={!isClient ? 'true' : undefined}\n        aria-describedby={!isClient ? paymentUnavailableId : undefined}\n      >\n        {buttonLabel}\n      </Button>\n      {!isClient && (\n        <span id={paymentUnavailableId} className=\"sr-only\">\n          Payments are not available right now.\n        </span>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/intake/components/IntakePaymentForm.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":27,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":27,"endColumn":17,"suggestions":[{"fix":{"range":[1219,1284],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":92,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":92,"endColumn":21,"suggestions":[{"fix":{"range":[3354,3442],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":97,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":97,"endColumn":19,"suggestions":[{"fix":{"range":[3520,3586],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":141,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":141,"endColumn":21,"suggestions":[{"fix":{"range":[4687,4762],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":167,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":167,"endColumn":23,"suggestions":[{"fix":{"range":[5494,5559],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":221,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":221,"endColumn":20,"suggestions":[{"fix":{"range":[7090,7164],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":297,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":297,"endColumn":21,"suggestions":[{"fix":{"range":[9512,9673],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":342,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":342,"endColumn":21,"suggestions":[{"fix":{"range":[11206,11273],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FunctionComponent } from 'preact/compat';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'preact/compat';\nimport { PaymentElement, useElements, useStripe } from '@stripe/react-stripe-js';\nimport { formatCurrency } from '@/shared/utils/currencyFormatter';\nimport { Button } from '@/shared/ui/Button';\nimport { getConversationWsEndpoint, getIntakeConfirmEndpoint } from '@/config/api';\nimport { isPaidIntakeStatus } from '@/shared/utils/intakePayments';\nimport { toMajorUnits, type MinorAmount } from '@/shared/utils/money';\n\ninterface IntakePaymentFormProps {\n  amount?: MinorAmount;\n  currency?: string;\n  intakeUuid?: string;\n  practiceId?: string;\n  conversationId?: string;\n  onSuccess?: () => void | Promise<void>;\n}\n\nconst formatIntakeAmount = (amount?: number, currency?: string, locale?: string) => {\n  if (typeof amount !== 'number') return null;\n  const rawCurrency = typeof currency === 'string' ? currency.toUpperCase() : 'USD';\n  const normalizedCurrency = /^[A-Z]{3}$/.test(rawCurrency) ? rawCurrency : 'USD';\n  const resolvedLocale = locale || 'en';\n  try {\n    return formatCurrency(toMajorUnits(amount) ?? 0, normalizedCurrency, resolvedLocale);\n  } catch (error) {\n    console.warn('[IntakePayment] Failed to format currency', error);\n    try {\n      return formatCurrency(toMajorUnits(amount) ?? 0, 'USD', 'en');\n    } catch {\n      return null;\n    }\n  }\n};\n\nexport const IntakePaymentForm: FunctionComponent<IntakePaymentFormProps> = ({\n  amount,\n  currency,\n  intakeUuid,\n  practiceId,\n  conversationId,\n  onSuccess\n}) => {\n  const stripe = useStripe();\n  const elements = useElements();\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [errorMessage, setErrorMessage] = useState<string | null>(null);\n  const [status, setStatus] = useState<'idle' | 'processing' | 'succeeded' | 'failed'>('idle');\n  const [paymentSubmitted, setPaymentSubmitted] = useState(false);\n  const [callbackWarning, setCallbackWarning] = useState<string | null>(null);\n  const isMountedRef = useRef(true);\n  const paymentWaitControllerRef = useRef<AbortController | null>(null);\n\n  const TERMINAL_FAILURE_STATUSES = useMemo(\n    () => new Set(['failed', 'canceled', 'cancelled', 'expired']),\n    []\n  );\n\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false;\n      paymentWaitControllerRef.current?.abort();\n      paymentWaitControllerRef.current = null;\n    };\n  }, []);\n\n  const locale = typeof navigator !== 'undefined' ? navigator.language : 'en';\n  const formattedAmount = useMemo(\n    () => formatIntakeAmount(amount, currency, locale),\n    [amount, currency, locale]\n  );\n\n  const confirmIntakeLead = useCallback(async (): Promise<boolean> => {\n    if (!intakeUuid || !practiceId || !conversationId) {\n      return false;\n    }\n    try {\n      const response = await fetch(`${getIntakeConfirmEndpoint()}?practiceId=${encodeURIComponent(practiceId)}`, {\n        method: 'POST',\n        credentials: 'include',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          intakeUuid,\n          conversationId\n        })\n      });\n      if (!response.ok) {\n        const payload = await response.json().catch(() => null) as { error?: string } | null;\n        const detail = payload?.error ? ` (${payload.error})` : '';\n        console.warn(`[IntakePayment] Intake confirmation failed: ${response.status}${detail}`);\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.warn('[IntakePayment] Intake confirmation failed', error);\n      return false;\n    }\n  }, [conversationId, intakeUuid, practiceId]);\n\n  const waitForPaymentConfirmation = useCallback(async (timeoutMs = 20000, signal?: AbortSignal): Promise<string | null> => {\n    if (!conversationId || !intakeUuid) {\n      return null;\n    }\n\n    const wsUrl = getConversationWsEndpoint(conversationId);\n\n    if (signal?.aborted) {\n      return null;\n    }\n\n    return await new Promise<string | null>((resolve) => {\n      const ws = new WebSocket(wsUrl);\n      let settled = false;\n      let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n      const onAbort = () => {\n        cleanup();\n        resolve(null);\n      };\n\n      const cleanup = () => {\n        if (settled) return;\n        settled = true;\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        signal?.removeEventListener('abort', onAbort);\n        try {\n          ws.close();\n        } catch {\n          // ignore\n        }\n      };\n\n      signal?.addEventListener('abort', onAbort, { once: true });\n\n      timeoutId = setTimeout(() => {\n        console.warn('[IntakePayment] Timed out waiting for payment confirmation');\n        cleanup();\n        resolve(null);\n      }, timeoutMs);\n\n      ws.addEventListener('open', () => {\n        ws.send(JSON.stringify({\n          type: 'auth',\n          data: {\n            protocol_version: 1,\n            client_info: { platform: 'web' }\n          }\n        }));\n      });\n\n      ws.addEventListener('message', (event) => {\n        if (settled) return;\n        if (typeof event.data !== 'string') return;\n        let frame: { type?: string; data?: Record<string, unknown> };\n        try {\n          frame = JSON.parse(event.data) as { type?: string; data?: Record<string, unknown> };\n        } catch {\n          return;\n        }\n\n        if (frame.type === 'auth.error' || frame.type === 'error') {\n          console.warn('[IntakePayment] WebSocket auth error', frame.data);\n          cleanup();\n          resolve(null);\n          return;\n        }\n\n        if (frame.type !== 'message.new' || !frame.data) {\n          return;\n        }\n\n        const metadata = typeof frame.data.metadata === 'object' && frame.data.metadata !== null\n          ? frame.data.metadata as Record<string, unknown>\n          : null;\n        const messageIntakeUuid = typeof metadata?.intakeUuid === 'string'\n          ? metadata.intakeUuid\n          : typeof metadata?.intakePaymentUuid === 'string'\n            ? metadata.intakePaymentUuid\n            : null;\n        if (!messageIntakeUuid || messageIntakeUuid !== intakeUuid) {\n          return;\n        }\n        const paymentStatus = typeof metadata?.paymentStatus === 'string'\n          ? metadata.paymentStatus\n          : typeof metadata?.payment_status === 'string'\n            ? metadata.payment_status\n            : null;\n        if (!paymentStatus || !isPaidIntakeStatus(paymentStatus)) {\n          return;\n        }\n        cleanup();\n        resolve(paymentStatus);\n      });\n\n      ws.addEventListener('error', () => {\n        if (settled) return;\n        cleanup();\n        resolve(null);\n      });\n\n      ws.addEventListener('close', () => {\n        if (settled) return;\n        cleanup();\n        resolve(null);\n      });\n    });\n  }, [conversationId, intakeUuid]);\n\n  const handlePostPaymentSuccess = useCallback(async () => {\n    setCallbackWarning(null);\n    if (!onSuccess) return;\n\n    try {\n      await onSuccess();\n    } catch (callbackError) {\n      console.error('[IntakePayment] onSuccess callback failed', callbackError);\n      if (isMountedRef.current) {\n        setCallbackWarning(\n          'Payment succeeded but we could not finish the follow-up steps. Please refresh or check back shortly.'\n        );\n      }\n    }\n  }, [onSuccess]);\n\n  const handleSubmit = useCallback(async (event: SubmitEvent) => {\n    event.preventDefault();\n    setErrorMessage(null);\n    let paymentSucceeded = false;\n\n    if (!stripe || !elements) {\n      setErrorMessage('Payment form is still loading. Please wait a moment.');\n      return;\n    }\n\n    setIsSubmitting(true);\n    setStatus('processing');\n\n    try {\n      const returnUrl = typeof window !== 'undefined'\n        ? window.location.href\n        : undefined;\n\n      const result = await stripe.confirmPayment({\n        elements,\n        confirmParams: returnUrl ? { return_url: returnUrl } : undefined,\n        redirect: 'if_required'\n      });\n\n      if (result.error) {\n        setErrorMessage(result.error.message || 'Payment failed. Please try again.');\n        setStatus('idle');\n        return;\n      }\n\n      if (result.paymentIntent) {\n        setPaymentSubmitted(true);\n        setStatus('processing');\n      }\n\n      const paymentIntentStatus = result.paymentIntent?.status ?? null;\n\n      if (paymentIntentStatus === 'requires_action') {\n        setPaymentSubmitted(false);\n        setStatus('failed');\n        setErrorMessage('Payment requires additional authentication. Please complete the verification and try again.');\n        return;\n      }\n\n      if (paymentIntentStatus === 'requires_payment_method') {\n        setPaymentSubmitted(false);\n        setStatus('failed');\n        setErrorMessage('Payment failed. Please try another payment method.');\n        return;\n      }\n\n      if (paymentIntentStatus && TERMINAL_FAILURE_STATUSES.has(paymentIntentStatus)) {\n        setPaymentSubmitted(false);\n        setStatus('failed');\n        setErrorMessage(`Payment ${paymentIntentStatus}. Please try again or contact support.`);\n        return;\n      }\n\n      if (paymentIntentStatus === 'succeeded' || paymentIntentStatus === 'processing') {\n        const confirmed = await confirmIntakeLead();\n        if (!isMountedRef.current) return;\n        if (confirmed) {\n          setStatus('succeeded');\n          paymentSucceeded = true;\n          await handlePostPaymentSuccess();\n          return;\n        }\n        console.warn('[IntakePayment] Intake confirmation did not succeed after payment intent result', {\n          intakeUuid,\n          paymentIntentStatus\n        });\n      }\n\n      const waitController = new AbortController();\n      paymentWaitControllerRef.current?.abort();\n      paymentWaitControllerRef.current = waitController;\n      const wsStatus = await waitForPaymentConfirmation(20000, waitController.signal);\n      if (paymentWaitControllerRef.current === waitController) {\n        paymentWaitControllerRef.current = null;\n      }\n      if (!isMountedRef.current) return;\n        if (wsStatus && isPaidIntakeStatus(wsStatus)) {\n          const confirmed = await confirmIntakeLead();\n          if (!isMountedRef.current) return;\n          if (!confirmed) {\n          const retryConfirmed = await confirmIntakeLead();\n          if (!isMountedRef.current) return;\n          if (!retryConfirmed) {\n            setPaymentSubmitted(false);\n            setStatus('failed');\n            setErrorMessage(\n              'Payment was received, but we could not confirm your intake. Please refresh or contact support.'\n            );\n            return;\n          }\n        }\n        setStatus('succeeded');\n        paymentSucceeded = true;\n        await handlePostPaymentSuccess();\n        return;\n      }\n\n      setPaymentSubmitted(false);\n      setStatus('idle');\n      setErrorMessage(\n        'Payment is still processing. Return to the chat and check status again in a moment.'\n      );\n    } catch (error) {\n      if (!paymentSucceeded) {\n        setErrorMessage(error instanceof Error ? error.message : 'Payment failed. Please try again.');\n        setStatus('idle');\n      } else {\n        console.warn('[IntakePayment] Error after payment success', error);\n        if (isMountedRef.current) {\n          setCallbackWarning(\n            'Payment succeeded but we could not finish the follow-up steps. Please refresh or check back shortly.'\n          );\n        }\n      }\n    } finally {\n      setIsSubmitting(false);\n    }\n  }, [\n    stripe,\n    elements,\n    intakeUuid,\n    confirmIntakeLead,\n    handlePostPaymentSuccess,\n    TERMINAL_FAILURE_STATUSES,\n    waitForPaymentConfirmation\n  ]);\n\n  return (\n    <form onSubmit={handleSubmit} className=\"space-y-5\">\n      {(!stripe || !elements) && (\n        <div className=\"rounded-xl border border-line-glass/30 bg-white/5 px-4 py-3 text-sm text-input-placeholder backdrop-blur-md\">\n          Loading secure payment form\n        </div>\n      )}\n      <div className=\"glass-panel p-5\">\n        <PaymentElement options={{ layout: 'tabs' }} />\n      </div>\n\n      {errorMessage && (\n        <div className=\"rounded-xl border border-red-500/30 bg-red-500/10 px-4 py-3 text-sm text-red-100 backdrop-blur-xl\">\n          {errorMessage}\n        </div>\n      )}\n\n      {callbackWarning && (\n        <div className=\"rounded-xl border border-amber-500/30 bg-amber-500/10 px-4 py-3 text-sm text-amber-100 backdrop-blur-xl\">\n          {callbackWarning}\n        </div>\n      )}\n\n      {status === 'succeeded' && (\n        <div className=\"glass-card p-6 text-center border-emerald-500/30\">\n          <div className=\"flex justify-center mb-4\">\n            <div className=\"rounded-full bg-emerald-500/20 p-3 shadow-lg shadow-emerald-500/20\">\n              <svg className=\"h-8 w-8 text-emerald-400\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n              </svg>\n            </div>\n          </div>\n          <h3 className=\"text-lg font-semibold text-input-text mb-1\">\n            Payment successful\n          </h3>\n          <p className=\"text-input-placeholder\">\n            {formattedAmount ? `Thank you for your payment of ${formattedAmount}.` : 'Thank you for your payment.'}\n          </p>\n          <div className=\"mt-4 pt-4 border-t border-line-glass/30 text-xs text-emerald-400\">\n            Payment processed successfully. You will receive confirmation if an email is on file.\n          </div>\n        </div>\n      )}\n\n      {status !== 'succeeded' && (\n        <Button\n          variant=\"primary\"\n          type=\"submit\"\n          disabled={isSubmitting || paymentSubmitted || !stripe || !elements}\n          className=\"w-full\"\n        >\n          {isSubmitting ? 'Processing payment' : (formattedAmount ? `Pay ${formattedAmount}` : 'Pay now')}\n        </Button>\n      )}\n    </form>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/intake/components/IntakePaymentModal.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":66,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":66,"endColumn":27,"suggestions":[{"fix":{"range":[2558,2628],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":82,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":82,"endColumn":23,"suggestions":[{"fix":{"range":[3054,3132],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport { useMemo, useEffect, useState, useRef } from 'preact/hooks';\nimport Modal from '@/shared/components/Modal';\nimport { Elements } from '@stripe/react-stripe-js';\nimport { loadStripe, type StripeElementsOptionsClientSecret } from '@stripe/stripe-js';\nimport type { IntakePaymentRequest } from '@/shared/utils/intakePayments';\nimport {\n  isValidStripePaymentLink,\n  isValidStripeCheckoutSessionUrl,\n  fetchIntakePaymentStatus,\n  isPaidIntakeStatus\n} from '@/shared/utils/intakePayments';\nimport { IntakePaymentForm } from '@/features/intake/components/IntakePaymentForm';\nimport { Button } from '@/shared/ui/Button';\n\nconst STRIPE_PUBLIC_KEY = import.meta.env.VITE_STRIPE_KEY ?? '';\nconst stripePromise = STRIPE_PUBLIC_KEY ? loadStripe(STRIPE_PUBLIC_KEY) : null;\n\ninterface IntakePaymentModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  paymentRequest: IntakePaymentRequest | null;\n  onSuccess?: () => void | Promise<void>;\n}\n\nexport const IntakePaymentModal: FunctionComponent<IntakePaymentModalProps> = ({\n  isOpen,\n  onClose,\n  paymentRequest,\n  onSuccess\n}) => {\n  const [isVerifying, setIsVerifying] = useState(false);\n  const clientSecret = paymentRequest?.clientSecret;\n  const paymentLinkUrl = paymentRequest?.paymentLinkUrl;\n  const checkoutSessionUrl = paymentRequest?.checkoutSessionUrl;\n  const isValidPaymentLink = paymentLinkUrl ? isValidStripePaymentLink(paymentLinkUrl) : false;\n  const isValidCheckoutSession = checkoutSessionUrl ? isValidStripeCheckoutSessionUrl(checkoutSessionUrl) : false;\n\n  const isVerifyingRef = useRef(false);\n  const latestOnSuccessRef = useRef(onSuccess);\n  const latestOnCloseRef = useRef(onClose);\n\n  useEffect(() => {\n    latestOnSuccessRef.current = onSuccess;\n    latestOnCloseRef.current = onClose;\n  }, [onSuccess, onClose]);\n\n  useEffect(() => {\n    if (!isOpen || !paymentRequest?.intakeUuid) return;\n\n    let cancelled = false;\n    const handleFocus = async () => {\n      if (isVerifyingRef.current || cancelled) return;\n      isVerifyingRef.current = true;\n      setIsVerifying(true);\n      try {\n        const status = await fetchIntakePaymentStatus(paymentRequest.intakeUuid);\n        if (cancelled) return;\n        if (isPaidIntakeStatus(status)) {\n          const requestToken = paymentRequest?.intakeUuid ?? null;\n          const onCloseToken = latestOnCloseRef.current;\n          if (latestOnSuccessRef.current) {\n            try {\n              await Promise.resolve(latestOnSuccessRef.current());\n            } catch (error) {\n              console.warn('[IntakePaymentModal] onSuccess callback failed', error);\n            }\n          }\n          if (\n            cancelled\n            || requestToken !== (paymentRequest?.intakeUuid ?? null)\n            || !isPaidIntakeStatus(status)\n            || onCloseToken !== latestOnCloseRef.current\n            || !latestOnCloseRef.current\n          ) {\n            return;\n          }\n          latestOnCloseRef.current();\n        }\n      } catch (err) {\n        if (!cancelled) {\n          console.warn('[IntakePaymentModal] Focus-triggered status check failed', err);\n        }\n      } finally {\n        if (!cancelled) {\n          isVerifyingRef.current = false;\n          setIsVerifying(false);\n        }\n      }\n    };\n\n    window.addEventListener('focus', handleFocus);\n    return () => {\n      cancelled = true;\n      window.removeEventListener('focus', handleFocus);\n      isVerifyingRef.current = false;\n    };\n  }, [isOpen, paymentRequest?.intakeUuid]);\n\n  useEffect(() => {\n    if (!isOpen) {\n      setIsVerifying(false);\n    }\n  }, [isOpen]);\n\n  const elementsOptions = useMemo<StripeElementsOptionsClientSecret | null>(() => {\n    if (!clientSecret) return null;\n    return {\n      clientSecret,\n      appearance: {\n        theme: 'stripe',\n        variables: {\n          colorPrimary: '#2563eb',\n          colorText: '#0f172a',\n          colorBackground: '#ffffff',\n          colorDanger: '#dc2626',\n          fontFamily: 'ui-sans-serif, system-ui',\n          borderRadius: '12px'\n        }\n      }\n    };\n  }, [clientSecret]);\n\n  if (!paymentRequest && !isOpen) {\n    return null;\n  }\n\n  const canUseElements = Boolean(clientSecret && elementsOptions && STRIPE_PUBLIC_KEY && stripePromise && paymentRequest);\n\n  return (\n    <Modal\n      isOpen={isOpen}\n      onClose={onClose}\n      title=\"Complete Payment\"\n      type=\"drawer\"\n    >\n      {canUseElements && paymentRequest ? (\n        <Elements stripe={stripePromise} options={elementsOptions}>\n          <IntakePaymentForm\n            amount={paymentRequest.amount}\n            currency={paymentRequest.currency}\n            intakeUuid={paymentRequest.intakeUuid}\n            practiceId={paymentRequest.practiceId}\n            conversationId={paymentRequest.conversationId}\n            onSuccess={onSuccess}\n          />\n        </Elements>\n      ) : isValidCheckoutSession ? (\n        <div className=\"glass-panel p-6 shadow-xl\">\n          <p className=\"mb-4 text-sm text-input-placeholder\">\n            One more step: click below to complete your payment on Stripe&apos;s secure checkout page.\n          </p>\n          <Button\n            variant=\"primary\"\n            className=\"w-full\"\n            disabled={isVerifying}\n            onClick={() => {\n              if (isVerifying) return;\n              if (typeof window !== 'undefined' && checkoutSessionUrl) {\n                window.open(checkoutSessionUrl, '_blank', 'noopener');\n              }\n            }}\n          >\n            {isVerifying ? 'Verifying...' : 'Complete payment'}\n          </Button>\n        </div>\n      ) : isValidPaymentLink ? (\n        <div className=\"glass-panel p-6 shadow-xl\">\n          <Button\n            variant=\"primary\"\n            className=\"w-full\"\n            onClick={() => {\n              if (typeof window !== 'undefined') {\n                window.open(paymentLinkUrl, '_blank', 'noopener');\n              }\n            }}\n          >\n            Open secure payment\n          </Button>\n        </div>\n      ) : !STRIPE_PUBLIC_KEY || !stripePromise ? (\n        <div className=\"glass-panel p-6 border-red-500/20\">\n          <p className=\"text-sm text-red-200\">\n            Payments are unavailable right now. Please try again later.\n          </p>\n        </div>\n      ) : (\n        <div className=\"glass-panel p-6 border-amber-500/20\">\n          <p className=\"text-sm text-amber-200\">\n            Missing payment details. Please return to the intake chat and try again.\n          </p>\n        </div>\n      )}\n    </Modal>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/intake/components/PrivacySupportSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/ActivityTimeline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/MatterCanvas.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/MatterCreateModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/MatterDetailHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/MatterListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/MatterStatusDot.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/MatterStatusPill.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/MatterSummaryCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/MatterTab.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":101,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":101,"endColumn":22,"suggestions":[{"fix":{"range":[3472,3524],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport { useRef } from 'preact/hooks';\nimport { Button } from '@/shared/ui/Button';\nimport { analyzeMissingInfo } from '@/shared/utils/matterAnalysis';\nimport {\n  DocumentIcon,\n  CheckCircleIcon,\n  ExclamationTriangleIcon\n} from \"@heroicons/react/24/outline\";\nimport { MatterData, MatterStatus } from '@/shared/types/matter';\nimport { getDefaultDocumentSuggestions } from '@/shared/hooks/useMatterState';\nimport type { DocumentIconAttachment } from '../../../../worker/types';\nimport { MatterStatusBadge } from './StatusBadge';\nimport type { MatterWorkflowStatus } from '@/shared/hooks/usePracticeManagement';\n\ninterface MatterTabProps {\n  matter: MatterData | null;\n  status: MatterStatus;\n  onStartChat?: () => void;\n  onViewInChat?: () => void;\n  onPayNow?: () => void;\n  onViewPDF?: () => void;\n  onShareMatter?: () => void;\n  onUploadDocument?: (files: File[], metadata?: { documentType?: string; matterId?: string }) => Promise<DocumentIconAttachment[]>;\n}\n\n/**\n * Maps document IDs from getDefaultDocumentSuggestions to semantic documentType values\n * expected by DocumentRequirementService\n */\nfunction mapDocumentIdToType(documentId: string | null): string | undefined {\n  if (!documentId) {\n    return undefined; // Let backend infer the type\n  }\n\n  const mapping: Record<string, string> = {\n    // Family law documents\n    'marriage-cert': 'marriage_certificate',\n    'financial-records': 'financial_statements',\n    'child-info': 'birth_certificates',\n    \n    // Employment law documents\n    'employment-contract': 'employment_contract',\n    'pay-stubs': 'pay_stubs',\n    'termination-docs': 'termination_documents',\n    \n    // Tenant/landlord documents\n    'lease-agreement': 'lease_agreement',\n    'payment-receipts': 'payment_receipts',\n    'communication': 'communication_records',\n    \n    // Business documents\n    'contracts': 'business_contracts',\n    'financial-statements': 'financial_statements',\n    'correspondence': 'correspondence',\n    \n    // General/default documents\n    'relevant-docs': 'general_documents',\n    \n    // If no mapping exists, function returns undefined to let backend infer the type\n  };\n\n  return mapping[documentId] || undefined; // Return undefined to let backend infer\n}\n\nconst MatterTab: FunctionComponent<MatterTabProps> = ({\n  matter,\n  status,\n  onStartChat,\n  onViewInChat,\n  onPayNow,\n  onViewPDF,\n  onShareMatter,\n  onUploadDocument\n}) => {\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const pendingUploadDocId = useRef<string | null>(null);\n\n  // Handle file upload\n  const handleDocumentIconUpload = async (event: Event) => {\n    const target = event.target as HTMLInputElement;\n    const files = target.files;\n    if (files && files.length > 0 && onUploadDocument) {\n      try {\n        const fileArray = Array.from(files);\n        const documentType = mapDocumentIdToType(pendingUploadDocId.current);\n        const metadata: { documentType?: string; matterId?: string } = {\n          matterId: matter?.matterNumber,\n        };\n        // Only include documentType if we have a valid mapping\n        if (documentType) {\n          metadata.documentType = documentType;\n        }\n        await onUploadDocument(fileArray, metadata);\n        // Reset the input and clear pending document ID\n        if (fileInputRef.current) {\n          fileInputRef.current.value = '';\n        }\n        pendingUploadDocId.current = null;\n      } catch (error) {\n        console.error('DocumentIcon upload failed:', error);\n        // Clear pending document ID even on error\n        pendingUploadDocId.current = null;\n      }\n    }\n  };\n\n  // Trigger file input\n  const triggerDocumentIconUpload = (documentId?: string) => {\n    // Set the pending document ID before opening the file picker\n    if (documentId) {\n      pendingUploadDocId.current = documentId;\n    }\n    if (fileInputRef.current) {\n      fileInputRef.current.click();\n    }\n  };\n\n  // Empty state - no matter exists yet\n  if (status === 'empty') {\n    return (\n      <div>\n        <DocumentIcon />\n        <h3>No Matter Yet</h3>\n        <p>Start a chat to create your matter</p>\n        <Button onClick={onStartChat} variant=\"primary\" size=\"sm\">\n          Start Chat\n        </Button>\n      </div>\n    );\n  }\n\n  if (!matter) {\n    return null;\n  }\n\n  // Get document suggestions (use existing or default)\n  const documentSuggestions = matter.documentChecklist?.documents || \n    getDefaultDocumentSuggestions(matter.service) || [];\n\n  // Analyze missing information\n  const missingInfo = analyzeMissingInfo(matter);\n\n  // Derive a workflow badge status for display\n  const badgeStatus: MatterWorkflowStatus = (() => {\n    switch (status) {\n      case 'ready':\n        return 'completed';\n      default:\n        return 'lead';\n    }\n  })();\n\n  return (\n    <div>\n      {/* Matter Header */}\n      <div>\n        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>\n          <h3>{matter.matterNumber || 'Matter'}</h3>\n          <MatterStatusBadge status={badgeStatus} />\n        </div>\n        <p>{matter.service}</p>\n        {(() => {\n          const msg = (() => {\n            switch (status) {\n              case 'ready':\n                return 'Ready  all required information provided';\n              case 'incomplete':\n                return 'In progress  more information may be needed';\n              default:\n                return 'Waiting for review by the legal team';\n            }\n          })();\n          return (\n            <p style={{ fontSize: '0.85rem', color: 'var(--gray-500)' }}>\n              {msg}\n            </p>\n          );\n        })()}\n        {matter.matterSummary && (\n          <p>{matter.matterSummary.substring(0, 100)}...</p>\n        )}\n      </div>\n\n      {/* Missing Information Section */}\n      {missingInfo.length > 0 && (\n        <div>\n          <div>\n            <ExclamationTriangleIcon />\n            <h4>Missing Information</h4>\n          </div>\n          <ul>\n            {missingInfo.slice(0, 3).map((info, index) => (\n              <li key={index}> {info}</li>\n            ))}\n            {missingInfo.length > 3 && (\n              <li> +{missingInfo.length - 3} more items</li>\n            )}\n          </ul>\n          <Button onClick={onViewInChat} variant=\"secondary\" size=\"sm\" className=\"mt-2\">\n            Continue in Chat\n          </Button>\n        </div>\n      )}\n\n      {/* Document Suggestions */}\n      <div>\n        <div>\n          <DocumentIcon />\n          <h4>Suggested Documents</h4>\n        </div>\n        <div>\n          {documentSuggestions.slice(0, 3).map((doc) => (\n            <div key={doc.id}>\n              <div>\n                {doc.status === 'uploaded' ? (\n                  <CheckCircleIcon />\n                ) : (\n                  <DocumentIcon />\n                )}\n                <div>\n                  <p>{doc.name}</p>\n                  {doc.required && (\n                    <span>Required</span>\n                  )}\n                </div>\n              </div>\n              {doc.status === 'missing' && (\n                <Button \n                  onClick={() => triggerDocumentIconUpload(doc.id)} \n                  variant=\"outline\" \n                  size=\"sm\"\n                >\n                  Upload\n                </Button>\n              )}\n            </div>\n          ))}\n          {documentSuggestions.length > 3 && (\n            <p>+{documentSuggestions.length - 3} more documents</p>\n          )}\n        </div>\n      </div>\n\n      {/* Ready State Actions */}\n      {status === 'ready' && (\n        <div>\n          <div>\n            <CheckCircleIcon />\n            <h4>Matter Complete</h4>\n          </div>\n          <p>All required information has been provided</p>\n          <div>\n            <div className=\"flex flex-col sm:flex-row gap-2 mt-4\">\n              {onPayNow && (\n                <Button onClick={onPayNow} variant=\"primary\" size=\"sm\" className=\"flex-1\">\n                  Pay Now\n                </Button>\n              )}\n              <Button onClick={onViewPDF} variant=\"secondary\" size=\"sm\" className=\"flex-1\">\n                View PDF\n              </Button>\n              <Button onClick={onShareMatter} variant=\"outline\" size=\"sm\" className=\"flex-1\">\n                Share Matter\n              </Button>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* View in Chat Link */}\n      <div className=\"mt-4\">\n        <Button onClick={onViewInChat} variant=\"ghost\" size=\"sm\" className=\"w-full\">\n          View in Chat\n        </Button>\n      </div>\n\n      {/* Hidden file input for document uploads */}\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        multiple\n        accept=\".pdf,.doc,.docx,.txt,.jpg,.jpeg,.png,.gif,.webp\"\n        onChange={handleDocumentIconUpload}\n        style={{ display: 'none' }}\n      />\n    </div>\n  );\n};\n\n\nexport default MatterTab;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/StatusBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/expenses/ExpenseForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/expenses/MatterExpensesPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/messages/MatterMessagesPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/milestones/MatterMilestonesPanel.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":121,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":121,"endColumn":24,"suggestions":[{"fix":{"range":[4487,4559],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":20,"suggestions":[{"fix":{"range":[5510,5587],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo, useState } from 'preact/hooks';\nimport { ArrowDownIcon, ArrowUpIcon, PencilIcon, PlusIcon, TrashIcon } from '@heroicons/react/24/outline';\nimport Modal from '@/shared/components/Modal';\nimport { Button } from '@/shared/ui/Button';\nimport { Combobox } from '@/shared/ui/input/Combobox';\nimport { CurrencyInput } from '@/shared/ui/input/CurrencyInput';\nimport { Input } from '@/shared/ui/input/Input';\nimport { formatCurrency } from '@/shared/utils/currencyFormatter';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { formatDateOnlyUtc } from '@/shared/utils/dateOnly';\nimport { asMajor, type MajorAmount } from '@/shared/utils/money';\nimport type { MatterDetail, MatterMilestone } from '@/features/matters/data/matterTypes';\n\ntype MilestoneStatus = 'pending' | 'in_progress' | 'completed' | 'overdue';\n\ninterface MatterMilestonesPanelProps {\n  matter: MatterDetail;\n  milestones?: MatterDetail['milestones'];\n  loading?: boolean;\n  error?: string | null;\n  onCreateMilestone?: (values: { description: string; amount: MajorAmount; dueDate: string; status?: MilestoneStatus }) => Promise<void> | void;\n  onUpdateMilestone?: (\n    milestone: MatterMilestone,\n    values: { description: string; amount: MajorAmount; dueDate: string; status?: MilestoneStatus }\n  ) => Promise<void> | void;\n  onDeleteMilestone?: (milestone: MatterMilestone) => Promise<void> | void;\n  onReorderMilestones?: (nextOrder: MatterDetail['milestones']) => Promise<void> | void;\n  allowReorder?: boolean;\n  allowEdit?: boolean;\n}\n\nexport const MatterMilestonesPanel = ({\n  matter,\n  milestones,\n  loading = false,\n  error = null,\n  onCreateMilestone,\n  onUpdateMilestone,\n  onDeleteMilestone,\n  onReorderMilestones,\n  allowReorder = false,\n  allowEdit = true\n}: MatterMilestonesPanelProps) => {\n  const resolvedMilestones = milestones ?? matter.milestones ?? [];\n  const [isFormOpen, setIsFormOpen] = useState(false);\n  const [editingMilestone, setEditingMilestone] = useState<MatterMilestone | null>(null);\n  const [deleteTarget, setDeleteTarget] = useState<MatterMilestone | null>(null);\n  const [formKey, setFormKey] = useState(0);\n  const [formState, setFormState] = useState({\n    description: '',\n    amount: undefined as MajorAmount | undefined,\n    dueDate: '',\n    status: 'pending' as MilestoneStatus\n  });\n  const [submitError, setSubmitError] = useState<string | null>(null);\n  const [deleteError, setDeleteError] = useState<string | null>(null);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const { showError } = useToastContext();\n  const canCreate = Boolean(onCreateMilestone);\n  const canEdit = allowEdit && Boolean(onUpdateMilestone);\n  const canDelete = allowEdit && Boolean(onDeleteMilestone);\n  const canReorder = allowReorder && typeof onReorderMilestones === 'function';\n  const statusOptions = useMemo(() => ([\n    { value: 'pending', label: 'Pending' },\n    { value: 'in_progress', label: 'In progress' },\n    { value: 'completed', label: 'Completed' },\n    { value: 'overdue', label: 'Overdue' }\n  ]), []);\n\n  const openForm = () => {\n    if (!canCreate) return;\n    setEditingMilestone(null);\n    setFormState({\n      description: '',\n      amount: undefined,\n      dueDate: '',\n      status: 'pending'\n    });\n    setSubmitError(null);\n    setFormKey((prev) => prev + 1);\n    setIsFormOpen(true);\n  };\n\n  const openEditForm = (milestone: MatterMilestone) => {\n    if (!canEdit) return;\n    setEditingMilestone(milestone);\n    setFormState({\n      description: milestone.description ?? '',\n      amount: milestone.amount ?? undefined,\n      dueDate: milestone.dueDate ?? '',\n      status: milestone.status ?? 'pending'\n    });\n    setSubmitError(null);\n    setFormKey((prev) => prev + 1);\n    setIsFormOpen(true);\n  };\n\n  const closeForm = () => {\n    setIsFormOpen(false);\n    setSubmitError(null);\n    setEditingMilestone(null);\n  };\n\n  const handleSubmit = async (event: Event) => {\n    event.preventDefault();\n    if (!formState.description.trim() || formState.amount === undefined || !formState.dueDate) {\n      setSubmitError('Please fill out description, amount, and due date.');\n      return;\n    }\n    setSubmitError(null);\n    setIsSubmitting(true);\n    try {\n      const payload = {\n        description: formState.description.trim(),\n        amount: formState.amount,\n        dueDate: formState.dueDate,\n        status: formState.status\n      };\n      if (editingMilestone) {\n        if (!onUpdateMilestone) {\n          console.error('[MatterMilestonesPanel] Cannot update: handler missing');\n          setSubmitError('Cannot update milestone.');\n          return;\n        }\n        await onUpdateMilestone(editingMilestone, payload);\n      } else if (onCreateMilestone) {\n        await onCreateMilestone(payload);\n      } else {\n        return;\n      }\n      closeForm();\n    } catch (error) {\n      const message = error instanceof Error\n        ? error.message\n        : `Failed to ${editingMilestone ? 'update' : 'create'} milestone`;\n      setSubmitError(message);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  const moveMilestone = async (index: number, direction: -1 | 1) => {\n    if (!canReorder) return;\n    const nextIndex = index + direction;\n    if (nextIndex < 0 || nextIndex >= resolvedMilestones.length) return;\n    const next = [...resolvedMilestones];\n    const [moved] = next.splice(index, 1);\n    next.splice(nextIndex, 0, moved);\n    try {\n      await onReorderMilestones?.(next);\n    } catch (error) {\n      console.error('[MatterMilestonesPanel] Failed to reorder milestones', error);\n      showError('Could not reorder milestones', 'Please try again.');\n    }\n  };\n\n  const confirmDelete = (milestone: MatterMilestone) => {\n    if (!canDelete) return;\n    setDeleteTarget(milestone);\n  };\n\n  const handleDelete = async () => {\n    if (!deleteTarget || !onDeleteMilestone) return;\n    setDeleteError(null);\n    setIsSubmitting(true);\n    try {\n      await onDeleteMilestone(deleteTarget);\n      setDeleteTarget(null);\n      if (editingMilestone?.id === deleteTarget.id) {\n        closeForm();\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to delete milestone';\n      setDeleteError(message);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <section className=\"glass-panel\">\n      <header className=\"flex flex-wrap items-center justify-between gap-3 border-b border-line-glass/30 px-6 py-4\">\n        <div>\n          <h3 className=\"text-sm font-semibold text-input-text\">Milestones</h3>\n          <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n            {resolvedMilestones.length} milestones tracked\n          </p>\n        </div>\n        <Button size=\"sm\" icon={<PlusIcon className=\"h-4 w-4\" />} onClick={openForm} disabled={!canCreate}>\n          Add milestone\n        </Button>\n      </header>\n\n      {error ? (\n        <div className=\"px-6 py-6 text-sm text-red-600 dark:text-red-400\">\n          {error}\n        </div>\n      ) : loading && resolvedMilestones.length === 0 ? (\n        <div className=\"px-6 py-6 text-sm text-gray-500 dark:text-gray-400\">\n          Loading milestones...\n        </div>\n      ) : resolvedMilestones.length === 0 ? (\n        <div className=\"px-6 py-6 text-sm text-gray-500 dark:text-gray-400\">\n          No milestones yet. Add milestones to track key deliverables for this matter.\n        </div>\n      ) : (\n        <ul className=\"divide-y divide-line-default\">\n          {resolvedMilestones.map((milestone, index) => (\n            <li key={milestone.id ?? `${milestone.description}-${index}`} className=\"px-6 py-4\">\n              <div className=\"flex flex-wrap items-start justify-between gap-3\">\n                <div className=\"min-w-0\">\n                  <p className=\"text-sm font-semibold text-input-text\">\n                    {milestone.description}\n                  </p>\n                  <div className=\"mt-1 flex flex-wrap items-center gap-2 text-xs text-gray-500 dark:text-gray-400\">\n                    {milestone.dueDate ? (\n                      <span>\n                        Due <time dateTime={milestone.dueDate}>{formatDateOnlyUtc(milestone.dueDate)}</time>\n                      </span>\n                    ) : (\n                      <span>No due date</span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"text-sm font-semibold text-input-text\">\n                    {formatCurrency(milestone.amount ?? 0)}\n                  </div>\n                  <div className=\"flex items-center gap-1\">\n                  {canEdit && (\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        icon={<PencilIcon className=\"h-4 w-4\" />}\n                        onClick={() => openEditForm(milestone)}\n                        aria-label=\"Edit milestone\"\n                      />\n                    )}\n                    {canDelete && (\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        icon={<TrashIcon className=\"h-4 w-4\" />}\n                        onClick={() => confirmDelete(milestone)}\n                        aria-label=\"Delete milestone\"\n                      />\n                    )}\n                  </div>\n                  {canReorder ? (\n                    <div className=\"flex items-center gap-1\">\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        icon={<ArrowUpIcon className=\"h-4 w-4\" />}\n                        onClick={() => moveMilestone(index, -1)}\n                        aria-label=\"Move milestone up\"\n                      />\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        icon={<ArrowDownIcon className=\"h-4 w-4\" />}\n                        onClick={() => moveMilestone(index, 1)}\n                        aria-label=\"Move milestone down\"\n                      />\n                    </div>\n                  ) : null}\n                </div>\n              </div>\n            </li>\n          ))}\n        </ul>\n      )}\n\n      {isFormOpen && (\n        <Modal\n          isOpen={isFormOpen}\n          onClose={closeForm}\n          title={editingMilestone ? 'Edit milestone' : 'Add milestone'}\n          contentClassName=\"max-w-2xl\"\n        >\n          <form key={formKey} className=\"space-y-4\" onSubmit={handleSubmit}>\n            <Input\n              label=\"Description\"\n              value={formState.description}\n              onChange={(value) => setFormState((prev) => ({ ...prev, description: value }))}\n              required\n              placeholder=\"Draft documents\"\n            />\n            <CurrencyInput\n              label=\"Amount\"\n              value={formState.amount}\n              onChange={(value) =>\n                setFormState((prev) => ({\n                  ...prev,\n                  amount: typeof value === 'number' ? asMajor(value) : undefined\n                }))\n              }\n              required\n              min={0}\n              step={0.01}\n            />\n            <Input\n              label=\"Due date\"\n              type=\"date\"\n              value={formState.dueDate}\n              onChange={(value) => setFormState((prev) => ({ ...prev, dueDate: value }))}\n              required\n            />\n            <div>\n              <span className=\"block text-sm font-medium text-input-text mb-1\">Status</span>\n              <Combobox\n                value={formState.status}\n                options={statusOptions}\n                onChange={(value) => setFormState((prev) => ({ ...prev, status: value as MilestoneStatus }))}\n                className=\"w-full justify-between px-3 py-2 text-sm rounded-lg border border-input-border bg-input-bg focus:ring-2 focus:ring-accent-500 focus:border-accent-500\"\n                searchable={false}\n              />\n            </div>\n            {submitError && (\n              <p className=\"text-sm text-red-600 dark:text-red-400\">{submitError}</p>\n            )}\n            <div className=\"flex items-center justify-end gap-3\">\n              <Button type=\"button\" variant=\"secondary\" onClick={closeForm}>\n                Cancel\n              </Button>\n              <Button type=\"submit\" disabled={isSubmitting}>\n                {isSubmitting ? 'Saving...' : editingMilestone ? 'Update milestone' : 'Add milestone'}\n              </Button>\n            </div>\n          </form>\n        </Modal>\n      )}\n\n      {canDelete && deleteTarget && (\n        <Modal\n          isOpen={Boolean(deleteTarget)}\n          onClose={() => setDeleteTarget(null)}\n          title=\"Delete milestone\"\n          contentClassName=\"max-w-xl\"\n        >\n          <div className=\"space-y-4\">\n            <p className=\"text-sm text-gray-600 dark:text-gray-300\">\n              Are you sure you want to delete this milestone? This action cannot be undone.\n            </p>\n            {deleteError && (\n              <p className=\"text-sm text-red-600 dark:text-red-400\">{deleteError}</p>\n            )}\n            <div className=\"flex items-center justify-end gap-3\">\n              <Button variant=\"secondary\" onClick={() => setDeleteTarget(null)}>\n                Cancel\n              </Button>\n              <Button variant=\"danger\" onClick={handleDelete} disabled={isSubmitting}>\n                {isSubmitting ? 'Deleting...' : 'Delete milestone'}\n              </Button>\n            </div>\n          </div>\n        </Modal>\n      )}\n    </section>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/notes/MatterNotesPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/notes/NoteForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/tasks/MatterTaskForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/tasks/MatterTasksPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/time-entries/TimeEntriesPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/time-entries/TimeEntryForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/components/time-entries/WorkDiaryCalendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/data/matterTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/hooks/useTimeEntries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/pages/ClientMattersPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/pages/PracticeMattersPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":354,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":354,"endColumn":17,"suggestions":[{"fix":{"range":[13554,13665],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":684,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":684,"endColumn":20,"suggestions":[{"fix":{"range":[28006,28084],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":824,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":824,"endColumn":27,"suggestions":[{"fix":{"range":[34027,34129],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":980,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":980,"endColumn":24,"suggestions":[{"fix":{"range":[39662,39731],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1007,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1007,"endColumn":21,"suggestions":[{"fix":{"range":[40522,40600],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1059,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1059,"endColumn":20,"suggestions":[{"fix":{"range":[42227,42301],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1133,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1133,"endColumn":29,"suggestions":[{"fix":{"range":[44636,44736],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1138,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1138,"endColumn":29,"suggestions":[{"fix":{"range":[44899,45027],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1153,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1153,"endColumn":21,"suggestions":[{"fix":{"range":[45465,45534],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1187,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1187,"endColumn":21,"suggestions":[{"fix":{"range":[46588,46667],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1275,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1275,"endColumn":21,"suggestions":[{"fix":{"range":[49407,49478],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1341,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1341,"endColumn":20,"suggestions":[{"fix":{"range":[52130,52203],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1350,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1350,"endColumn":22,"suggestions":[{"fix":{"range":[52644,52726],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1370,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1370,"endColumn":20,"suggestions":[{"fix":{"range":[53478,53551],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1380,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1380,"endColumn":22,"suggestions":[{"fix":{"range":[54026,54108],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1409,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1409,"endColumn":20,"suggestions":[{"fix":{"range":[54884,54959],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1471,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1471,"endColumn":20,"suggestions":[{"fix":{"range":[57596,57667],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1478,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1478,"endColumn":22,"suggestions":[{"fix":{"range":[57973,58053],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1493,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1493,"endColumn":20,"suggestions":[{"fix":{"range":[58567,58638],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1501,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1501,"endColumn":22,"suggestions":[{"fix":{"range":[58976,59056],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1532,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1532,"endColumn":20,"suggestions":[{"fix":{"range":[60145,60217],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1550,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1550,"endColumn":20,"suggestions":[{"fix":{"range":[60932,61006],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1627,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1627,"endColumn":19,"suggestions":[{"fix":{"range":[64348,64420],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1640,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1640,"endColumn":19,"suggestions":[{"fix":{"range":[64775,64852],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2277,"column":29,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2277,"endColumn":42,"suggestions":[{"fix":{"range":[92964,93030],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { useLocation } from 'preact-iso';\nimport { PageHeader } from '@/shared/ui/layout/PageHeader';\nimport { Page } from '@/shared/ui/layout/Page';\nimport { Panel } from '@/shared/ui/layout/Panel';\nimport { Tabs, type TabItem } from '@/shared/ui/tabs/Tabs';\nimport { Button } from '@/shared/ui/Button';\nimport { Breadcrumbs } from '@/shared/ui/navigation';\nimport { MarkdownUploadTextarea } from '@/shared/ui/input/MarkdownUploadTextarea';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger\n} from '@/shared/ui/dropdown';\nimport { ActivityTimeline, type TimelineItem, type TimelinePerson } from '@/shared/ui/activity/ActivityTimeline';\nimport Modal from '@/shared/components/Modal';\nimport {\n  ChevronUpDownIcon,\n  FolderIcon,\n  PlusIcon\n} from '@heroicons/react/24/outline';\nimport {\n  MATTER_STATUS_LABELS,\n  MATTER_WORKFLOW_STATUSES,\n  isMatterStatus,\n  type MatterStatus\n} from '@/shared/types/matterStatus';\nimport {\n  type MatterDetail,\n  type MatterExpense,\n  type MatterOption,\n  type MatterSummary,\n  type TimeEntry\n} from '@/features/matters/data/matterTypes';\nimport { MatterCreateForm, MatterEditForm, type MatterFormState } from '@/features/matters/components/MatterCreateModal';\nimport { MatterListItem } from '@/features/matters/components/MatterListItem';\nimport { formatRelativeTime } from '@/features/matters/utils/formatRelativeTime';\nimport { TimeEntriesPanel } from '@/features/matters/components/time-entries/TimeEntriesPanel';\nimport { TimeEntryForm, type TimeEntryFormValues } from '@/features/matters/components/time-entries/TimeEntryForm';\nimport { MatterExpensesPanel } from '@/features/matters/components/expenses/MatterExpensesPanel';\nimport { MatterMessagesPanel } from '@/features/matters/components/messages/MatterMessagesPanel';\nimport { MatterMilestonesPanel } from '@/features/matters/components/milestones/MatterMilestonesPanel';\nimport { MatterSummaryCards } from '@/features/matters/components/MatterSummaryCards';\nimport { MatterDetailHeader } from '@/features/matters/components/MatterDetailHeader';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { usePracticeManagement } from '@/shared/hooks/usePracticeManagement';\nimport { usePracticeDetails } from '@/shared/hooks/usePracticeDetails';\nimport { asMajor, toMajorUnits, type MajorAmount } from '@/shared/utils/money';\nimport { formatCurrency } from '@/shared/utils/currencyFormatter';\nimport {\n  createMatter,\n  getMatter,\n  getMatterActivity,\n  listMatters,\n  updateMatter,\n  type BackendMatter,\n  type BackendMatterActivity,\n  type BackendMatterExpense,\n  type BackendMatterMilestone,\n  type BackendMatterNote,\n  type BackendMatterTimeEntry,\n  type BackendMatterTimeStats,\n  createMatterExpense,\n  createMatterNote,\n  createMatterMilestone,\n  createMatterTimeEntry,\n  deleteMatterExpense,\n  deleteMatterMilestone,\n  deleteMatterTimeEntry,\n  getMatterTimeEntryStats,\n  listMatterExpenses,\n  listMatterMilestones,\n  listMatterNotes,\n  listMatterTimeEntries,\n  reorderMatterMilestones,\n  updateMatterExpense,\n  updateMatterMilestone,\n  updateMatterTimeEntry\n} from '@/features/matters/services/mattersApi';\nimport { listUserDetails, type UserDetailRecord } from '@/shared/lib/apiClient';\n\nconst statusOrder = Object.fromEntries(\n  MATTER_WORKFLOW_STATUSES.map((status, index) => [status, index])\n) as Record<MatterStatus, number>;\n\nimport { debounce } from '@/shared/utils/debounce';\nimport { formatLongDate } from '@/shared/utils/dateFormatter';\n\ntype MatterTabId = 'all' | 'open' | 'closed';\ntype DetailTabId = 'overview' | 'time' | 'messages';\n\ntype SortOption = 'updated' | 'title' | 'status' | 'client' | 'assigned' | 'practice_area';\n\nconst SORT_LABELS: Record<SortOption, string> = {\n  updated: 'Date updated',\n  title: 'Title',\n  status: 'Status',\n  client: 'Client',\n  assigned: 'Assigned',\n  practice_area: 'Practice area'\n};\n\nconst CLOSED_STATUSES: MatterStatus[] = ['closed', 'declined', 'conflicted', 'referred'];\n\nconst isClosedStatus = (status: MatterStatus) => CLOSED_STATUSES.includes(status);\n\nconst buildTabs = (counts: { open: number; closed: number; all: number }): TabItem[] => [\n  { id: 'all', label: 'All', count: counts.all },\n  { id: 'open', label: 'Open', count: counts.open },\n  { id: 'closed', label: 'Closed', count: counts.closed }\n];\n\nconst TAB_HEADINGS: Record<MatterTabId, string> = {\n  all: 'All',\n  open: 'Open',\n  closed: 'Closed'\n};\n\nconst DETAIL_TABS: Array<{ id: DetailTabId; label: string }> = [\n  { id: 'overview', label: 'Overview' },\n  { id: 'time', label: 'Billing' },\n  { id: 'messages', label: 'Messages' }\n];\n\nconst isUuid = (value: string) =>\n  /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value);\n\ntype PracticeMattersPageProps = {\n  basePath?: string;\n};\n\n\n\nconst formatMinorCurrency = (value: unknown): string | null => {\n  if (typeof value !== 'number' || !Number.isFinite(value)) return null;\n  const major = toMajorUnits(value);\n  if (typeof major !== 'number' || !Number.isFinite(major)) return null;\n  return formatCurrency(major);\n};\n\nconst formatUrgencyLabel = (value: string) => value.replace(/_/g, ' ');\n\nconst resolveClientLabel = (clientId?: string | null, fallback?: string) => {\n  if (fallback) return fallback;\n  return clientId ? `Client ${clientId.slice(0, 8)}` : 'Unassigned client';\n};\n\nconst resolvePracticeServiceLabel = (serviceId?: string | null, fallback?: string) => {\n  if (fallback) return fallback;\n  return serviceId ? `Service ${serviceId.slice(0, 8)}` : 'Not specified';\n};\n\nconst resolveOptionLabel = (options: MatterOption[], id: string, fallback: string) =>\n  options.find((option) => option.id === id)?.name ?? fallback;\n\nconst normalizeMatterStatus = (status?: string | null): MatterStatus => {\n  const normalized = status?.toLowerCase().replace(/\\s+/g, '_') ?? '';\n  if (normalized === 'draft' || normalized === 'lead') return 'first_contact';\n  if (isMatterStatus(normalized)) return normalized;\n  return 'first_contact';\n};\n\nconst mapStatusToBackend = (status: MatterStatus): MatterStatus => status;\n\nconst prunePayload = (payload: Record<string, unknown>) =>\n  Object.fromEntries(\n    Object.entries(payload).filter(([, value]) => value !== undefined)\n  );\n\nconst extractAssigneeIds = (matter: BackendMatter): string[] => {\n  if (Array.isArray(matter.assignee_ids)) {\n    return matter.assignee_ids.filter((id): id is string => typeof id === 'string' && id.trim().length > 0);\n  }\n  if (Array.isArray(matter.assignees)) {\n    return matter.assignees\n      .map((assignee) => {\n        if (typeof assignee === 'string') return assignee;\n        if (!assignee || typeof assignee !== 'object') return '';\n        const record = assignee as Record<string, unknown>;\n        if (typeof record.id === 'string') return record.id;\n        if (typeof record.user_id === 'string') return record.user_id;\n        return '';\n      })\n      .filter((id) => id.trim().length > 0);\n  }\n  return [];\n};\n\nconst mapMilestones = (milestones?: BackendMatter['milestones']): MatterDetail['milestones'] => {\n  if (!Array.isArray(milestones)) return [];\n  return milestones.map((item, index) => {\n    if (!item || typeof item !== 'object') {\n      return {\n        description: `Milestone ${index + 1}`,\n        dueDate: '',\n        amount: asMajor(0)\n      };\n    }\n    const record = item as Record<string, unknown>;\n    return {\n      description: typeof record.description === 'string' ? record.description : `Milestone ${index + 1}`,\n      dueDate: typeof record.due_date === 'string'\n        ? record.due_date\n        : typeof record.dueDate === 'string'\n          ? record.dueDate\n          : '',\n      amount: typeof record.amount === 'number' ? asMajor(record.amount) : asMajor(0)\n    };\n  });\n};\n\nconst toMatterSummary = (\n  matter: BackendMatter,\n  options?: {\n    clientNameById?: Map<string, string>;\n    serviceNameById?: Map<string, string>;\n  }\n): MatterSummary => {\n  const updatedAt = matter.updated_at || matter.created_at || new Date().toISOString();\n  const clientName = matter.client_id\n    ? options?.clientNameById?.get(matter.client_id)\n    : undefined;\n  const serviceName = matter.practice_service_id\n    ? options?.serviceNameById?.get(matter.practice_service_id)\n    : undefined;\n  return {\n    id: matter.id,\n    title: matter.title || 'Untitled matter',\n    clientName: resolveClientLabel(matter.client_id, clientName),\n    practiceArea: matter.practice_service_id\n      ? resolvePracticeServiceLabel(matter.practice_service_id, serviceName)\n      : null,\n    status: normalizeMatterStatus(matter.status),\n    updatedAt,\n    createdAt: matter.created_at || matter.updated_at || new Date().toISOString()\n  };\n};\n\nconst toMatterDetail = (\n  matter: BackendMatter,\n  options?: {\n    clientNameById?: Map<string, string>;\n    serviceNameById?: Map<string, string>;\n  }\n): MatterDetail => ({\n  ...toMatterSummary(matter, options),\n  clientId: matter.client_id || '',\n  practiceAreaId: matter.practice_service_id || '',\n  assigneeIds: extractAssigneeIds(matter),\n  description: matter.description || '',\n  caseNumber: matter.case_number ?? undefined,\n  matterType: matter.matter_type ?? undefined,\n  urgency: (matter.urgency as MatterDetail['urgency']) ?? undefined,\n  responsibleAttorneyId: matter.responsible_attorney_id ?? undefined,\n  originatingAttorneyId: matter.originating_attorney_id ?? undefined,\n  court: matter.court ?? undefined,\n  judge: matter.judge ?? undefined,\n  opposingParty: matter.opposing_party ?? undefined,\n  opposingCounsel: matter.opposing_counsel ?? undefined,\n  openDate: matter.open_date ?? undefined,\n  closeDate: matter.close_date ?? undefined,\n  billingType: (matter.billing_type as MatterDetail['billingType']) || 'hourly',\n  attorneyHourlyRate: typeof matter.attorney_hourly_rate === 'number'\n    ? asMajor(matter.attorney_hourly_rate)\n    : undefined,\n  adminHourlyRate: typeof matter.admin_hourly_rate === 'number'\n    ? asMajor(matter.admin_hourly_rate)\n    : undefined,\n  paymentFrequency: (matter.payment_frequency as MatterDetail['paymentFrequency']) ?? undefined,\n  totalFixedPrice: typeof matter.total_fixed_price === 'number'\n    ? asMajor(matter.total_fixed_price)\n    : undefined,\n  settlementAmount: typeof matter.settlement_amount === 'number'\n    ? asMajor(matter.settlement_amount)\n    : undefined,\n  milestones: mapMilestones(matter.milestones),\n  contingencyPercent: matter.contingency_percentage ?? undefined,\n  timeEntries: [],\n  expenses: [],\n  notes: []\n});\n\nconst activityActionMap: Record<string, { type: TimelineItem['type']; label: string }> = {\n  matter_created: { type: 'created', label: 'created the matter.' },\n  matter_updated: { type: 'edited', label: 'updated matter details.' },\n  matter_deleted: { type: 'edited', label: 'deleted the matter.' },\n  matter_status_changed: { type: 'edited', label: 'updated the status.' },\n  note_added: { type: 'commented', label: 'added a note.' },\n  note_updated: { type: 'commented', label: 'updated a note.' },\n  note_deleted: { type: 'commented', label: 'deleted a note.' },\n  time_entry_added: { type: 'edited', label: 'added a time entry.' },\n  time_entry_updated: { type: 'edited', label: 'updated a time entry.' },\n  time_entry_deleted: { type: 'edited', label: 'deleted a time entry.' },\n  expense_added: { type: 'edited', label: 'added an expense.' },\n  expense_updated: { type: 'edited', label: 'updated an expense.' },\n  expense_deleted: { type: 'edited', label: 'deleted an expense.' },\n  milestone_created: { type: 'edited', label: 'added a milestone.' },\n  milestone_updated: { type: 'edited', label: 'updated a milestone.' },\n  milestone_deleted: { type: 'edited', label: 'deleted a milestone.' },\n  milestone_completed: { type: 'edited', label: 'completed a milestone.' },\n  assignee_added: { type: 'edited', label: 'assigned a team member.' },\n  assignee_removed: { type: 'edited', label: 'removed an assignee.' }\n};\n\nconst humanizeAction = (value?: string | null): string | undefined => {\n  if (!value) return undefined;\n  return value\n    .trim()\n    .replace(/_/g, ' ')\n    .replace(/\\b\\w/g, (match) => match.toUpperCase());\n};\n\nconst FIELD_LABELS: Record<string, string> = {\n  title: 'title',\n  description: 'description',\n  client_id: 'client',\n  practice_service_id: 'practice area',\n  billing_type: 'billing type',\n  case_number: 'case number',\n  matter_type: 'matter type',\n  urgency: 'urgency',\n  responsible_attorney_id: 'responsible attorney',\n  originating_attorney_id: 'originating attorney',\n  court: 'court',\n  judge: 'judge',\n  opposing_party: 'opposing party',\n  opposing_counsel: 'opposing counsel',\n  open_date: 'open date',\n  close_date: 'close date',\n  admin_hourly_rate: 'admin rate',\n  attorney_hourly_rate: 'attorney rate',\n  status: 'status',\n  payment_frequency: 'payment schedule',\n  total_fixed_price: 'fixed fee',\n  contingency_percentage: 'contingency percentage',\n  settlement_amount: 'settlement amount',\n  assignee_ids: 'team members',\n  assignees: 'team members'\n};\n\nconst normalizeFieldLabel = (field: string): string => {\n  const trimmed = field.trim();\n  if (!trimmed) return '';\n  return FIELD_LABELS[trimmed] ?? trimmed.replace(/_/g, ' ');\n};\n\nconst isEmailLike = (value: string): boolean => value.includes('@');\n\nconst extractChangedFields = (metadata: Record<string, unknown>): string[] => {\n  const raw = metadata.changed_fields;\n  if (!Array.isArray(raw)) {\n    console.warn('[PracticeMattersPage] Missing or invalid metadata.changed_fields for update activity', metadata);\n    return [];\n  }\n  const normalized = raw\n    .filter((item): item is string => typeof item === 'string')\n    .map(normalizeFieldLabel)\n    .filter((value) => value && value.length > 0);\n  return Array.from(new Set(normalized));\n};\n\n\nconst formatFieldList = (fields: string[]): string | null => {\n  if (fields.length === 0) return null;\n  if (fields.length === 1) return fields[0];\n  if (fields.length === 2) return `${fields[0]} and ${fields[1]}`;\n  return `${fields.slice(0, -1).join(', ')}, and ${fields[fields.length - 1]}`;\n};\n\nconst resolveStatusLabel = (value: string): string => {\n  if (isMatterStatus(value)) return MATTER_STATUS_LABELS[value];\n  return value.replace(/_/g, ' ');\n};\n\nconst buildMatterCreatedLabel = (context: {\n  title?: string | null;\n  clientName?: string | null;\n  practiceArea?: string | null;\n}): string => {\n  const title = context.title?.trim();\n  const clientName = context.clientName?.trim();\n  const practiceArea = context.practiceArea?.trim();\n  if (title) {\n    const clientSuffix = clientName ? ` for ${clientName}` : '';\n    const practiceSuffix = practiceArea ? ` (${practiceArea})` : '';\n    return `created matter ${title}${clientSuffix}${practiceSuffix}.`;\n  }\n  if (clientName || practiceArea) {\n    const clientSuffix = clientName ? ` for ${clientName}` : '';\n    const practiceSuffix = practiceArea ? ` (${practiceArea})` : '';\n    return `created a matter${clientSuffix}${practiceSuffix}.`;\n  }\n  return 'created the matter.';\n};\n\nconst resolveStatusChangeLabel = (metadata: Record<string, unknown>): string | null => {\n  const rawOld = metadata.oldStatus ?? metadata.old_status ?? metadata.from_status ?? metadata.from;\n  const rawNew = metadata.newStatus ?? metadata.new_status ?? metadata.to_status ?? metadata.to ?? metadata.status;\n  const oldValue = typeof rawOld === 'string' ? rawOld.trim() : '';\n  const newValue = typeof rawNew === 'string' ? rawNew.trim() : '';\n\n  if (oldValue && newValue) {\n    return `updated the status from ${resolveStatusLabel(oldValue)} to ${resolveStatusLabel(newValue)}.`;\n  }\n  if (newValue) {\n    return `updated the status to ${resolveStatusLabel(newValue)}.`;\n  }\n  return null;\n};\n\nconst buildStatusChangeMeta = (metadata: Record<string, unknown>): TimelineItem['actionMeta'] | null => {\n  const rawOld = metadata.oldStatus ?? metadata.old_status ?? metadata.from_status ?? metadata.from;\n  const rawNew = metadata.newStatus ?? metadata.new_status ?? metadata.to_status ?? metadata.to ?? metadata.status;\n  const oldValue = typeof rawOld === 'string' ? rawOld.trim() : '';\n  const newValue = typeof rawNew === 'string' ? rawNew.trim() : '';\n  if (!oldValue || !newValue) return null;\n  return {\n    type: 'status_change',\n    from: resolveStatusLabel(oldValue),\n    to: resolveStatusLabel(newValue)\n  };\n};\n\nconst buildSingleFieldUpdateAction = (\n  field: string,\n  metadata: Record<string, unknown>,\n  options: {\n    clientNameById: Map<string, string>;\n    serviceNameById: Map<string, string>;\n    assigneeNameById: Map<string, string>;\n  }\n): string | null => {\n  const changes = metadata.changes;\n  const changeRecord = changes && typeof changes === 'object' ? (changes as Record<string, unknown>) : {};\n  const value = changeRecord[field];\n\n  if (field === 'client_id' && typeof value === 'string' && value.trim()) {\n    const clientName = options.clientNameById.get(value) ?? `Client ${value.slice(0, 6)}`;\n    return `updated client to ${clientName}.`;\n  }\n  if (field === 'practice_service_id' && typeof value === 'string' && value.trim()) {\n    const serviceName = options.serviceNameById.get(value) ?? `Service ${value.slice(0, 6)}`;\n    return `updated practice area to ${serviceName}.`;\n  }\n  if ((field === 'responsible_attorney_id' || field === 'originating_attorney_id') && typeof value === 'string' && value.trim()) {\n    const name = options.assigneeNameById.get(value) ?? `User ${value.slice(0, 6)}`;\n    const label = field === 'responsible_attorney_id' ? 'responsible attorney' : 'originating attorney';\n    return `updated ${label} to ${name}.`;\n  }\n  if (field === 'urgency' && typeof value === 'string' && value.trim()) {\n    return `updated urgency to ${formatUrgencyLabel(value)}.`;\n  }\n  if (field === 'open_date' || field === 'close_date') {\n    const label = field === 'open_date' ? 'open date' : 'close date';\n    const formatted = typeof value === 'string' ? formatLongDate(value) : null;\n    return formatted ? `updated ${label} to ${formatted}.` : `updated ${label}.`;\n  }\n  if (field === 'billing_type' && typeof value === 'string' && value.trim()) {\n    return `updated billing type to ${value.replace(/_/g, ' ')}.`;\n  }\n  if (field === 'admin_hourly_rate' || field === 'attorney_hourly_rate' || field === 'total_fixed_price' || field === 'settlement_amount') {\n    const formatted = formatMinorCurrency(value);\n    const label = normalizeFieldLabel(field);\n    return formatted ? `updated ${label} to ${formatted}.` : `updated ${label}.`;\n  }\n  if (field === 'contingency_percentage' && typeof value === 'number') {\n    return `updated contingency percentage to ${value}%.`;\n  }\n  if (typeof value === 'string' && value.trim()) {\n    return `updated ${normalizeFieldLabel(field)} to ${value}.`;\n  }\n  return `updated ${normalizeFieldLabel(field)}.`;\n};\n\nconst findStatusChangeMeta = (\n  activity: BackendMatterActivity,\n  activities: BackendMatterActivity[]\n): TimelineItem['actionMeta'] | null => {\n  if (!activity.created_at) return null;\n  const activityTime = new Date(activity.created_at).getTime();\n  if (!Number.isFinite(activityTime)) return null;\n  const match = activities.find((candidate) => {\n    if (candidate.action !== 'matter_status_changed') return false;\n    if (candidate.user_id !== activity.user_id) return false;\n    if (!candidate.created_at) return false;\n    const candidateTime = new Date(candidate.created_at).getTime();\n    if (!Number.isFinite(candidateTime)) return false;\n    return Math.abs(candidateTime - activityTime) <= 1000;\n  });\n  if (!match) return null;\n  return buildStatusChangeMeta(match.metadata as Record<string, unknown>);\n};\n\nconst formatDuration = (seconds?: number | null): string | null => {\n  if (typeof seconds !== 'number' || !Number.isFinite(seconds) || seconds <= 0) {\n    return null;\n  }\n  const totalMinutes = Math.round(seconds / 60);\n  const hours = Math.floor(totalMinutes / 60);\n  const minutes = totalMinutes % 60;\n  if (hours > 0 && minutes > 0) {\n    return `${hours} ${hours === 1 ? 'hour' : 'hours'} ${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`;\n  }\n  if (hours > 0) return `${hours} ${hours === 1 ? 'hour' : 'hours'}`;\n  return `${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`;\n};\n\nconst stripActorPrefix = (description: string, actorName: string): string => {\n  const trimmed = description.trim();\n  if (!actorName) return trimmed;\n  const prefix = `${actorName} `;\n  if (trimmed.toLowerCase().startsWith(prefix.toLowerCase())) {\n    return trimmed.slice(prefix.length).trim();\n  }\n  return trimmed;\n};\n\nconst toTimeEntry = (entry: BackendMatterTimeEntry): TimeEntry => ({\n  id: entry.id,\n  startTime: entry.start_time ?? new Date().toISOString(),\n  endTime: entry.end_time ?? new Date().toISOString(),\n  description: entry.description ?? ''\n});\n\nconst toExpense = (expense: BackendMatterExpense): MatterExpense => ({\n  id: expense.id,\n  description: expense.description ?? 'Expense',\n  amount: asMajor(expense.amount ?? 0),\n  date: expense.date ?? new Date().toISOString().slice(0, 10),\n  billable: expense.billable ?? true\n});\n\nconst toMilestone = (milestone: BackendMatterMilestone): MatterDetail['milestones'][number] => ({\n  id: milestone.id,\n  description: milestone.description ?? 'Milestone',\n  amount: asMajor(milestone.amount ?? 0),\n  dueDate: milestone.due_date ?? '',\n  status: ((): MatterDetail['milestones'][number]['status'] => {\n    const status = typeof milestone.status === 'string' ? milestone.status : undefined;\n    if (!status) return undefined;\n    if (status === 'pending' || status === 'in_progress' || status === 'completed' || status === 'overdue') {\n      return status;\n    }\n    return undefined;\n  })()\n});\n\nconst EmptyState = ({ onCreate, disableCreate }: { onCreate?: () => void; disableCreate?: boolean }) => (\n  <div className=\"flex h-full items-center justify-center p-8\">\n    <div className=\"max-w-md text-center\">\n      <div className=\"mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-white/[0.08] ring-1 ring-white/[0.12]\">\n        <FolderIcon className=\"h-6 w-6 text-input-text/70\" aria-hidden=\"true\" />\n      </div>\n      <h3 className=\"mt-4 text-sm font-semibold text-input-text\">No matters yet</h3>\n      <p className=\"mt-2 text-sm text-input-placeholder\">\n        Create your first matter to start tracking progress and milestones.\n      </p>\n      <div className=\"mt-6 flex justify-center\">\n        <Button size=\"sm\" icon={<PlusIcon className=\"h-4 w-4\" />} onClick={onCreate} disabled={disableCreate}>\n          Add Matter\n        </Button>\n      </div>\n    </div>\n  </div>\n);\n\nconst LoadingState = ({ message }: { message: string }) => (\n  <div className=\"flex h-full items-center justify-center p-8 text-sm text-input-placeholder\">\n    {message}\n  </div>\n);\n\nexport const PracticeMattersPage = ({ basePath = '/practice/matters' }: PracticeMattersPageProps) => {\n  const location = useLocation();\n  const pathSuffix = location.path.startsWith(basePath)\n    ? location.path.slice(basePath.length)\n    : '';\n  const pathSegments = pathSuffix.replace(/^\\/+/, '').split('/').filter(Boolean);\n  const firstSegment = pathSegments[0] ?? '';\n  const secondSegment = pathSegments[1] ?? '';\n  const isCreateRoute = firstSegment === 'new';\n  const isEditRoute = Boolean(firstSegment) && secondSegment === 'edit';\n  const selectedMatterId = firstSegment && firstSegment !== 'activity' && firstSegment !== 'new'\n    ? decodeURIComponent(firstSegment)\n    : null;\n  const conversationBasePath = basePath.endsWith('/matters')\n    ? basePath.replace(/\\/matters$/, '/conversations')\n    : '/practice/conversations';\n  const { activePracticeId, session } = useSessionContext();\n  const { showError } = useToastContext();\n  const { getMembers, fetchMembers } = usePracticeManagement({\n    autoFetchPractices: false,\n    fetchInvitations: false,\n    fetchPracticeDetails: false\n  });\n  const {\n    details: practiceDetails,\n    hasDetails: hasPracticeDetails,\n    fetchDetails: fetchPracticeDetails\n  } = usePracticeDetails(activePracticeId);\n\n  const [matters, setMatters] = useState<BackendMatter[]>([]);\n  const [mattersLoading, setMattersLoading] = useState(false);\n  const [mattersError, setMattersError] = useState<string | null>(null);\n  const [mattersRefreshKey, setMattersRefreshKey] = useState(0);\n  const [mattersPage, setMattersPage] = useState(1);\n  const [mattersHasMore, setMattersHasMore] = useState(true);\n  const [mattersLoadingMore, setMattersLoadingMore] = useState(false);\n  const pageSize = 50;\n  const loadMoreRef = useRef<HTMLDivElement | null>(null);\n  const practiceDetailsRequestedRef = useRef<string | null>(null);\n  const [selectedMatterDetail, setSelectedMatterDetail] = useState<MatterDetail | null>(null);\n  const [detailLoading, setDetailLoading] = useState(false);\n  const [detailError, setDetailError] = useState<string | null>(null);\n  const [activityItems, setActivityItems] = useState<TimelineItem[]>([]);\n  const [noteItems, setNoteItems] = useState<TimelineItem[]>([]);\n  const [activityLoading, setActivityLoading] = useState(false);\n  const [servicesLoading, setServicesLoading] = useState(false);\n  const [timeEntries, setTimeEntries] = useState<TimeEntry[]>([]);\n  const [timeEntriesLoading, setTimeEntriesLoading] = useState(false);\n  const [timeEntriesError, setTimeEntriesError] = useState<string | null>(null);\n  const [timeStats, setTimeStats] = useState<BackendMatterTimeStats | null>(null);\n  const [expenses, setExpenses] = useState<MatterExpense[]>([]);\n  const [expensesLoading, setExpensesLoading] = useState(false);\n  const [expensesError, setExpensesError] = useState<string | null>(null);\n  const [milestones, setMilestones] = useState<MatterDetail['milestones']>([]);\n  const [milestonesLoading, setMilestonesLoading] = useState(false);\n  const [milestonesError, setMilestonesError] = useState<string | null>(null);\n  const [clientOptions, setClientOptions] = useState<MatterOption[]>([]);\n  const [isClientListTruncated, setIsClientListTruncated] = useState(false);\n  const matterContext = useMemo(\n    () => ({\n      title: selectedMatterDetail?.title ?? null,\n      clientName: selectedMatterDetail?.clientName ?? null,\n      practiceArea: selectedMatterDetail?.practiceArea ?? null\n    }),\n    [selectedMatterDetail?.clientName, selectedMatterDetail?.practiceArea, selectedMatterDetail?.title]\n  );\n\n  const isMounted = useRef(true);\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  const [activeTab, setActiveTab] = useState<MatterTabId>('all');\n  const [sortOption, setSortOption] = useState<SortOption>('updated');\n  const [detailTab, setDetailTab] = useState<DetailTabId>('overview');\n  const [isQuickTimeEntryOpen, setIsQuickTimeEntryOpen] = useState(false);\n  const [quickTimeEntryKey, setQuickTimeEntryKey] = useState(0);\n  const refreshRequestIdRef = useRef(0);\n  const createdMatterIdRef = useRef<string | null>(null);\n\n  const refreshMatters = useCallback(() => {\n    setMattersRefreshKey((prev) => prev + 1);\n  }, []);\n\n  const openQuickTimeEntry = () => {\n    setQuickTimeEntryKey((prev) => prev + 1);\n    setIsQuickTimeEntryOpen(true);\n  };\n\n  const handleQuickTimeSubmit = async (values: TimeEntryFormValues) => {\n    if (!activePracticeId || !selectedMatterId) return;\n    try {\n      await createMatterTimeEntry(activePracticeId, selectedMatterId, {\n        start_time: values.startTime,\n        end_time: values.endTime,\n        description: values.description,\n        billable: true\n      });\n      const [entries, stats] = await Promise.all([\n        listMatterTimeEntries(activePracticeId, selectedMatterId),\n        getMatterTimeEntryStats(activePracticeId, selectedMatterId)\n      ]);\n      setTimeEntries(entries.map(toTimeEntry));\n      setTimeStats(stats);\n      setIsQuickTimeEntryOpen(false);\n    } catch (error) {\n      console.error('[PracticeMattersPage] Failed to save quick time entry', error);\n      showError('Could not save time entry', 'Please try again.');\n    }\n  };\n\n  const buildClientOption = useCallback((detail: UserDetailRecord): MatterOption => {\n    const name =\n      detail.user?.name?.trim() ||\n      detail.user?.email?.trim() ||\n      detail.user?.phone?.trim() ||\n      'Unknown Client';\n    return {\n      id: detail.id,\n      name,\n      email: detail.user?.email ?? undefined,\n      role: 'client',\n      status: detail.status\n    };\n  }, []);\n  const clientNameById = useMemo(\n    () => new Map(clientOptions.map((client) => [client.id, client.name])),\n    [clientOptions]\n  );\n  const practiceAreaOptions = useMemo<MatterOption[]>(() => {\n    const services = practiceDetails?.services;\n    if (!Array.isArray(services)) return [];\n    return services\n      .filter((service): service is { id: string; name: string; key?: string } => {\n        if (!service || typeof service !== 'object') return false;\n        if (typeof service.id !== 'string' || !isUuid(service.id)) return false;\n        if (typeof service.name !== 'string' || !service.name.trim()) return false;\n        return true;\n      })\n      .map((service) => ({\n        id: service.id,\n        name: service.name,\n        role: service.key\n      }));\n  }, [practiceDetails?.services]);\n  const assigneeOptions = useMemo<MatterOption[]>(() => {\n    if (!activePracticeId) return [];\n    const members = getMembers(activePracticeId);\n    return members\n      .filter((member) => member.role !== 'member' && member.role !== 'client')\n      .map((member) => ({\n        id: member.userId,\n        name: member.name ?? member.email,\n        email: member.email,\n        image: member.image ?? undefined,\n        role: member.role\n      }));\n  }, [activePracticeId, getMembers]);\n\n  const assigneeNameById = useMemo(() => {\n    return new Map(assigneeOptions.map((assignee) => [assignee.id, assignee.name]));\n  }, [assigneeOptions]);\n\n  const membersById = useMemo(() => {\n    if (!activePracticeId) return new Map<string, { name: string; email?: string | null; image?: string | null }>();\n    const members = getMembers(activePracticeId);\n    return new Map(\n      members.map((member) => [\n        member.userId,\n        { name: member.name ?? '', email: member.email ?? null, image: member.image }\n      ])\n    );\n  }, [activePracticeId, getMembers]);\n\n  const serviceNameById = useMemo(() => {\n    return new Map(practiceAreaOptions.map((service) => [service.id, service.name]));\n  }, [practiceAreaOptions]);\n\n  const resolveTimelinePerson = useCallback(\n    (userId?: string | null): TimelinePerson => {\n      if (!userId) return { name: 'System' };\n      const member = membersById.get(userId);\n      if (member) {\n        const fallbackEmail = member.email ?? '';\n        const sessionName = session?.user?.id === userId ? session?.user?.name?.trim() : '';\n        const preferredName = member.name?.trim() || sessionName || fallbackEmail;\n        const name = preferredName && !isEmailLike(preferredName)\n          ? preferredName\n          : sessionName && !isEmailLike(sessionName)\n            ? sessionName\n            : fallbackEmail || preferredName;\n        return { name: name || `User ${userId.slice(0, 6)}`, imageUrl: member.image ?? null };\n      }\n      const sessionName = session?.user?.id === userId ? session?.user?.name?.trim() : '';\n      if (sessionName && !isEmailLike(sessionName)) {\n        return { name: sessionName, imageUrl: session?.user?.image ?? null };\n      }\n      return { name: `User ${userId.slice(0, 6)}` };\n    },\n    [membersById, session?.user?.id, session?.user?.image, session?.user?.name]\n  );\n\n  const toActivityTimelineItem = useCallback(\n    (activity: BackendMatterActivity, activities: BackendMatterActivity[]): TimelineItem => {\n      const createdAt = activity.created_at ?? new Date().toISOString();\n      const actionKey = activity.action ?? '';\n      const mapped = activityActionMap[actionKey];\n      const type = mapped?.type ?? 'edited';\n      const date = formatRelativeTime(createdAt);\n      const description = activity.description ?? undefined;\n      const person = resolveTimelinePerson(activity.user_id);\n      const metadata = activity.metadata ?? {};\n      const timeEntryDuration = formatDuration(\n        typeof (metadata as Record<string, unknown>).duration === 'number'\n          ? (metadata as Record<string, unknown>).duration as number\n          : null\n      );\n      const timeEntryDescription = typeof (metadata as Record<string, unknown>).description === 'string'\n        ? (metadata as Record<string, unknown>).description as string\n        : undefined;\n      const cleanedDescription = description ? stripActorPrefix(description, person.name) : undefined;\n      let actionMeta = actionKey === 'matter_status_changed'\n        ? buildStatusChangeMeta(metadata as Record<string, unknown>)\n        : null;\n      const action = (() => {\n        if (type === 'commented') return undefined;\n        if (actionKey === 'matter_created') {\n          return buildMatterCreatedLabel(matterContext);\n        }\n        if (actionKey === 'matter_updated') {\n          const fields = extractChangedFields(metadata as Record<string, unknown>);\n          if (fields.length === 1 && fields[0] === 'client') {\n            const changes = (metadata as Record<string, unknown>).changes;\n            if (changes && typeof changes === 'object') {\n              const clientId = (changes as Record<string, unknown>).client_id;\n              if (typeof clientId === 'string' && clientId.trim()) {\n                const clientName = clientNameById.get(clientId);\n                if (clientName) {\n                  return `updated client to ${clientName}.`;\n                }\n              }\n            }\n          }\n          if (fields.length === 1 && fields[0] === 'status') {\n            const statusMeta = findStatusChangeMeta(activity, activities);\n            if (!statusMeta) {\n              console.warn('[PracticeMattersPage] Missing status change metadata for status-only update', activity);\n            } else {\n              actionMeta = statusMeta;\n            }\n            return undefined;\n          }\n          if (fields.length === 1) {\n            return buildSingleFieldUpdateAction(fields[0], metadata as Record<string, unknown>, {\n              clientNameById,\n              serviceNameById,\n              assigneeNameById\n            });\n          }\n          const formatted = formatFieldList(fields);\n          if (formatted) return `updated ${formatted}.`;\n          return cleanedDescription ?? 'updated matter details.';\n        }\n        if (actionKey === 'matter_status_changed') {\n          return resolveStatusChangeLabel(metadata as Record<string, unknown>) ?? 'updated the status.';\n        }\n        if (actionKey.startsWith('time_entry_')) {\n          if (actionKey === 'time_entry_updated') {\n            const fields = extractChangedFields(metadata as Record<string, unknown>);\n            const formatted = formatFieldList(fields);\n            if (formatted) return `updated ${formatted}.`;\n          }\n          if (actionKey === 'time_entry_deleted') {\n            return cleanedDescription ?? 'deleted a time entry.';\n          }\n          if (timeEntryDuration) {\n            const verb = actionKey === 'time_entry_updated' ? 'updated' : 'logged';\n            return timeEntryDescription\n              ? `${verb} ${timeEntryDuration} for ${timeEntryDescription}.`\n              : `${verb} ${timeEntryDuration}.`;\n          }\n          return cleanedDescription ?? 'logged time entry.';\n        }\n        if (actionKey.startsWith('milestone_')) {\n          if (actionKey === 'milestone_updated') {\n            const fields = extractChangedFields(metadata as Record<string, unknown>);\n            const formatted = formatFieldList(fields);\n            if (formatted) return `updated ${formatted}.`;\n          }\n          if (cleanedDescription) {\n            return cleanedDescription;\n          }\n          return actionKey === 'milestone_completed'\n            ? 'completed a milestone.'\n            : actionKey === 'milestone_deleted'\n              ? 'deleted a milestone.'\n              : actionKey === 'milestone_updated'\n                ? 'updated a milestone.'\n                : 'added a milestone.';\n        }\n        if (actionKey === 'expense_updated' || actionKey === 'note_updated') {\n          const fields = extractChangedFields(metadata as Record<string, unknown>);\n          const formatted = formatFieldList(fields);\n          if (formatted) return `updated ${formatted}.`;\n        }\n        return mapped?.label ?? cleanedDescription ?? humanizeAction(actionKey);\n      })();\n      return {\n        id: activity.id,\n        type,\n        person,\n        date: date || 'Just now',\n        dateTime: createdAt,\n        comment: type === 'commented' ? description : undefined,\n        action,\n        actionMeta: actionMeta ?? undefined\n      };\n    },\n    [assigneeNameById, clientNameById, matterContext, resolveTimelinePerson, serviceNameById]\n  );\n\n  const toNoteTimelineItem = useCallback(\n    (note: BackendMatterNote): TimelineItem => {\n      const createdAt = note.created_at ?? new Date().toISOString();\n      const person = resolveTimelinePerson(note.user_id);\n      const date = formatRelativeTime(createdAt);\n      return {\n        id: `note-${note.id}`,\n        type: 'commented',\n        person,\n        date: date || 'Just now',\n        dateTime: createdAt,\n        comment: note.content ?? ''\n      };\n    },\n    [resolveTimelinePerson]\n  );\n\n  useEffect(() => {\n    if (!activePracticeId) return;\n    void fetchMembers(activePracticeId, { force: false });\n  }, [activePracticeId, fetchMembers]);\n\n  useEffect(() => {\n    if (!activePracticeId) {\n      setClientOptions([]);\n      setIsClientListTruncated(false);\n      return;\n    }\n\n    let cancelled = false;\n    const controller = new AbortController();\n\n    const fetchAllClients = async () => {\n      setIsClientListTruncated(false);\n      let offset = 0;\n      const limit = 100;\n      const allClients: MatterOption[] = [];\n      let hasMore = true;\n\n      let lastTotal = 0;\n      try {\n        const MAX_PAGES = 100;\n        let iterations = 0;\n        while (hasMore && !cancelled && !controller.signal.aborted && iterations < MAX_PAGES) {\n          iterations++;\n          const response = await listUserDetails(activePracticeId, {\n            limit,\n            offset,\n            signal: controller.signal\n          });\n          if (cancelled || controller.signal.aborted) break;\n\n          const options = response.data.map(buildClientOption);\n          allClients.push(...options);\n\n          // Determine if we should fetch more\n          const count = response.data.length;\n          lastTotal = response.total ?? 0;\n\n          if (lastTotal > 0) {\n            hasMore = allClients.length < lastTotal;\n          } else {\n            hasMore = count === limit;\n          }\n\n          if (hasMore) {\n            offset += limit;\n          }\n        }\n\n        if (!cancelled && !controller.signal.aborted) {\n          setClientOptions(allClients);\n          // Detect truncation if we broke loop prematurely or if total exceeds the amount we fetched\n          const isTruncated = iterations >= MAX_PAGES || (lastTotal > allClients.length);\n          setIsClientListTruncated(isTruncated);\n        }\n      } catch (error) {\n        if (controller.signal.aborted || (error instanceof DOMException && error.name === 'AbortError')) {\n          return;\n        }\n        if (!cancelled) {\n          console.error('[PracticeMattersPage] Failed to load clients', error);\n          setClientOptions(allClients); // Show what we have\n          setIsClientListTruncated(true);\n          showError('Failed to load full client list', 'Some clients may be missing.');\n        }\n      }\n    };\n\n    void fetchAllClients();\n\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [activePracticeId, buildClientOption, showError]);\n\n  useEffect(() => {\n    if (!activePracticeId) return;\n    if (practiceDetailsRequestedRef.current === activePracticeId) return;\n    if (practiceDetails && hasPracticeDetails) {\n      practiceDetailsRequestedRef.current = activePracticeId;\n      return;\n    }\n    practiceDetailsRequestedRef.current = activePracticeId;\n    setServicesLoading(true);\n    fetchPracticeDetails()\n      .catch((error) => {\n        console.warn('[PracticeMattersPage] Failed to load practice services', error);\n      })\n      .finally(() => {\n        setServicesLoading(false);\n      });\n  }, [activePracticeId, fetchPracticeDetails, hasPracticeDetails, practiceDetails]);\n\n  useEffect(() => {\n    if (!activePracticeId) {\n      setMatters([]);\n      setMattersError(null);\n      setMattersLoading(false);\n      setMattersHasMore(true);\n      setMattersPage(1);\n      return;\n    }\n\n    const controller = new AbortController();\n    setMattersLoading(true);\n    setMattersError(null);\n    setMattersHasMore(true);\n    setMattersPage(1);\n\n    listMatters(activePracticeId, { signal: controller.signal, page: 1, limit: pageSize })\n      .then((items) => {\n        setMatters(items);\n        setMattersHasMore(items.length === pageSize);\n      })\n      .catch((error: unknown) => {\n        if ((error as DOMException).name === 'AbortError') return;\n        const message = error instanceof Error ? error.message : 'Failed to load matters';\n        setMattersError(message);\n      })\n      .finally(() => {\n        setMattersLoading(false);\n      });\n\n    return () => controller.abort();\n  }, [activePracticeId, mattersRefreshKey, pageSize]);\n\n  const loadMoreMatters = useCallback(async () => {\n    if (!activePracticeId || mattersLoadingMore || mattersLoading || !mattersHasMore) {\n      return;\n    }\n    const nextPage = mattersPage + 1;\n    setMattersLoadingMore(true);\n    try {\n      const items = await listMatters(activePracticeId, { page: nextPage, limit: pageSize });\n      setMatters((prev) => [...prev, ...items]);\n      setMattersPage(nextPage);\n      setMattersHasMore(items.length === pageSize);\n    } catch (error) {\n      console.error('[PracticeMattersPage] Failed to load more matters', error);\n      showError('Could not load more matters', 'Please try again.');\n    } finally {\n      setMattersLoadingMore(false);\n    }\n  }, [activePracticeId, mattersHasMore, mattersLoading, mattersLoadingMore, mattersPage, pageSize, showError]);\n\n  useEffect(() => {\n    const target = loadMoreRef.current;\n    if (!target) return;\n    if (!mattersHasMore || mattersLoading || mattersLoadingMore) return;\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        const entry = entries[0];\n        if (entry?.isIntersecting) {\n          void loadMoreMatters();\n        }\n      },\n      { rootMargin: '200px' }\n    );\n\n    observer.observe(target);\n    return () => observer.disconnect();\n  }, [loadMoreMatters, mattersHasMore, mattersLoading, mattersLoadingMore]);\n\n  useEffect(() => {\n    if (!activePracticeId || !selectedMatterId) {\n      setSelectedMatterDetail(null);\n      setDetailError(null);\n      setDetailLoading(false);\n      return;\n    }\n\n    const controller = new AbortController();\n    setDetailLoading(true);\n    setDetailError(null);\n\n    getMatter(activePracticeId, selectedMatterId, { signal: controller.signal })\n      .then((matter) => {\n        setSelectedMatterDetail(\n          matter ? toMatterDetail(matter, { clientNameById, serviceNameById }) : null\n        );\n      })\n      .catch((error: unknown) => {\n        if ((error as DOMException).name === 'AbortError') return;\n        const message = error instanceof Error ? error.message : 'Failed to load matter';\n        setDetailError(message);\n      })\n      .finally(() => {\n        setDetailLoading(false);\n      });\n\n    return () => controller.abort();\n  }, [activePracticeId, clientNameById, selectedMatterId, serviceNameById]);\n\n  useEffect(() => {\n    if (!activePracticeId || !selectedMatterId) {\n      setActivityItems([]);\n      setActivityLoading(false);\n      return;\n    }\n\n    const controller = new AbortController();\n    setActivityLoading(true);\n\n    getMatterActivity(activePracticeId, selectedMatterId, { signal: controller.signal })\n      .then((items) => {\n        const nextItems = items\n          .filter((item) => !String(item.action ?? '').startsWith('note_'))\n          .slice()\n          .sort((a, b) => {\n            const getTimestamp = (item: typeof a) => {\n              if (!item.created_at) {\n                console.warn('[PracticeMattersPage] Item missing created_at', { id: item.id, action: item.action });\n                return 0;\n              }\n              const time = new Date(item.created_at).getTime();\n              if (Number.isNaN(time)) {\n                console.warn('[PracticeMattersPage] Item has invalid created_at', { id: item.id, action: item.action, value: item.created_at });\n                return 0;\n              }\n              return time;\n            };\n\n            const aTime = getTimestamp(a);\n            const bTime = getTimestamp(b);\n            return aTime - bTime;\n          })\n          .map((item) => toActivityTimelineItem(item, items));\n        setActivityItems(nextItems);\n      })\n      .catch((error: unknown) => {\n        if ((error as DOMException).name === 'AbortError') return;\n        console.warn('[PracticeMattersPage] Failed to load activity', error);\n        setActivityItems([]);\n      })\n      .finally(() => {\n        setActivityLoading(false);\n      });\n\n    return () => controller.abort();\n  }, [activePracticeId, selectedMatterId, toActivityTimelineItem]);\n\n  useEffect(() => {\n    if (!activePracticeId || !selectedMatterId) {\n      setNoteItems([]);\n      return;\n    }\n\n    const controller = new AbortController();\n    listMatterNotes(activePracticeId, selectedMatterId, { signal: controller.signal })\n      .then((items) => {\n        const nextNotes = items\n          .slice()\n          .sort((a, b) => {\n            const getTimestamp = (item: typeof a) => {\n              if (!item.created_at) return 0;\n              const time = new Date(item.created_at).getTime();\n              return Number.isNaN(time) ? 0 : time;\n            };\n            return getTimestamp(a) - getTimestamp(b);\n          })\n          .map(toNoteTimelineItem);\n        setNoteItems(nextNotes);\n      })\n      .catch((error: unknown) => {\n        if ((error as DOMException).name === 'AbortError') return;\n        console.warn('[PracticeMattersPage] Failed to load notes for timeline', error);\n        setNoteItems([]);\n      });\n\n    return () => controller.abort();\n  }, [activePracticeId, selectedMatterId, toNoteTimelineItem]);\n\n  useEffect(() => {\n    if (!activePracticeId || !selectedMatterId) {\n      setTimeEntries([]);\n      setTimeEntriesError(null);\n      setTimeEntriesLoading(false);\n      setTimeStats(null);\n      return;\n    }\n\n    const controller = new AbortController();\n    setTimeEntriesLoading(true);\n    setTimeEntriesError(null);\n\n    Promise.all([\n      listMatterTimeEntries(activePracticeId, selectedMatterId, { signal: controller.signal }),\n      getMatterTimeEntryStats(activePracticeId, selectedMatterId, { signal: controller.signal })\n    ])\n      .then(([entries, stats]) => {\n        setTimeEntries(entries.map(toTimeEntry));\n        setTimeStats(stats);\n      })\n      .catch((error: unknown) => {\n        if ((error as DOMException).name === 'AbortError') return;\n        const message = error instanceof Error ? error.message : 'Failed to load time entries';\n        setTimeEntriesError(message);\n      })\n      .finally(() => {\n        setTimeEntriesLoading(false);\n      });\n\n    return () => controller.abort();\n  }, [activePracticeId, selectedMatterId]);\n\n  useEffect(() => {\n    if (!activePracticeId || !selectedMatterId) {\n      setExpenses([]);\n      setExpensesError(null);\n      setExpensesLoading(false);\n      return;\n    }\n\n    const controller = new AbortController();\n    setExpensesLoading(true);\n    setExpensesError(null);\n\n    listMatterExpenses(activePracticeId, selectedMatterId, { signal: controller.signal })\n      .then((items) => {\n        setExpenses(items.map(toExpense));\n      })\n      .catch((error: unknown) => {\n        if ((error as DOMException).name === 'AbortError') return;\n        const message = error instanceof Error ? error.message : 'Failed to load expenses';\n        setExpensesError(message);\n      })\n      .finally(() => {\n        setExpensesLoading(false);\n      });\n\n    return () => controller.abort();\n  }, [activePracticeId, selectedMatterId]);\n\n  useEffect(() => {\n    if (!activePracticeId || !selectedMatterId) {\n      setMilestones([]);\n      setMilestonesError(null);\n      setMilestonesLoading(false);\n      return;\n    }\n\n    const controller = new AbortController();\n    setMilestonesLoading(true);\n    setMilestonesError(null);\n\n    listMatterMilestones(activePracticeId, selectedMatterId, { signal: controller.signal })\n      .then((items) => {\n        const mapped = items.map(toMilestone);\n        setMilestones(mapped);\n        setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: mapped } : prev));\n      })\n      .catch((error: unknown) => {\n        if ((error as DOMException).name === 'AbortError') return;\n        console.warn('[PracticeMattersPage] Failed to load milestones', error);\n        const message = error instanceof Error ? error.message : 'Failed to load milestones';\n        setMilestonesError(message);\n      })\n      .finally(() => {\n        setMilestonesLoading(false);\n      });\n\n    return () => controller.abort();\n  }, [activePracticeId, selectedMatterId]);\n\n  const handleCreateMilestone = useCallback(async (values: { description: string; amount: MajorAmount; dueDate: string; status?: string }) => {\n    if (!activePracticeId || !selectedMatterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n\n    const created = await createMatterMilestone(activePracticeId, selectedMatterId, {\n      description: values.description,\n      amount: values.amount,\n      due_date: values.dueDate,\n      status: values.status ?? 'pending',\n      order: milestones.length + 1\n    });\n\n    if (created) {\n      const next = [...milestones, toMilestone(created)];\n      setMilestones(next);\n      setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: next } : prev));\n    } else {\n      const refreshed = await listMatterMilestones(activePracticeId, selectedMatterId);\n      const mapped = refreshed.map(toMilestone);\n      setMilestones(mapped);\n      setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: mapped } : prev));\n    }\n  }, [activePracticeId, milestones, selectedMatterId]);\n\n  const handleUpdateMilestone = useCallback(async (\n    milestone: MatterDetail['milestones'][number],\n    values: { description: string; amount: MajorAmount; dueDate: string; status?: string }\n  ) => {\n    if (!activePracticeId || !selectedMatterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n    if (!milestone.id) {\n      throw new Error('Milestone ID is required');\n    }\n    try {\n      const updated = await updateMatterMilestone(activePracticeId, selectedMatterId, milestone.id, {\n        description: values.description,\n        amount: values.amount,\n        due_date: values.dueDate,\n        status: values.status ?? 'pending'\n      });\n      if (updated) {\n        const next = milestones.map((item) => (item.id === milestone.id ? toMilestone(updated) : item));\n        setMilestones(next);\n        setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: next } : prev));\n        setMilestonesError(null);\n        return;\n      }\n      const refreshed = await listMatterMilestones(activePracticeId, selectedMatterId);\n      const mapped = refreshed.map(toMilestone);\n      setMilestones(mapped);\n      setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: mapped } : prev));\n      setMilestonesError(null);\n    } catch (error) {\n      console.error('[PracticeMattersPage] Failed to update milestone', error);\n      showError('Could not update milestone', 'Please try again.');\n      setMilestonesError('Unable to update milestone.');\n      try {\n        const refreshed = await listMatterMilestones(activePracticeId, selectedMatterId);\n        const mapped = refreshed.map(toMilestone);\n        setMilestones(mapped);\n        setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: mapped } : prev));\n      } catch (refreshError) {\n        console.error('[PracticeMattersPage] Failed to refresh milestones', refreshError);\n      }\n      throw error;\n    }\n  }, [activePracticeId, milestones, selectedMatterId, showError]);\n\n  const handleDeleteMilestone = useCallback(async (milestone: MatterDetail['milestones'][number]) => {\n    if (!activePracticeId || !selectedMatterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n    if (!milestone.id) {\n      throw new Error('Milestone ID is required');\n    }\n    try {\n      await deleteMatterMilestone(activePracticeId, selectedMatterId, milestone.id);\n      const next = milestones.filter((item) => item.id !== milestone.id);\n      setMilestones(next);\n      setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: next } : prev));\n      setMilestonesError(null);\n    } catch (error) {\n      console.error('[PracticeMattersPage] Failed to delete milestone', error);\n      showError('Could not delete milestone', 'Please try again.');\n      setMilestonesError('Unable to delete milestone.');\n      try {\n        const refreshed = await listMatterMilestones(activePracticeId, selectedMatterId);\n        const mapped = refreshed.map(toMilestone);\n        setMilestones(mapped);\n        setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: mapped } : prev));\n        setMilestonesError(null);\n      } catch (refreshError) {\n        console.error('[PracticeMattersPage] Failed to refresh milestones', refreshError);\n      }\n      throw error;\n    }\n  }, [activePracticeId, milestones, selectedMatterId, showError]);\n\n  const handleReorderMilestones = useCallback(async (nextOrder: MatterDetail['milestones']) => {\n    if (!activePracticeId || !selectedMatterId) {\n      return;\n    }\n\n    const previousMilestones = milestones;\n    setMilestones(nextOrder);\n    setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: nextOrder } : prev));\n\n    const payload = nextOrder\n      .map((milestone, index) => ({\n        id: milestone.id ?? '',\n        order: index + 1\n      }))\n      .filter((item) => item.id);\n\n    if (payload.length === 0) {\n      return;\n    }\n\n    try {\n      await reorderMatterMilestones(activePracticeId, selectedMatterId, payload);\n    } catch (error) {\n      console.error('[PracticeMattersPage] Failed to reorder milestones', error);\n      setMilestones(previousMilestones);\n      setSelectedMatterDetail((prev) => (prev ? { ...prev, milestones: previousMilestones } : prev));\n      showError('Could not reorder milestones', 'Please try again.');\n    }\n  }, [activePracticeId, milestones, selectedMatterId, showError]);\n\n  const handleCreateNote = useCallback(async (values: { content: string }) => {\n    if (!activePracticeId || !selectedMatterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n    const created = await createMatterNote(activePracticeId, selectedMatterId, values.content);\n    if (created) {\n      const newItem = toNoteTimelineItem(created);\n      setNoteItems((prev) => [...prev, newItem]);\n    }\n  }, [activePracticeId, selectedMatterId, toNoteTimelineItem]);\n\n  const handleCreateExpense = useCallback(async (values: { description: string; amount: MajorAmount | undefined; date: string; billable: boolean }) => {\n    if (!activePracticeId || !selectedMatterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n    if (values.amount === undefined) {\n      throw new Error('Amount is required');\n    }\n    const created = await createMatterExpense(activePracticeId, selectedMatterId, {\n      description: values.description,\n      amount: values.amount,\n      date: values.date,\n      billable: values.billable\n    });\n    if (created) {\n      setExpenses((prev) => [toExpense(created), ...prev]);\n    } else {\n      const updated = await listMatterExpenses(activePracticeId, selectedMatterId);\n      setExpenses(updated.map(toExpense));\n    }\n  }, [activePracticeId, selectedMatterId]);\n\n  const handleUpdateExpense = useCallback(async (expense: MatterExpense, values: { description: string; amount: MajorAmount | undefined; date: string; billable: boolean }) => {\n    if (!activePracticeId || !selectedMatterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n    if (values.amount === undefined) {\n      throw new Error('Amount is required');\n    }\n    try {\n      const updated = await updateMatterExpense(activePracticeId, selectedMatterId, expense.id, {\n        description: values.description,\n        amount: values.amount,\n        date: values.date,\n        billable: values.billable\n      });\n      if (updated) {\n        setExpenses((prev) => prev.map((item) => (item.id === expense.id ? toExpense(updated) : item)));\n        setExpensesError(null);\n        return;\n      }\n      const refreshed = await listMatterExpenses(activePracticeId, selectedMatterId);\n      setExpenses(refreshed.map(toExpense));\n      setExpensesError(null);\n    } catch (error) {\n      console.error('[PracticeMattersPage] Failed to update expense', error);\n      showError('Could not update expense', 'Please try again.');\n      setExpensesError('Unable to update expense.');\n      try {\n        const refreshed = await listMatterExpenses(activePracticeId, selectedMatterId);\n        setExpenses(refreshed.map(toExpense));\n      } catch (refreshError) {\n        console.error('[PracticeMattersPage] Failed to refresh expenses', refreshError);\n      }\n      throw error;\n    }\n  }, [activePracticeId, selectedMatterId, showError]);\n\n  const handleDeleteExpense = useCallback(async (expense: MatterExpense) => {\n    if (!activePracticeId || !selectedMatterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n    try {\n      await deleteMatterExpense(activePracticeId, selectedMatterId, expense.id);\n      setExpenses((prev) => prev.filter((item) => item.id !== expense.id));\n      setExpensesError(null);\n    } catch (error) {\n      console.error('[PracticeMattersPage] Failed to delete expense', error);\n      showError('Could not delete expense', 'Please try again.');\n      setExpensesError('Unable to delete expense.');\n      try {\n        const refreshed = await listMatterExpenses(activePracticeId, selectedMatterId);\n        setExpenses(refreshed.map(toExpense));\n        setExpensesError(null);\n      } catch (refreshError) {\n        console.error('[PracticeMattersPage] Failed to refresh expenses', refreshError);\n      }\n      throw error;\n    }\n  }, [activePracticeId, selectedMatterId, showError]);\n\n  const handleSaveTimeEntry = useCallback(async (values: TimeEntryFormValues, existing?: TimeEntry | null) => {\n    if (!activePracticeId || !selectedMatterId) return;\n    try {\n      if (existing?.id) {\n        await updateMatterTimeEntry(activePracticeId, selectedMatterId, existing.id, {\n          start_time: values.startTime,\n          end_time: values.endTime,\n          description: values.description,\n          billable: true\n        });\n      } else {\n        await createMatterTimeEntry(activePracticeId, selectedMatterId, {\n          start_time: values.startTime,\n          end_time: values.endTime,\n          description: values.description,\n          billable: true\n        });\n      }\n      const [entries, stats] = await Promise.all([\n        listMatterTimeEntries(activePracticeId, selectedMatterId),\n        getMatterTimeEntryStats(activePracticeId, selectedMatterId)\n      ]);\n      setTimeEntries(entries.map(toTimeEntry));\n      setTimeStats(stats);\n    } catch (error) {\n      console.error('[PracticeMattersPage] Failed to save time entry', error);\n      showError('Could not save time entry', 'Please try again.');\n    }\n  }, [activePracticeId, selectedMatterId, showError]);\n\n  const handleDeleteTimeEntry = useCallback(async (entry: TimeEntry) => {\n    if (!activePracticeId || !selectedMatterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n    try {\n      await deleteMatterTimeEntry(activePracticeId, selectedMatterId, entry.id);\n      const [entries, stats] = await Promise.all([\n        listMatterTimeEntries(activePracticeId, selectedMatterId),\n        getMatterTimeEntryStats(activePracticeId, selectedMatterId)\n      ]);\n      setTimeEntries(entries.map(toTimeEntry));\n      setTimeStats(stats);\n    } catch (error) {\n      console.error('[PracticeMattersPage] Failed to delete time entry', error);\n      showError('Could not delete time entry', 'Please try again.');\n    }\n  }, [activePracticeId, selectedMatterId, showError]);\n\n  const handleCreateMatter = useCallback(async (values: MatterFormState) => {\n    if (!activePracticeId) {\n      throw new Error('Practice ID is required to create a matter.');\n    }\n\n    if (values.clientId && !isUuid(values.clientId)) {\n      throw new Error(`Invalid client_id UUID: \"${values.clientId}\"`);\n    }\n    if (values.practiceAreaId && !isUuid(values.practiceAreaId)) {\n      throw new Error(`Invalid practice_service_id UUID: \"${values.practiceAreaId}\"`);\n    }\n\n    const payload: Record<string, unknown> = {\n      title: values.title.trim(),\n      client_id: values.clientId || undefined,\n      description: values.description || undefined,\n      case_number: values.caseNumber || undefined,\n      matter_type: values.matterType || undefined,\n      urgency: values.urgency || undefined,\n      responsible_attorney_id: values.responsibleAttorneyId || undefined,\n      originating_attorney_id: values.originatingAttorneyId || undefined,\n      court: values.court || undefined,\n      judge: values.judge || undefined,\n      opposing_party: values.opposingParty || undefined,\n      opposing_counsel: values.opposingCounsel || undefined,\n      open_date: values.openDate || undefined,\n      close_date: values.closeDate || undefined,\n      billing_type: values.billingType,\n      total_fixed_price: values.totalFixedPrice ?? undefined,\n      contingency_percentage: values.contingencyPercent ?? undefined,\n      settlement_amount: values.settlementAmount ?? undefined,\n      practice_service_id: values.practiceAreaId || undefined,\n      admin_hourly_rate: values.adminHourlyRate ?? undefined,\n      attorney_hourly_rate: values.attorneyHourlyRate ?? undefined,\n      payment_frequency: values.paymentFrequency ?? undefined,\n      status: mapStatusToBackend(values.status),\n      assignee_ids: values.assigneeIds.length > 0 ? values.assigneeIds : undefined,\n      milestones: values.milestones.map((milestone, index) => ({\n        description: milestone.description,\n        amount: milestone.amount ?? 0,\n        due_date: milestone.dueDate,\n        order: index + 1\n      }))\n    };\n\n    const created = await createMatter(activePracticeId, prunePayload(payload));\n    refreshMatters();\n    createdMatterIdRef.current = created?.id ?? null;\n  }, [activePracticeId, refreshMatters]);\n\n  const refreshSelectedMatter = useCallback(async () => {\n    if (!activePracticeId || !selectedMatterId) return;\n    const requestId = ++refreshRequestIdRef.current;\n    \n    try {\n      const activities = await getMatterActivity(activePracticeId, selectedMatterId);\n      if (requestId !== refreshRequestIdRef.current || !isMounted.current) return;\n      \n      const nextItems = (activities ?? [])\n        .filter((item) => !String(item.action ?? '').startsWith('note_'))\n        .slice()\n        .sort((a, b) => {\n          const getTimestamp = (d?: string | null) => {\n             const t = d ? new Date(d).getTime() : 0;\n             return Number.isNaN(t) ? 0 : t;\n          };\n          return getTimestamp(a.created_at) - getTimestamp(b.created_at);\n        })\n        .map((item) => toActivityTimelineItem(item, activities ?? []));\n      \n      setActivityItems(nextItems);\n    } catch (error) {\n      console.warn('[PracticeMattersPage] Failed to refresh activity', error);\n    }\n\n    try {\n      const refreshed = await getMatter(activePracticeId, selectedMatterId);\n      if (requestId !== refreshRequestIdRef.current || !isMounted.current) return;\n\n      if (refreshed) {\n        setSelectedMatterDetail(\n          toMatterDetail(refreshed, { clientNameById, serviceNameById })\n        );\n      }\n    } catch (error) {\n      console.warn('[PracticeMattersPage] Failed to refresh matter detail', error);\n    }\n  }, [activePracticeId, selectedMatterId, clientNameById, serviceNameById, toActivityTimelineItem]);\n\n  const handleUpdateMatter = useCallback(async (values: MatterFormState) => {\n    if (!activePracticeId || !selectedMatterId) return;\n\n    if (values.clientId && !isUuid(values.clientId)) {\n      throw new Error(`Invalid client_id UUID: \"${values.clientId}\"`);\n    }\n    if (values.practiceAreaId && !isUuid(values.practiceAreaId)) {\n      throw new Error(`Invalid practice_service_id UUID: \"${values.practiceAreaId}\"`);\n    }\n\n    const payload: Partial<BackendMatter> = {\n      title: values.title.trim(),\n      description: values.description !== undefined ? values.description.trim() : undefined,\n      client_id: values.clientId === '' ? null : (values.clientId || undefined),\n      practice_service_id: values.practiceAreaId === '' ? null : (values.practiceAreaId || undefined),\n      case_number: values.caseNumber === '' ? null : (values.caseNumber || undefined),\n      matter_type: values.matterType === '' ? null : (values.matterType || undefined),\n      urgency: values.urgency === '' ? null : (values.urgency || undefined),\n      responsible_attorney_id: values.responsibleAttorneyId === ''\n        ? null\n        : values.responsibleAttorneyId && isUuid(values.responsibleAttorneyId)\n          ? values.responsibleAttorneyId\n          : undefined,\n      originating_attorney_id: values.originatingAttorneyId === ''\n        ? null\n        : values.originatingAttorneyId && isUuid(values.originatingAttorneyId)\n          ? values.originatingAttorneyId\n          : undefined,\n      court: values.court === '' ? null : (values.court || undefined),\n      judge: values.judge === '' ? null : (values.judge || undefined),\n      opposing_party: values.opposingParty === '' ? null : (values.opposingParty || undefined),\n      opposing_counsel: values.opposingCounsel === '' ? null : (values.opposingCounsel || undefined),\n      open_date: values.openDate === '' ? null : (values.openDate || undefined),\n      close_date: values.closeDate === '' ? null : (values.closeDate || undefined),\n      admin_hourly_rate: values.adminHourlyRate ?? undefined,\n      attorney_hourly_rate: values.attorneyHourlyRate ?? undefined,\n      payment_frequency: values.paymentFrequency ?? undefined,\n      settlement_amount: values.settlementAmount ?? undefined,\n      status: values.status !== selectedMatterDetail?.status ? mapStatusToBackend(values.status) : undefined,\n      assignee_ids: values.assigneeIds.length > 0 ? values.assigneeIds : null\n    };\n\n    await updateMatter(activePracticeId, selectedMatterId, prunePayload(payload));\n    refreshMatters();\n    await refreshSelectedMatter();\n  }, [\n    activePracticeId,\n    refreshMatters,\n    selectedMatterDetail?.status,\n    selectedMatterId,\n    refreshSelectedMatter\n  ]);\n\n  const matterEntries = useMemo(() => {\n    return matters.map((matter) => {\n      const summary = toMatterSummary(matter, { clientNameById, serviceNameById });\n      return {\n        summary: {\n          ...summary\n        },\n        assigneeIds: extractAssigneeIds(matter)\n      };\n    });\n  }, [clientNameById, matters, serviceNameById]);\n\n  const matterSummaries = useMemo(() => matterEntries.map((entry) => entry.summary), [matterEntries]);\n\n  const counts = useMemo(() => {\n    const countsByStatus = MATTER_WORKFLOW_STATUSES.reduce<Record<MatterStatus, number>>((acc, status) => {\n      acc[status] = 0;\n      return acc;\n    }, {} as Record<MatterStatus, number>);\n    for (const matter of matterSummaries) {\n      countsByStatus[matter.status] = (countsByStatus[matter.status] ?? 0) + 1;\n    }\n    const all = Object.values(countsByStatus).reduce((sum, value) => sum + value, 0);\n    const closed = Object.entries(countsByStatus)\n      .filter(([status]) => isClosedStatus(status as MatterStatus))\n      .reduce((sum, [, value]) => sum + value, 0);\n    return {\n      all,\n      closed,\n      open: all - closed\n    };\n  }, [matterSummaries]);\n\n  const tabs = useMemo(() => buildTabs(counts), [counts]);\n\n  const filteredMatters = useMemo(() => {\n    if (activeTab === 'all') return matterEntries;\n    if (activeTab === 'open') {\n      return matterEntries.filter((entry) => !isClosedStatus(entry.summary.status));\n    }\n    return matterEntries.filter((entry) => isClosedStatus(entry.summary.status));\n  }, [activeTab, matterEntries]);\n\n  const sortedMatters = useMemo(() => {\n    const matters = [...filteredMatters];\n    if (sortOption === 'title') {\n      return matters.sort((a, b) => a.summary.title.localeCompare(b.summary.title));\n    }\n    if (sortOption === 'status') {\n      return matters.sort((a, b) => statusOrder[a.summary.status] - statusOrder[b.summary.status]);\n    }\n    if (sortOption === 'client') {\n      return matters.sort((a, b) => a.summary.clientName.localeCompare(b.summary.clientName));\n    }\n    if (sortOption === 'practice_area') {\n      return matters.sort((a, b) => (a.summary.practiceArea ?? '').localeCompare(b.summary.practiceArea ?? ''));\n    }\n    if (sortOption === 'assigned') {\n      return matters.sort((a, b) => {\n        const aAssigneeId = a.assigneeIds?.[0] ?? '';\n        const bAssigneeId = b.assigneeIds?.[0] ?? '';\n        const aAssignee = aAssigneeId ? assigneeNameById.get(aAssigneeId) ?? '' : '';\n        const bAssignee = bAssigneeId ? assigneeNameById.get(bAssigneeId) ?? '' : '';\n        return aAssignee.localeCompare(bAssignee);\n      });\n    }\n    return matters.sort((a, b) => new Date(b.summary.updatedAt).getTime() - new Date(a.summary.updatedAt).getTime());\n  }, [assigneeNameById, filteredMatters, sortOption]);\n\n  const sortedMatterSummaries = useMemo(() => sortedMatters.map((entry) => entry.summary), [sortedMatters]);\n\n  const selectedMatterSummary = useMemo(() => (\n    selectedMatterId ? matterSummaries.find((matter) => matter.id === selectedMatterId) ?? null : null\n  ), [matterSummaries, selectedMatterId]);\n  const resolvedSelectedMatter = selectedMatterDetail ?? selectedMatterSummary;\n  const timelineItems = useMemo(() => {\n    const combined = [...activityItems, ...noteItems];\n    return combined.sort((a, b) => {\n      const getTimestamp = (d?: string | null) => {\n        const t = d ? new Date(d).getTime() : 0;\n        return Number.isFinite(t) ? t : 0;\n      };\n      const aTime = getTimestamp(a.dateTime);\n      const bTime = getTimestamp(b.dateTime);\n      return bTime - aTime;\n    });\n  }, [activityItems, noteItems]);\n\n  const debouncedUpdateMatter = useMemo(\n    () => debounce((values: MatterFormState) => handleUpdateMatter(values), 1000),\n    [handleUpdateMatter]\n  );\n\n  useEffect(() => {\n    return () => debouncedUpdateMatter.cancel();\n  }, [debouncedUpdateMatter]);\n\n  const activeTabLabel = TAB_HEADINGS[activeTab] ?? 'All';\n  const headerMeta = useMemo(() => {\n    if (!resolvedSelectedMatter) return null;\n\n    const detail = selectedMatterDetail;\n    const clientIds = detail \n      ? [detail.clientId, ...((detail as { clientIds?: string[] }).clientIds ?? [])].filter(Boolean) as string[]\n      : [];\n    \n    const clientEntries = clientIds.map((id) => {\n      const option = clientOptions.find((opt) => opt.id === id);\n      return {\n        id,\n        name: option?.name ?? resolveOptionLabel(clientOptions, id, resolveClientLabel(id)),\n        status: option?.status,\n        location: option?.location\n      };\n    });\n    \n    if (clientEntries.length === 0 && resolvedSelectedMatter.clientName) {\n      clientEntries.push({ \n        id: 'client-name-fallback', \n        name: resolvedSelectedMatter.clientName,\n        status: undefined,\n        location: undefined\n      });\n    }\n\n    const assigneeNames = detail?.assigneeIds\n      .map((id) => resolveOptionLabel(assigneeOptions, id, `User ${id.slice(0, 6)}`))\n      .filter(Boolean) ?? [];\n\n    const billingLabel = detail?.billingType\n      ? detail.billingType.replace(/_/g, ' ').replace(/^\\w/, (char) => char.toUpperCase())\n      : '';\n\n    const createdLabel = formatLongDate(resolvedSelectedMatter.createdAt);\n\n    return {\n      description: detail?.description,\n      clientEntries,\n      assigneeNames,\n      billingLabel,\n      createdLabel\n    };\n  }, [resolvedSelectedMatter, selectedMatterDetail, clientOptions, assigneeOptions]);\n\n\n  if (isCreateRoute) {\n    return (\n      <Page className=\"min-h-full\">\n        <div className=\"max-w-6xl mx-auto flex flex-col gap-6\">\n          <Breadcrumbs\n            items={[\n              { label: 'Matters', href: basePath },\n              { label: 'Create matter' }\n            ]}\n            onNavigate={(href) => location.route(href)}\n          />\n          <PageHeader\n            title=\"Create Matter\"\n            subtitle=\"Capture matter details, billing structure, and assignment in one place.\"\n            actions={(\n              <Button size=\"sm\" variant=\"secondary\" onClick={() => location.route(basePath)}>\n                Back to matters\n              </Button>\n            )}\n          />\n          <MatterCreateForm\n            onClose={() => {\n              const createdMatterId = createdMatterIdRef.current;\n              createdMatterIdRef.current = null;\n              if (createdMatterId) {\n                location.route(`${basePath}/${encodeURIComponent(createdMatterId)}`);\n                return;\n              }\n              location.route(basePath);\n            }}\n            onSubmit={handleCreateMatter}\n            practiceId={activePracticeId}\n            clients={clientOptions}\n            practiceAreas={practiceAreaOptions}\n            practiceAreasLoading={servicesLoading}\n            assignees={assigneeOptions}\n          />\n        </div>\n      </Page>\n    );\n  }\n\n  if (isEditRoute && selectedMatterId) {\n    if (detailLoading && !resolvedSelectedMatter) {\n      return (\n        <Page className=\"h-full\">\n          <LoadingState message=\"Loading matter details...\" />\n        </Page>\n      );\n    }\n\n    if (detailError && !resolvedSelectedMatter) {\n      return (\n        <Page className=\"h-full\">\n          <div className=\"max-w-5xl mx-auto space-y-6\">\n            <PageHeader\n              title=\"Unable to load matter\"\n              subtitle={detailError}\n              actions={(\n                <Button size=\"sm\" variant=\"secondary\" onClick={() => location.route(basePath)}>\n                  Back to matters\n                </Button>\n              )}\n            />\n          </div>\n        </Page>\n      );\n    }\n\n    if (!resolvedSelectedMatter) {\n      return (\n        <Page className=\"h-full\">\n          <div className=\"max-w-5xl mx-auto space-y-6\">\n            <PageHeader\n              title=\"Matter not found\"\n              subtitle=\"This matter may have been removed or is no longer available.\"\n              actions={(\n                <Button size=\"sm\" variant=\"secondary\" onClick={() => location.route(basePath)}>\n                  Back to matters\n                </Button>\n              )}\n            />\n            <section className=\"glass-panel p-6\">\n              <p className=\"text-sm text-input-placeholder\">\n                We could not find a matter with the ID{' '}\n                <span className=\"font-mono text-input-text\">{selectedMatterId}</span>\n                {' '}in this workspace.\n              </p>\n            </section>\n          </div>\n        </Page>\n      );\n    }\n\n    if (!selectedMatterDetail) {\n      return (\n        <Page className=\"h-full\">\n          <LoadingState message=\"Loading matter details...\" />\n        </Page>\n      );\n    }\n\n    return (\n      <Page className=\"min-h-full\">\n        <div className=\"max-w-6xl mx-auto flex flex-col gap-6\">\n          <Breadcrumbs\n            items={[\n              { label: 'Matters', href: basePath },\n              { label: resolvedSelectedMatter.title, href: `${basePath}/${encodeURIComponent(resolvedSelectedMatter.id)}` },\n              { label: 'Edit' }\n            ]}\n            onNavigate={(href) => location.route(href)}\n          />\n          <PageHeader\n            title=\"Edit Matter\"\n            subtitle={`Update details for ${resolvedSelectedMatter.title}.`}\n            actions={(\n              <Button\n                size=\"sm\"\n                variant=\"secondary\"\n                onClick={() => location.route(`${basePath}/${encodeURIComponent(resolvedSelectedMatter.id)}`)}\n              >\n                Back to matter\n              </Button>\n            )}\n          />\n          <MatterEditForm\n            key={`edit-${selectedMatterId}`}\n            onClose={() => location.route(`${basePath}/${encodeURIComponent(resolvedSelectedMatter.id)}`)}\n            onSubmit={handleUpdateMatter}\n            practiceId={activePracticeId}\n            clients={clientOptions}\n            practiceAreas={practiceAreaOptions}\n            practiceAreasLoading={servicesLoading}\n            assignees={assigneeOptions}\n            initialValues={{\n              title: selectedMatterDetail.title,\n              clientId: selectedMatterDetail.clientId,\n              practiceAreaId: selectedMatterDetail.practiceAreaId,\n              assigneeIds: selectedMatterDetail.assigneeIds,\n              status: selectedMatterDetail.status,\n              caseNumber: selectedMatterDetail.caseNumber ?? '',\n              matterType: selectedMatterDetail.matterType ?? '',\n              urgency: selectedMatterDetail.urgency ?? '',\n              responsibleAttorneyId: selectedMatterDetail.responsibleAttorneyId ?? '',\n              originatingAttorneyId: selectedMatterDetail.originatingAttorneyId ?? '',\n              court: selectedMatterDetail.court ?? '',\n              judge: selectedMatterDetail.judge ?? '',\n              opposingParty: selectedMatterDetail.opposingParty ?? '',\n              opposingCounsel: selectedMatterDetail.opposingCounsel ?? '',\n              openDate: selectedMatterDetail.openDate ?? '',\n              closeDate: selectedMatterDetail.closeDate ?? '',\n              billingType: selectedMatterDetail.billingType,\n              attorneyHourlyRate: selectedMatterDetail.attorneyHourlyRate,\n              adminHourlyRate: selectedMatterDetail.adminHourlyRate,\n              paymentFrequency: selectedMatterDetail.paymentFrequency,\n              totalFixedPrice: selectedMatterDetail.totalFixedPrice,\n              settlementAmount: selectedMatterDetail.settlementAmount,\n              milestones: selectedMatterDetail.milestones ?? [],\n              contingencyPercent: selectedMatterDetail.contingencyPercent,\n              description: selectedMatterDetail.description\n            }}\n          />\n        </div>\n      </Page>\n    );\n  }\n\n  if (selectedMatterId && !isEditRoute) {\n    if (detailLoading && !resolvedSelectedMatter) {\n      return (\n        <Page className=\"h-full\">\n          <LoadingState message=\"Loading matter details...\" />\n        </Page>\n      );\n    }\n\n    if (detailError && !resolvedSelectedMatter) {\n      return (\n        <Page className=\"h-full\">\n          <div className=\"max-w-5xl mx-auto space-y-6\">\n            <PageHeader\n              title=\"Unable to load matter\"\n              subtitle={detailError}\n              actions={(\n                <Button size=\"sm\" variant=\"secondary\" onClick={() => location.route(basePath)}>\n                  Back to matters\n                </Button>\n              )}\n            />\n          </div>\n        </Page>\n      );\n    }\n\n    if (!resolvedSelectedMatter) {\n      return (\n        <Page className=\"h-full\">\n          <div className=\"max-w-5xl mx-auto space-y-6\">\n            <PageHeader\n              title=\"Matter not found\"\n              subtitle=\"This matter may have been removed or is no longer available.\"\n              actions={(\n                <Button size=\"sm\" variant=\"secondary\" onClick={() => location.route(basePath)}>\n                  Back to matters\n                </Button>\n              )}\n            />\n            <section className=\"glass-panel p-6\">\n              <p className=\"text-sm text-input-placeholder\">\n                We could not find a matter with the ID{' '}\n                <span className=\"font-mono text-input-text\">{selectedMatterId}</span>\n                {' '}in this workspace.\n              </p>\n            </section>\n          </div>\n        </Page>\n      );\n    }\n\n    return (\n      <Page className=\"min-h-full\">\n        <div className=\"max-w-6xl mx-auto flex flex-col gap-6\">\n          <div className=\"space-y-4\">\n            {headerMeta && (\n              <MatterDetailHeader\n                matter={resolvedSelectedMatter}\n                detail={selectedMatterDetail}\n                headerMeta={headerMeta}\n                activeTab={detailTab}\n                onTabChange={(id) => setDetailTab(id as DetailTabId)}\n                tabs={DETAIL_TABS}\n                onUpdateStatus={(newStatus) => {\n                  if (!selectedMatterDetail || !activePracticeId) return;\n                  handleUpdateMatter({\n                    title: selectedMatterDetail.title,\n                    clientId: selectedMatterDetail.clientId,\n                    practiceAreaId: selectedMatterDetail.practiceAreaId,\n                    assigneeIds: selectedMatterDetail.assigneeIds,\n                    status: newStatus,\n                    caseNumber: selectedMatterDetail.caseNumber ?? '',\n                    matterType: selectedMatterDetail.matterType ?? '',\n                    urgency: selectedMatterDetail.urgency ?? '',\n                    responsibleAttorneyId: selectedMatterDetail.responsibleAttorneyId ?? '',\n                    originatingAttorneyId: selectedMatterDetail.originatingAttorneyId ?? '',\n                    court: selectedMatterDetail.court ?? '',\n                    judge: selectedMatterDetail.judge ?? '',\n                    opposingParty: selectedMatterDetail.opposingParty ?? '',\n                    opposingCounsel: selectedMatterDetail.opposingCounsel ?? '',\n                    openDate: selectedMatterDetail.openDate ?? '',\n                    closeDate: selectedMatterDetail.closeDate ?? '',\n                    billingType: selectedMatterDetail.billingType,\n                    attorneyHourlyRate: selectedMatterDetail.attorneyHourlyRate,\n                    adminHourlyRate: selectedMatterDetail.adminHourlyRate,\n                    paymentFrequency: selectedMatterDetail.paymentFrequency,\n                    totalFixedPrice: selectedMatterDetail.totalFixedPrice,\n                    settlementAmount: selectedMatterDetail.settlementAmount,\n                    milestones: selectedMatterDetail.milestones ?? [],\n                    contingencyPercent: selectedMatterDetail.contingencyPercent,\n                    description: selectedMatterDetail.description\n                  });\n                }}\n                onEdit={() => location.route(`${basePath}/${encodeURIComponent(resolvedSelectedMatter.id)}/edit`)}\n                isLoading={detailLoading}\n              />\n            )}\n          </div>\n\n\n\n          <MatterSummaryCards\n            activeTab={detailTab}\n            onAddTime={() => {\n              if (detailTab !== 'overview') return;\n              openQuickTimeEntry();\n            }}\n            onViewTimesheet={() => setDetailTab('time')}\n            onChangeRate={() => {}}\n            timeStats={timeStats}\n          />\n\n          {detailTab === 'overview' && selectedMatterDetail && (\n            <div className=\"glass-panel p-6\">\n              <MarkdownUploadTextarea\n                label=\"Description\"\n                value={selectedMatterDetail.description}\n                onChange={(value) => {\n                  if (!selectedMatterDetail || !activePracticeId) return;\n                  debouncedUpdateMatter({\n                    title: selectedMatterDetail.title,\n                    clientId: selectedMatterDetail.clientId,\n                    practiceAreaId: selectedMatterDetail.practiceAreaId,\n                    assigneeIds: selectedMatterDetail.assigneeIds,\n                    status: selectedMatterDetail.status,\n                    caseNumber: selectedMatterDetail.caseNumber ?? '',\n                    matterType: selectedMatterDetail.matterType ?? '',\n                    urgency: selectedMatterDetail.urgency ?? '',\n                    responsibleAttorneyId: selectedMatterDetail.responsibleAttorneyId ?? '',\n                    originatingAttorneyId: selectedMatterDetail.originatingAttorneyId ?? '',\n                    court: selectedMatterDetail.court ?? '',\n                    judge: selectedMatterDetail.judge ?? '',\n                    opposingParty: selectedMatterDetail.opposingParty ?? '',\n                    opposingCounsel: selectedMatterDetail.opposingCounsel ?? '',\n                    openDate: selectedMatterDetail.openDate ?? '',\n                    closeDate: selectedMatterDetail.closeDate ?? '',\n                    billingType: selectedMatterDetail.billingType,\n                    attorneyHourlyRate: selectedMatterDetail.attorneyHourlyRate,\n                    adminHourlyRate: selectedMatterDetail.adminHourlyRate,\n                    paymentFrequency: selectedMatterDetail.paymentFrequency,\n                    totalFixedPrice: selectedMatterDetail.totalFixedPrice,\n                    settlementAmount: selectedMatterDetail.settlementAmount,\n                    milestones: selectedMatterDetail.milestones ?? [],\n                    contingencyPercent: selectedMatterDetail.contingencyPercent,\n                    description: value\n                  });\n                }}\n                practiceId={activePracticeId}\n                showLabel={true}\n                showTabs={true}\n                showFooter={true}\n                rows={12}\n                defaultTab=\"preview\"\n              />\n            </div>\n          )}\n\n          <section>\n            {detailTab === 'overview' ? (\n              <div className=\"px-0 space-y-6\">\n                {selectedMatterDetail && (\n                  <Panel className=\"p-4\">\n                    <h3 className=\"text-sm font-semibold text-input-text\">Matter details</h3>\n                    <div className=\"mt-4 grid gap-4 sm:grid-cols-2 lg:grid-cols-3\">\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Case number</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.caseNumber || ''}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Matter type</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.matterType || ''}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Urgency</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.urgency ? selectedMatterDetail.urgency.replace(/_/g, ' ') : ''}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Responsible attorney</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.responsibleAttorneyId\n                            ? resolveOptionLabel(assigneeOptions, selectedMatterDetail.responsibleAttorneyId, `User ${selectedMatterDetail.responsibleAttorneyId.slice(0, 6)}`)\n                            : ''}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Originating attorney</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.originatingAttorneyId\n                            ? resolveOptionLabel(assigneeOptions, selectedMatterDetail.originatingAttorneyId, `User ${selectedMatterDetail.originatingAttorneyId.slice(0, 6)}`)\n                            : ''}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Court</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.court || ''}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Judge</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.judge || ''}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Opposing party</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.opposingParty || ''}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Opposing counsel</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.opposingCounsel || ''}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Open date</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {formatLongDate(selectedMatterDetail.openDate)}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Close date</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {formatLongDate(selectedMatterDetail.closeDate)}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-xs font-medium uppercase tracking-wide text-input-placeholder\">Settlement amount</p>\n                        <p className=\"mt-1 text-sm text-input-text\">\n                          {selectedMatterDetail.settlementAmount !== undefined && selectedMatterDetail.settlementAmount !== null\n                            ? formatCurrency(selectedMatterDetail.settlementAmount)\n                            : ''}\n                        </p>\n                      </div>\n                    </div>\n                  </Panel>\n                )}\n                <div>\n                  <h3 className=\"text-sm font-semibold text-input-text\">Recent activity</h3>\n                  <Panel className=\"mt-4 p-4\">\n                    {activityLoading && activityItems.length === 0 ? (\n                      <LoadingState message=\"Loading activity...\" />\n                    ) : (\n                      <ActivityTimeline\n                        items={timelineItems}\n                        showComposer\n                        composerDisabled={activityLoading || !selectedMatterDetail}\n                        composerLabel=\"Comment\"\n                        composerPlaceholder=\"Add your comment...\"\n                        composerPracticeId={activePracticeId}\n                        composerPerson={{\n                          name: session?.user?.name ?? session?.user?.email ?? 'You',\n                          imageUrl: session?.user?.image ?? null\n                        }}\n                        onComposerSubmit={async (value) => {\n                          try {\n                            await handleCreateNote({ content: value });\n                          } catch (err) {\n                            console.error('[PracticeMattersPage] Failed to create note', err);\n                            showError('Could not save comment', 'Please try again.');\n                          }\n                        }}\n                      />\n                    )}\n                  </Panel>\n                </div>\n                {selectedMatterDetail && (\n                  <MatterMilestonesPanel\n                    key={`milestones-overview-${selectedMatterDetail.id}`}\n                    matter={selectedMatterDetail}\n                    milestones={milestones}\n                    loading={milestonesLoading}\n                    error={milestonesError}\n                    onCreateMilestone={handleCreateMilestone}\n                    onUpdateMilestone={handleUpdateMilestone}\n                    onDeleteMilestone={handleDeleteMilestone}\n                    onReorderMilestones={handleReorderMilestones}\n                    allowReorder\n                  />\n                )}\n                {/* Notes are handled via the activity timeline composer */}\n              </div>\n            ) : detailTab === 'time' && selectedMatterDetail ? (\n              <div className=\"px-0 space-y-6\">\n                <TimeEntriesPanel\n                  key={`time-${selectedMatterDetail.id}`}\n                  entries={timeEntries}\n                  onSaveEntry={(values, existing) => {\n                    void handleSaveTimeEntry(values, existing);\n                  }}\n                  onDeleteEntry={(entry) => {\n                    void handleDeleteTimeEntry(entry);\n                  }}\n                  loading={timeEntriesLoading}\n                  error={timeEntriesError}\n                />\n                <MatterExpensesPanel\n                  key={`expenses-${selectedMatterDetail.id}`}\n                  matter={selectedMatterDetail}\n                  expenses={expenses}\n                  loading={expensesLoading}\n                  error={expensesError}\n                  onCreateExpense={handleCreateExpense}\n                  onUpdateExpense={handleUpdateExpense}\n                  onDeleteExpense={handleDeleteExpense}\n                />\n                <Panel>\n                  <header className=\"flex items-center justify-between border-b border-line-glass/30 px-6 py-4\">\n                    <div>\n                      <h3 className=\"text-sm font-semibold text-input-text\">Recent transactions</h3>\n                      <p className=\"text-xs text-input-placeholder\">\n                        Summary of billed time across recent periods.\n                      </p>\n                    </div>\n                  </header>\n                  <div className=\"grid gap-4 p-6 sm:grid-cols-3\">\n                    {[\n                      { label: 'Last 7 days', value: '$0.00' },\n                      { label: 'Last 30 days', value: '$0.00' },\n                      { label: 'Since start', value: '$1,237.50' }\n                    ].map((card) => (\n                      <div\n                        key={card.label}\n                        className=\"glass-panel p-4\"\n                      >\n                        <p className=\"text-xs font-medium text-input-placeholder\">{card.label}</p>\n                        <p className=\"mt-2 text-lg font-semibold text-input-text\">{card.value}</p>\n                      </div>\n                    ))}\n                  </div>\n                </Panel>\n              </div>\n            ) : detailTab === 'messages' && selectedMatterDetail ? (\n              <div className=\"px-0\">\n                <MatterMessagesPanel\n                  key={`messages-${selectedMatterDetail.id}`}\n                  matter={selectedMatterDetail}\n                  practiceId={activePracticeId}\n                  conversationBasePath={conversationBasePath}\n                />\n              </div>\n            ) : (\n              <div className=\"px-0 text-sm text-input-placeholder\">\n                We will add the {DETAIL_TABS.find((tab) => tab.id === detailTab)?.label ?? 'tab'} details next.\n              </div>\n            )}\n          </section>\n        </div>\n        \n        {isQuickTimeEntryOpen && (\n          <Modal\n            isOpen={isQuickTimeEntryOpen}\n            onClose={() => setIsQuickTimeEntryOpen(false)}\n            title=\"Add time entry\"\n            contentClassName=\"max-w-2xl\"\n          >\n            <TimeEntryForm\n              key={`quick-time-${quickTimeEntryKey}`}\n              onSubmit={handleQuickTimeSubmit}\n              onCancel={() => setIsQuickTimeEntryOpen(false)}\n            />\n          </Modal>\n        )}\n      </Page>\n    );\n  }\n\n  return (\n    <Page className=\"min-h-full\">\n      <div className=\"max-w-6xl mx-auto flex flex-col gap-6\">\n        <PageHeader\n          title=\"Matters\"\n          subtitle=\"Track matter progress, client updates, and case milestones.\"\n          actions={(\n            <div className=\"flex items-center gap-2\">\n              <Button\n                size=\"sm\"\n                icon={<PlusIcon className=\"h-4 w-4\" />}\n                onClick={() => location.route(`${basePath}/new`)}\n                disabled={!activePracticeId}\n              >\n                Create Matter\n              </Button>\n            </div>\n          )}\n        />\n\n        {isClientListTruncated && (\n          <div className=\"rounded-xl border border-amber-200 bg-amber-50 px-4 py-3 text-sm text-amber-700 dark:border-amber-500/40 dark:bg-amber-500/10 dark:text-amber-200\">\n            <strong>Warning:</strong> The client list is incomplete. Some names or options may be missing.\n          </div>\n        )}\n\n\n        <Tabs\n          items={tabs}\n          activeId={activeTab}\n          onChange={(id) => setActiveTab(id as MatterTabId)}\n          actions={(\n            <DropdownMenu>\n              <DropdownMenuTrigger asChild>\n                <Button\n                  variant=\"secondary\"\n                  size=\"sm\"\n                  icon={<ChevronUpDownIcon className=\"h-4 w-4\" />}\n                  iconPosition=\"right\"\n                >\n                  Sort by {SORT_LABELS[sortOption]}\n                </Button>\n              </DropdownMenuTrigger>\n              <DropdownMenuContent align=\"end\" className=\"w-44\">\n                <div className=\"py-1\">\n                  {(Object.keys(SORT_LABELS) as SortOption[]).map((option) => (\n                    <DropdownMenuItem\n                      key={option}\n                      onSelect={() => setSortOption(option)}\n                      className={option === sortOption ? 'font-semibold text-input-text' : ''}\n                    >\n                      {SORT_LABELS[option]}\n                    </DropdownMenuItem>\n                  ))}\n                </div>\n              </DropdownMenuContent>\n            </DropdownMenu>\n          )}\n        />\n\n        {mattersError && (\n          <div className=\"rounded-2xl border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-700 dark:border-red-500/40 dark:bg-red-500/10 dark:text-red-200\">\n            {mattersError}\n          </div>\n        )}\n\n        <div className=\"flex flex-col gap-6\">\n          <Panel className=\"overflow-hidden\">\n            <header className=\"flex items-center justify-between border-b border-line-glass/30 px-4 py-4 sm:px-6 lg:px-8\">\n              <div>\n                <h2 className=\"text-sm font-semibold text-input-text\">{activeTabLabel} Matters</h2>\n                <p className=\"text-xs text-input-placeholder\">\n                  {sortedMatterSummaries.length} showing\n                </p>\n              </div>\n            </header>\n            {mattersLoading ? (\n              <LoadingState message=\"Loading matters...\" />\n            ) : sortedMatterSummaries.length === 0 ? (\n              <EmptyState\n                onCreate={() => location.route(`${basePath}/new`)}\n                disableCreate={!activePracticeId}\n              />\n            ) : (\n              <ul className=\"divide-y divide-line-default\">\n                {sortedMatterSummaries.map((matter) => (\n                  <MatterListItem\n                    key={matter.id}\n                    matter={matter}\n                    onSelect={(selected) => location.route(`${basePath}/${encodeURIComponent(selected.id)}`)}\n                  />\n                ))}\n              </ul>\n            )}\n            {mattersHasMore && !mattersLoading && (\n              <div ref={loadMoreRef} className=\"h-10\" />\n            )}\n            {mattersLoadingMore && (\n              <div className=\"px-6 py-4 text-sm text-input-placeholder\">\n                Loading more matters...\n              </div>\n            )}\n          </Panel>\n\n        </div>\n      </div>\n\n    </Page>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/services/mattersApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/matters/utils/formatRelativeTime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/media/components/AudioRecordingUI.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":277,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":277,"endColumn":29,"suggestions":[{"fix":{"range":[11100,11159],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":298,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":298,"endColumn":26,"suggestions":[{"fix":{"range":[12107,12169],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport { useEffect, useState, useRef, useCallback } from 'preact/hooks';\nimport { XMarkIcon, CheckIcon } from \"@heroicons/react/24/outline\";\nimport { Button } from '@/shared/ui/Button';\n\n// Type-safe interface for AudioContext globals\ninterface AudioContextGlobals {\n    AudioContext?: typeof AudioContext;\n    webkitAudioContext?: typeof AudioContext;\n}\n\ninterface AudioRecordingUIProps {\n    onCancel: () => void;\n    onConfirm: () => void;\n    isRecording: boolean;\n    mediaStream?: MediaStream | null; // Add mediaStream prop to access the audio stream\n}\n\nconst AudioRecordingUI: FunctionComponent<AudioRecordingUIProps> = ({\n    onCancel,\n    onConfirm,\n    isRecording,\n    mediaStream\n}) => {\n    const [recordingTime, setRecordingTime] = useState(0);\n    const [isBrowser, setIsBrowser] = useState(false);\n    const timerRef = useRef<number>();\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const animationFrameRef = useRef<number>();\n    const confirmBtnRef = useRef<HTMLButtonElement>(null);\n    \n    // Web Audio API references\n    const audioContextRef = useRef<AudioContext | null>(null);\n    const analyserRef = useRef<AnalyserNode | null>(null);\n    const dataArrayRef = useRef<Uint8Array | null>(null);\n\n    useEffect(() => {\n        setIsBrowser(true);\n    }, []);\n\n    // Focus the confirm button when recording starts\n    useEffect(() => {\n        if (isBrowser && isRecording) {\n            setTimeout(() => {\n                confirmBtnRef.current?.focus();\n            }, 100);\n        }\n    }, [isRecording, isBrowser]);\n\n    // Handle keyboard navigation during recording\n    useEffect(() => {\n        if (!isBrowser || !isRecording) return;\n\n        const handleKeyDown = (e: KeyboardEvent) => {\n            if (e.key === 'Escape') {\n                e.preventDefault();\n                onCancel();\n            } else if (e.key === 'Enter') {\n                e.preventDefault();\n                onConfirm();\n            }\n        };\n\n        document.addEventListener('keydown', handleKeyDown);\n        return () => {\n            document.removeEventListener('keydown', handleKeyDown);\n        };\n    }, [isRecording, isBrowser, onCancel, onConfirm]);\n\n    // Timer logic\n    useEffect(() => {\n        if (!isBrowser || !isRecording) return;\n\n        timerRef.current = window.setInterval(() => {\n            setRecordingTime(prev => prev + 1);\n        }, 1000);\n        \n        return () => {\n            if (timerRef.current) {\n                clearInterval(timerRef.current);\n            }\n        };\n    }, [isRecording, isBrowser]);\n\n    // Audio visualization callbacks - defined before the effect that uses them\n    const visualizeAudio = useCallback(() => {\n        const canvas = canvasRef.current;\n        if (!canvas || !analyserRef.current || !dataArrayRef.current) return;\n\n        const ctx = canvas.getContext('2d');\n        if (!ctx) return;\n\n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        // Visualization settings\n        const barWidth = 4;\n        const barGap = 2;\n        const barCount = Math.floor(canvas.width / (barWidth + barGap));\n        const radius = 2; // Radius for rounded corners\n        const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');\n        \n        ctx.fillStyle = accentColor || '#0ea5e9';\n        \n        function draw() {\n            if (!analyserRef.current || !dataArrayRef.current) return;\n            \n            // Get frequency data from microphone\n            analyserRef.current.getByteFrequencyData(dataArrayRef.current as Uint8Array<ArrayBuffer>);\n            \n            // Clear the canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Center everything\n            const totalWidth = barCount * barWidth + (barCount - 1) * barGap;\n            const startXMarkIcon = (canvas.width - totalWidth) / 2;\n            \n            // Draw bars based on audio frequency data\n            for (let i = 0; i < barCount; i++) {\n                const x = startXMarkIcon + i * (barWidth + barGap);\n                \n                // Map frequency data to bar index\n                // Use logarithmic scale to better match human hearing perception\n                const dataIndex = Math.min(\n                    Math.floor(i / barCount * dataArrayRef.current.length * 0.75),\n                    dataArrayRef.current.length - 1\n                );\n                \n                // Scale the value to get the bar height (0-255 to 0-1)\n                const amplitude = dataArrayRef.current[dataIndex] / 255;\n                \n                // Calculate bar height (min 2px)\n                const baseHeight = 4; // Minimum height when silent\n                const maxHeight = canvas.height - 8; // Maximum height\n                const h = baseHeight + (maxHeight - baseHeight) * amplitude;\n                const y = (canvas.height - h) / 2;\n                \n                // Draw rounded rectangle\n                if (h > 0) {\n                    ctx.beginPath();\n                    // Only use rounded corners if height is enough\n                    if (h > radius * 2) {\n                        // Corners are rounded\n                        ctx.moveTo(x + radius, y);\n                        ctx.lineTo(x + barWidth - radius, y);\n                        ctx.quadraticCurveTo(x + barWidth, y, x + barWidth, y + radius);\n                        ctx.lineTo(x + barWidth, y + h - radius);\n                        ctx.quadraticCurveTo(x + barWidth, y + h, x + barWidth - radius, y + h);\n                        ctx.lineTo(x + radius, y + h);\n                        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);\n                        ctx.lineTo(x, y + radius);\n                        ctx.quadraticCurveTo(x, y, x + radius, y);\n                    } else {\n                        // Simple rectangle for small heights\n                        ctx.rect(x, y, barWidth, h);\n                    }\n                    ctx.fill();\n                }\n            }\n            \n            // Continue the animation loop if still recording\n            if (isRecording) {\n                animationFrameRef.current = requestAnimationFrame(draw);\n            }\n        }\n        \n        // Start the animation loop\n        animationFrameRef.current = requestAnimationFrame(draw);\n    }, [isRecording]);\n\n    // Fallback to fake visualization if real audio analysis fails\n    const fallbackVisualization = useCallback((): number => {\n        const canvas = canvasRef.current;\n        if (!canvas) return 0;\n\n        const ctx = canvas.getContext('2d');\n        if (!ctx) return 0;\n\n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        // Visualization settings\n        const barWidth = 4;\n        const barGap = 2;\n        const barCount = Math.floor(canvas.width / (barWidth + barGap));\n        const barHeightMultiplier = 30;\n        const baseHeight = canvas.height / 4;\n        const radius = 2; // Radius for rounded corners\n        const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');\n        \n        ctx.fillStyle = accentColor || '#0ea5e9';\n        \n        function animateBarData() {\n            const amplitudes = [];\n            for (let i = 0; i < barCount; i++) {\n                // Dynamic animation logic\n                const time = Date.now() / 1000;\n                const freq = 1 + (i / barCount) * 3;\n                const amplitude = (Math.sin(time * freq * 2) + 1) / 2;\n                \n                // Add variations based on index to make it look more natural\n                const variation = Math.sin(i * 0.2) * 0.3 + 0.7;\n                \n                // Create amplitude array with values between 0.1 and 1\n                const finalAmplitude = 0.1 + (amplitude * variation * 0.9);\n                \n                // Add in some randomness for realism\n                const randomFactor = 0.05;\n                const randomOffset = (Math.random() * 2 - 1) * randomFactor;\n                \n                amplitudes.push(Math.max(0.1, Math.min(1, finalAmplitude + randomOffset)));\n            }\n            return amplitudes;\n        }\n        \n        const drawBars = () => {\n            const barAmplitudes = animateBarData();\n            \n            // Clear the canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Center everything\n            const totalWidth = barCount * barWidth + (barCount - 1) * barGap;\n            const startXMarkIcon = (canvas.width - totalWidth) / 2;\n            \n            // Draw bars\n            for (let i = 0; i < barCount; i++) {\n                const x = startXMarkIcon + i * (barWidth + barGap);\n                const amplitude = barAmplitudes[i];\n                const h = amplitude * barHeightMultiplier + baseHeight;\n                const y = (canvas.height - h) / 2;\n                \n                // Draw rounded rectangle with better corner handling\n                if (h > 0) {\n                    ctx.beginPath();\n                    // Only use rounded corners if height is enough\n                    if (h > radius * 2) {\n                        // Corners are rounded\n                        ctx.moveTo(x + radius, y);\n                        ctx.lineTo(x + barWidth - radius, y);\n                        ctx.quadraticCurveTo(x + barWidth, y, x + barWidth, y + radius);\n                        ctx.lineTo(x + barWidth, y + h - radius);\n                        ctx.quadraticCurveTo(x + barWidth, y + h, x + barWidth - radius, y + h);\n                        ctx.lineTo(x + radius, y + h);\n                        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);\n                        ctx.lineTo(x, y + radius);\n                        ctx.quadraticCurveTo(x, y, x + radius, y);\n                    } else {\n                        // Simple rectangle for small heights\n                        ctx.rect(x, y, barWidth, h);\n                    }\n                    ctx.fill();\n                }\n            }\n            \n            // Continue the animation loop if still recording\n            if (isRecording) {\n                animationFrameRef.current = requestAnimationFrame(drawBars);\n            }\n        };\n        \n        // Start the animation loop and return the animation frame ID\n        return requestAnimationFrame(drawBars);\n    }, [isRecording]);\n\n    // Set up audio context and analyzer\n    useEffect(() => {\n        if (!isBrowser || !isRecording || !mediaStream) return;\n\n        try {\n            // Initialize Audio Context - get constructor from globalThis to avoid shadowing\n            const audioGlobals = globalThis as unknown as AudioContextGlobals;\n            const AudioContextConstructor: typeof AudioContext | undefined = \n                audioGlobals.AudioContext || audioGlobals.webkitAudioContext;\n            \n            if (!AudioContextConstructor) {\n                console.warn('AudioContext not supported in this browser');\n                animationFrameRef.current = fallbackVisualization();\n                return;\n            }\n            \n            audioContextRef.current = new AudioContextConstructor();\n            \n            // Create analyzer node\n            analyserRef.current = audioContextRef.current.createAnalyser();\n            analyserRef.current.fftSize = 256; // Fast Fourier Transform size\n            const bufferLength = analyserRef.current.frequencyBinCount;\n            // Create Uint8Array for frequency data (created with length to ensure proper typing)\n            dataArrayRef.current = new Uint8Array(bufferLength);\n            \n            // Connect microphone stream to analyzer\n            const source = audioContextRef.current.createMediaStreamSource(mediaStream);\n            source.connect(analyserRef.current);\n            \n            // Start visualization\n            visualizeAudio();\n        } catch (error) {\n            console.error('Error setting up audio visualization:', error);\n            // Fall back to fake visualization if Web Audio API fails\n            animationFrameRef.current = fallbackVisualization();\n        }\n        \n        return () => {\n            // Clean up audio context\n            if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n                audioContextRef.current.close();\n            }\n            \n            if (animationFrameRef.current) {\n                cancelAnimationFrame(animationFrameRef.current);\n                animationFrameRef.current = undefined;\n            }\n        };\n    }, [isRecording, isBrowser, mediaStream, visualizeAudio, fallbackVisualization]);\n\n    const formatTime = (seconds: number): string => {\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return `${mins}:${secs.toString().padStart(2, '0')}`;\n    };\n\n    return (\n        <div className=\"flex items-center gap-4 w-full flex-1 p-0 m-0 bg-none border-none h-8 animate-fade-in\" role=\"dialog\" aria-modal=\"true\" aria-label=\"Audio recording in progress\">\n            <Button \n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={onCancel}\n                aria-label=\"Cancel recording\"\n                title=\"Cancel recording\"\n                className=\"flex items-center justify-center w-8 h-8 p-1.5 border-none rounded-full cursor-pointer transition-all duration-200 text-input-placeholder hover:text-red-400 bg-white/5 hover:bg-red-500/10 animate-zoom-in\"\n            >\n                <XMarkIcon className=\"w-5 h-5\" aria-hidden=\"true\" />\n            </Button>\n            <div className=\"flex-1 flex items-center gap-4 h-8 animate-zoom-in bg-transparent\" aria-live=\"polite\">\n                <canvas ref={canvasRef} width=\"300\" height=\"40\" aria-hidden=\"true\" className=\"flex-1 h-8 rounded-lg block image-rendering-crisp-edges image-rendering-webkit-optimize-contrast bg-white/5\" />\n                <div className=\"text-sm text-accent-500 font-tabular-nums min-w-10 text-right\" role=\"timer\" aria-label={`Recording time: ${formatTime(recordingTime)}`}>\n                    {formatTime(recordingTime)}\n                </div>\n                <div className=\"sr-only\" aria-live=\"assertive\">\n                    Recording audio, duration: {formatTime(recordingTime)}\n                </div>\n            </div>\n            <Button \n                variant=\"primary\"\n                size=\"sm\"\n                onClick={onConfirm}\n                aria-label=\"Confirm and send recording\"\n                title=\"Confirm and send recording\"\n                ref={confirmBtnRef}\n                className=\"flex items-center justify-center w-8 h-8 p-1.5 rounded-full shadow-lg shadow-accent-500/20 cursor-pointer transition-all duration-200 animate-zoom-in hover:scale-110 active:scale-95\"\n            >\n                <CheckIcon className=\"w-5 h-5\" aria-hidden=\"true\" />\n            </Button>\n        </div>\n    );\n};\n\nexport default AudioRecordingUI; ","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/media/components/DragDropOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/media/components/FileMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/media/components/LazyMedia.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/media/components/MediaContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/media/components/MediaControls.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":4,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":17,"suggestions":[{"fix":{"range":[2021,2076],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":105,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":105,"endColumn":18,"suggestions":[{"fix":{"range":[3147,3197],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport { useState, useRef, useEffect } from 'preact/hooks';\nimport AudioRecordingUI from './AudioRecordingUI';\nimport { MicrophoneIcon } from \"@heroicons/react/24/outline\";\nimport { features } from '@/config/features';\nimport { Button } from '@/shared/ui/Button';\n\ninterface MediaControlsProps {\n\tonMediaCapture: (blob: Blob, type: 'audio' | 'video') => void;\n\tonRecordingStateChange?: (isRecording: boolean) => void;\n}\n\nconst MediaControls: FunctionComponent<MediaControlsProps> = ({ \n\tonMediaCapture,\n\tonRecordingStateChange \n}) => {\n\t// Always call hooks at the top level\n\tconst [isRecording, setIsRecording] = useState(false);\n\tconst [permissionDenied, setPermissionDenied] = useState(false);\n\tconst mediaRecorderRef = useRef<MediaRecorder | null>(null);\n\tconst mediaStreamRef = useRef<MediaStream | null>(null);\n\tconst chunksRef = useRef<Blob[]>([]);\n\n\tuseEffect(() => {\n\t\tif (!features.enableAudioRecording) return;\n\t\tonRecordingStateChange?.(isRecording);\n\t}, [isRecording, onRecordingStateChange]);\n\n\tconst stopMediaStream = () => {\n\t\tif (mediaStreamRef.current) {\n\t\t\tmediaStreamRef.current.getTracks().forEach(track => {\n\t\t\t\ttrack.stop();\n\t\t\t});\n\t\t\tmediaStreamRef.current = null;\n\t\t}\n\t};\n\n\tuseEffect(() => {\n\t\treturn () => {\n\t\t\tstopMediaStream();\n\t\t};\n\t}, []);\n\n\t// If audio recording is disabled via feature flag, don't render anything\n\tif (!features.enableAudioRecording) {\n\t\treturn null;\n\t}\n\n\tconst startRecording = async () => {\n\t\ttry {\n\t\t\tsetPermissionDenied(false);\n\t\t\tconst constraints = {\n\t\t\t\taudio: true,\n\t\t\t\tvideo: false\n\t\t\t};\n\n\t\t\tconst stream = await navigator.mediaDevices.getUserMedia(constraints);\n\t\t\tmediaStreamRef.current = stream;\n\t\t\tconst mediaRecorder = new MediaRecorder(stream);\n\t\t\tmediaRecorderRef.current = mediaRecorder;\n\t\t\tchunksRef.current = [];\n\n\t\t\tmediaRecorder.ondataavailable = (e) => {\n\t\t\t\tif (e.data.size > 0) {\n\t\t\t\t\tchunksRef.current.push(e.data);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmediaRecorder.start();\n\t\t\tsetIsRecording(true);\n\t\t} catch (error) {\n\t\t\tconsole.error('Error accessing media devices:', error);\n\t\t\tsetIsRecording(false);\n\t\t\tsetPermissionDenied(true);\n\t\t\t// Announce the error for screen readers\n\t\t\tif (typeof document !== 'undefined') {\n\t\t\t\tconst errorMessage = document.createElement('div');\n\t\t\t\terrorMessage.setAttribute('role', 'alert');\n\t\t\t\terrorMessage.classList.add('sr-only');\n\t\t\t\terrorMessage.textContent = 'MicrophoneIconrophone access denied. Please check your browser permissions.';\n\t\t\t\tdocument.body.appendChild(errorMessage);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tdocument.body.removeChild(errorMessage);\n\t\t\t\t}, 5000);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst stopRecording = (shouldSave: boolean = true) => {\n\t\tif (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n\t\t\ttry {\n\t\t\t\tmediaRecorderRef.current.onstop = () => {\n\t\t\t\t\tif (shouldSave && chunksRef.current.length > 0) {\n\t\t\t\t\t\tconst blob = new Blob(chunksRef.current, {\n\t\t\t\t\t\t\ttype: 'audio/webm'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tonMediaCapture(blob, 'audio');\n\t\t\t\t\t}\n\t\t\t\t\tchunksRef.current = [];\n\t\t\t\t\tstopMediaStream();\n\t\t\t\t\tsetIsRecording(false);\n\t\t\t\t};\n\t\t\t\tmediaRecorderRef.current.stop();\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Error stopping recording:', error);\n\t\t\t\t// Force cleanup even if there was an error\n\t\t\t\tchunksRef.current = [];\n\t\t\t\tstopMediaStream();\n\t\t\t\tsetIsRecording(false);\n\t\t\t}\n\t\t} else {\n\t\t\t// If recorder is not available or already inactive, just clean up\n\t\t\tchunksRef.current = [];\n\t\t\tstopMediaStream();\n\t\t\tsetIsRecording(false);\n\t\t}\n\t};\n\n\tconst handleCancelRecording = () => {\n\t\tstopRecording(false);\n\t};\n\n\tconst handleConfirmRecording = () => {\n\t\tstopRecording(true);\n\t};\n\n\tconst handleKeyDown = (e: KeyboardEvent) => {\n\t\tif (e.key === 'Enter' || e.key === ' ') {\n\t\t\te.preventDefault();\n\t\t\tif (!isRecording) {\n\t\t\t\tstartRecording();\n\t\t\t}\n\t\t}\n\t};\n\n\tif (isRecording) {\n\t\treturn (\n\t\t\t<div className=\"flex items-center gap-2\" role=\"region\" aria-label=\"Audio recording controls\">\n\t\t\t\t<AudioRecordingUI\n\t\t\t\t\tisRecording={isRecording}\n\t\t\t\t\tonCancel={handleCancelRecording}\n\t\t\t\t\tonConfirm={handleConfirmRecording}\n\t\t\t\t\tmediaStream={mediaStreamRef.current}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t}\n\n\treturn (\n\t\t<div className=\"flex items-center gap-2\" role=\"region\" aria-label=\"Audio recording\">\n\t\t\t<Button\n\t\t\t\tvariant=\"icon\"\n\t\t\t\tsize=\"sm\"\n\t\t\t\tonClick={() => {\n\t\t\t\t\tif (!isRecording) {\n\t\t\t\t\t\tstartRecording();\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t\tonKeyDown={handleKeyDown}\n\t\t\t\ttitle=\"Record audio\"\n\t\t\t\taria-label=\"Record audio message\"\n\t\t\t\taria-pressed={isRecording}\n\t\t\t\tdisabled={permissionDenied}\n\t\t\t\tclassName=\"w-8 h-8 p-0 rounded-full\"\n\t\t\t>\n\t\t\t\t<MicrophoneIcon className=\"w-4 h-4\" aria-hidden=\"true\" />\n\t\t\t</Button>\n\t\t\t{permissionDenied && (\n\t\t\t\t<div className=\"sr-only\" role=\"alert\">\n\t\t\t\t\tMicrophoneIconrophone access denied. Please check your browser permissions.\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t);\n};\n\nexport default MediaControls; ","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/media/components/MediaSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/BadgeRecommended.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/CameraCaptureButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/CameraModal.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":20,"suggestions":[{"fix":{"range":[1410,1489],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":57,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":57,"endColumn":20,"suggestions":[{"fix":{"range":[1860,1906],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":77,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":77,"endColumn":20,"suggestions":[{"fix":{"range":[2578,2638],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":83,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":83,"endColumn":20,"suggestions":[{"fix":{"range":[2800,2841],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":91,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":91,"endColumn":20,"suggestions":[{"fix":{"range":[3082,3128],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":105,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":105,"endColumn":24,"suggestions":[{"fix":{"range":[3605,3656],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":110,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":110,"endColumn":20,"suggestions":[{"fix":{"range":[3787,3842],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport { useRef, useEffect, useState, useCallback } from 'preact/hooks';\nimport Modal from '@/shared/components/Modal';\nimport CameraCaptureButton from './CameraCaptureButton';\n\ninterface CameraModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onCapture: (file: File) => void;\n}\n\nconst CameraModal: FunctionComponent<CameraModalProps> = ({\n  isOpen,\n  onClose,\n  onCapture\n}) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n  const [isCameraReady, setIsCameraReady] = useState(false);\n  const [error, setError] = useState('');\n\n  const onVideoLoaded = useCallback(() => {\n    setIsCameraReady(true);\n  }, []);\n  const onVideoError = useCallback(() => {\n    setError('Error loading video stream.');\n  }, []);\n\n  const stopCamera = useCallback(() => {\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n    setIsCameraReady(false);\n  }, []);\n\n  const startCamera = useCallback(async () => {\n    try {\n      setError('');\n      setIsCameraReady(false);\n      if (streamRef.current) stopCamera();\n      let stream;\n      try {\n        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });\n      } catch (envError) {\n        console.log('Environment camera not available, trying user camera:', envError);\n        stream = await navigator.mediaDevices.getUserMedia({ video: true });\n      }\n      streamRef.current = stream;\n      if (videoRef.current) {\n        videoRef.current.srcObject = stream;\n        videoRef.current.addEventListener('loadedmetadata', onVideoLoaded);\n        videoRef.current.addEventListener('error', onVideoError);\n      }\n    } catch (err) {\n      console.error('Error accessing camera:', err);\n      setError('Could not access camera. Please check permissions and ensure your device has a camera.');\n    }\n  }, [stopCamera, onVideoLoaded, onVideoError]);\n\n  useEffect(() => {\n    if (isOpen) startCamera();\n    const video = videoRef.current;\n    return () => {\n      // Remove listeners before stopping camera\n      if (video) {\n        video.removeEventListener('loadedmetadata', onVideoLoaded);\n        video.removeEventListener('error', onVideoError);\n      }\n      stopCamera();\n    };\n  }, [isOpen, startCamera, stopCamera, onVideoLoaded, onVideoError]);\n\n  const takePhoto = () => {\n    if (!isCameraReady || !videoRef.current || !canvasRef.current) {\n      console.error('Camera not ready or elements not available');\n      return;\n    }\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    if (video.videoWidth === 0 || video.videoHeight === 0) {\n      console.error('Video has no dimensions');\n      setError('Camera not ready. Please wait a moment and try again.');\n      return;\n    }\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n    const context = canvas.getContext('2d');\n    if (!context) {\n      console.error('Could not get canvas context');\n      setError('Error capturing photo. Please try again.');\n      return;\n    }\n    try {\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\n      canvas.toBlob((blob) => {\n        if (blob) {\n          const file = new File([blob], `photo_${Date.now()}.jpg`, { type: 'image/jpeg' });\n          onCapture(file);\n          // Stop camera after capture completes to avoid race with cleanup\n          stopCamera();\n          onClose();\n        } else {\n          console.error('Failed to create blob from canvas');\n          setError('Error creating photo. Please try again.');\n        }\n      }, 'image/jpeg', 0.9);\n    } catch (error) {\n      console.error('Error drawing image to canvas:', error);\n      setError('Error capturing photo. Please try again.');\n    }\n  };\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} type=\"fullscreen\" showCloseButton={true}>\n      <div className=\"flex flex-col h-full w-full\">\n        {error && (\n          <div className=\"p-3 bg-red-50 border border-red-200 rounded text-red-600 text-sm text-center absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10 max-w-80\">\n            <p>{error}</p>\n          </div>\n        )}\n        <div className=\"relative w-full h-full overflow-hidden bg-black flex-grow\">\n          <video ref={videoRef} autoPlay playsInline muted className=\"w-full h-full object-cover\" />\n          <canvas ref={canvasRef} style={{ display: 'none' }} />\n        </div>\n        <div className=\"absolute bottom-10 left-0 right-0 flex justify-center items-center py-4 z-10\">\n          <CameraCaptureButton onClick={takePhoto} disabled={!isCameraReady} />\n        </div>\n      </div>\n    </Modal>\n  );\n};\n\nexport default CameraModal;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/ModalBody.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/ModalCloseButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/ModalFooter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/ModalHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/PlanCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/PricingTabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/TipCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/WelcomeModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/components/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/hooks/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/modals/hooks/useWelcomeModal.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":34,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":34,"endColumn":23,"suggestions":[{"fix":{"range":[1280,1349],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":23,"suggestions":[{"fix":{"range":[1424,1491],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":41,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":41,"endColumn":20,"suggestions":[{"fix":{"range":[1537,1613],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":66,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":66,"endColumn":21,"suggestions":[{"fix":{"range":[2299,2376],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":87,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":87,"endColumn":19,"suggestions":[{"fix":{"range":[2845,2918],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":20,"suggestions":[{"fix":{"range":[3059,3126],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'preact/hooks';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { getPreferencesCategory, updatePreferencesCategory } from '@/shared/lib/preferencesApi';\nimport type { OnboardingPreferences } from '@/shared/types/preferences';\n\ninterface UseWelcomeModalOptions {\n  enabled?: boolean;\n}\n\ninterface UseWelcomeModalResult {\n  shouldShow: boolean;\n  markAsShown: () => Promise<void>;\n}\n\nexport function useWelcomeModal(options: UseWelcomeModalOptions = {}): UseWelcomeModalResult {\n  const { enabled = true } = options;\n  const { session, isPending: sessionIsPending, isAnonymous } = useSessionContext();\n  const [shouldShow, setShouldShow] = useState(false);\n  const bcRef = useRef<BroadcastChannel | null>(null);\n\n  useEffect(() => {\n    if (!enabled) return;\n    if (typeof window === 'undefined') return;\n    try {\n      bcRef.current = new BroadcastChannel('welcome');\n      const handler = (e: MessageEvent) => {\n        if (e?.data === 'shown') {\n          setShouldShow(false);\n        }\n      };\n      bcRef.current.addEventListener('message', handler as never);\n      return () => {\n        try { bcRef.current?.removeEventListener('message', handler as never); } catch (err) {\n          console.warn('[WELCOME_MODAL] Failed to remove event listener', err);\n        }\n        try { bcRef.current?.close(); } catch (err) {\n          console.warn('[WELCOME_MODAL] BroadcastChannel close failed', err);\n        }\n      };\n    } catch (err) {\n      console.error('[WELCOME_MODAL] Failed to initialize BroadcastChannel', err);\n    }\n  }, [enabled, session?.user?.id]);\n\n  useEffect(() => {\n    if (!enabled) {\n      setShouldShow(false);\n      return;\n    }\n    if (sessionIsPending || isAnonymous || !session?.user?.id) {\n      setShouldShow(false);\n      return;\n    }\n\n    let isMounted = true;\n\n    const checkPreferences = async () => {\n      try {\n        const prefs = await getPreferencesCategory<OnboardingPreferences>('onboarding');\n        const hasCompletedOnboarding = prefs?.completed === true;\n        const hasSeenWelcome = Boolean(prefs?.welcome_modal_shown);\n        if (isMounted) {\n          setShouldShow(hasCompletedOnboarding && !hasSeenWelcome);\n        }\n      } catch (error) {\n        console.warn('[WELCOME_MODAL] Failed to load onboarding preferences', error);\n        if (isMounted) {\n          setShouldShow(false);\n        }\n      }\n    };\n\n    void checkPreferences();\n\n    return () => {\n      isMounted = false;\n    };\n  }, [enabled, isAnonymous, session?.user?.id, sessionIsPending]);\n\n  const markAsShown = useCallback(async () => {\n    if (isAnonymous || !session?.user?.id) {\n      setShouldShow(false);\n      return;\n    }\n    setShouldShow(false);\n    try { bcRef.current?.postMessage('shown'); } catch (err) {\n      console.warn('[WELCOME_MODAL] BroadcastChannel postMessage failed', err);\n    }\n    try {\n      await updatePreferencesCategory('onboarding', {\n        welcome_modal_shown: true\n      });\n    } catch (err) {\n      console.error('[WELCOME_MODAL] Failed to update preferences', err);\n    }\n  }, [isAnonymous, session?.user?.id]);\n\n  return { shouldShow, markAsShown };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/onboarding/components/BusinessWelcomePrompt.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/onboarding/components/InfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/onboarding/components/OnboardingFlow.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":138,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":138,"endColumn":24,"suggestions":[{"fix":{"range":[4672,4735],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":180,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":180,"endColumn":22,"suggestions":[{"fix":{"range":[5627,5820],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":219,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":219,"endColumn":22,"suggestions":[{"fix":{"range":[6924,6998],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef, useState } from 'preact/hooks';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { getPreferencesCategory, updatePreferencesCategory } from '@/shared/lib/preferencesApi';\nimport { updateUser, getSession } from '@/shared/lib/authClient';\nimport type { OnboardingFormData } from '@/shared/types/onboarding';\nimport { sanitizeOnboardingPersonalInfo } from '@/shared/types/onboarding';\nimport type { OnboardingPreferences, ProductUsage } from '@/shared/types/preferences';\nimport PersonalInfoStep from './PersonalInfoStep';\nimport UseCaseStep from './UseCaseStep';\n\ntype OnboardingStep = 'personal' | 'useCase';\n\nconst createDefaultFormData = (): OnboardingFormData => ({\n  personalInfo: {\n    fullName: '',\n    birthday: '',\n    agreedToTerms: false\n  },\n  useCase: {\n    primaryUseCase: 'messaging',\n    productUsage: ['messaging'],\n    additionalInfo: undefined\n  }\n});\n\nconst resolvePrimaryUseCase = (\n  value: string | undefined\n): OnboardingFormData['useCase']['primaryUseCase'] => {\n  switch (value) {\n    case 'messaging':\n    case 'legal_payments':\n    case 'matter_management':\n    case 'intake_forms':\n    case 'other':\n      return value;\n    case 'personal':\n      return 'messaging';\n    case 'business':\n      return 'legal_payments';\n    case 'research':\n      return 'matter_management';\n    case 'documents':\n      return 'intake_forms';\n    default:\n      return 'other';\n  }\n};\n\nconst normalizeProductUsage = (values: unknown): ProductUsage[] => {\n  if (!Array.isArray(values)) return [];\n  const mapped = values\n    .map((value) => {\n      switch (value) {\n        case 'messaging':\n        case 'legal_payments':\n        case 'matter_management':\n        case 'intake_forms':\n        case 'other':\n          return value;\n        case 'communication':\n          return 'messaging';\n        case 'billing':\n          return 'legal_payments';\n        case 'case_management':\n          return 'matter_management';\n        case 'document_management':\n        case 'client_management':\n          return 'intake_forms';\n        default:\n          return null;\n      }\n    })\n    .filter((value): value is ProductUsage => value !== null);\n  return Array.from(new Set(mapped));\n};\n\ninterface OnboardingFlowProps {\n  onClose: () => void;\n  onComplete: (data: OnboardingFormData) => void;\n  active?: boolean;\n  className?: string;\n  testId?: string;\n}\n\nexport const OnboardingFlow = ({\n  onClose,\n  onComplete,\n  active = true,\n  className = '',\n  testId\n}: OnboardingFlowProps) => {\n  const { t } = useTranslation('common');\n  const { showError, showSuccess } = useToastContext();\n  const { session } = useSessionContext();\n  const [currentStep, setCurrentStep] = useState<OnboardingStep>('personal');\n  const [onboardingData, setOnboardingData] = useState<OnboardingFormData>(() => createDefaultFormData());\n  const hasLoadedRef = useRef(false);\n  const sessionUserId = session?.user?.id;\n  const sessionUserSnapshotRef = useRef<{ id?: string; name?: string }>({});\n  if (sessionUserId && sessionUserSnapshotRef.current.id !== sessionUserId) {\n    sessionUserSnapshotRef.current = {\n      id: sessionUserId,\n      name: session?.user?.name ?? ''\n    };\n  }\n  const sessionUserName = sessionUserSnapshotRef.current.name ?? '';\n\n  useEffect(() => {\n    if (active && sessionUserId && !hasLoadedRef.current) {\n      const loadPreferences = async () => {\n        try {\n          const prefs = await getPreferencesCategory<OnboardingPreferences>('onboarding');\n          setOnboardingData((prev) => ({\n            personalInfo: {\n              ...prev.personalInfo,\n              fullName: sessionUserName || prev.personalInfo.fullName,\n              birthday: prefs?.birthday ?? '',\n              agreedToTerms: prev.personalInfo.agreedToTerms\n            },\n            useCase: {\n              primaryUseCase: prefs?.primary_use_case\n                ? resolvePrimaryUseCase(prefs.primary_use_case)\n                : prev.useCase.primaryUseCase,\n              productUsage: (() => {\n                const fromPrefs = normalizeProductUsage(prefs?.product_usage);\n                if (fromPrefs.length > 0) return fromPrefs;\n                if (prefs?.primary_use_case) {\n                  return [resolvePrimaryUseCase(prefs.primary_use_case)];\n                }\n                return prev.useCase.productUsage;\n              })(),\n              additionalInfo: prefs?.use_case_additional_info ?? prev.useCase.additionalInfo\n            }\n          }));\n        } catch (error) {\n          console.error('Failed to load onboarding preferences:', error);\n        } finally {\n          hasLoadedRef.current = true;\n        }\n      };\n\n      void loadPreferences();\n    } else if (!active) {\n      hasLoadedRef.current = false;\n    }\n  }, [active, sessionUserId, sessionUserName]);\n\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const handleStepComplete = async (\n    step: OnboardingStep,\n    data: Partial<OnboardingFormData>\n  ) => {\n    const mergedData = {\n      ...onboardingData,\n      ...data\n    };\n\n    setOnboardingData(mergedData);\n\n    if (step === 'personal') {\n      setCurrentStep('useCase');\n      return;\n    }\n\n    if (step === 'useCase') {\n      await handleComplete(mergedData);\n    }\n  };\n\n  const handleComplete = async (data?: OnboardingFormData) => {\n    if (isSubmitting) return;\n    setIsSubmitting(true);\n    const sourceData = data || onboardingData;\n\n    try {\n      if (import.meta.env.DEV) {\n        console.debug('[ONBOARDING][SAVE] updating onboarding data', {\n          personalInfo: sanitizeOnboardingPersonalInfo(sourceData.personalInfo),\n          useCase: sourceData.useCase\n        });\n      }\n\n      const trimmedName = sourceData.personalInfo.fullName.trim();\n      const updatePayload: Record<string, unknown> = {\n        onboardingComplete: true\n      };\n      if (trimmedName) {\n        updatePayload.name = trimmedName;\n      }\n      if (sourceData.personalInfo.birthday) {\n        updatePayload.dob = sourceData.personalInfo.birthday;\n      }\n\n      await updateUser(updatePayload);\n\n      await updatePreferencesCategory('onboarding', {\n        birthday: sourceData.personalInfo.birthday,\n        primary_use_case: sourceData.useCase.primaryUseCase,\n        use_case_additional_info: sourceData.useCase.additionalInfo,\n        product_usage: sourceData.useCase.productUsage,\n        completed: true\n      });\n\n      await getSession().catch(() => undefined);\n\n      showSuccess(\n        t('onboarding.completed.title', 'Onboarding complete!'),\n        t('onboarding.completed.message', 'Welcome to Blawby AI.')\n      );\n\n      setOnboardingData(createDefaultFormData());\n      onComplete(sourceData);\n      onClose();\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.error('[ONBOARDING][SAVE] failed to save onboarding data', error);\n      }\n\n      showError(\n        t('onboarding.error.title', 'Save failed'),\n        t('onboarding.error.message', 'Unable to save your onboarding data. Please try again.')\n      );\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  const renderStep = () => {\n    switch (currentStep) {\n      case 'personal':\n        return (\n          <PersonalInfoStep\n            data={onboardingData.personalInfo}\n            isSubmitting={isSubmitting}\n            onComplete={async (data) => await handleStepComplete('personal', { personalInfo: data })}\n          />\n        );\n      case 'useCase':\n        return (\n          <UseCaseStep\n            data={onboardingData.useCase}\n            isSubmitting={isSubmitting}\n            onComplete={async (data) => await handleStepComplete('useCase', { useCase: data })}\n          />\n        );\n      default:\n        return null;\n    }\n  };\n\n  const resolvedTestId = testId ?? 'onboarding-flow';\n\n  return (\n    <div\n      className={`h-full bg-transparent flex flex-col ${className}`}\n      data-testid={resolvedTestId}\n    >\n      {renderStep()}\n    </div>\n  );\n};\n\nexport default OnboardingFlow;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/onboarding/components/PersonalInfoStep.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":43,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":43,"endColumn":20,"suggestions":[{"fix":{"range":[1380,1436],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useEffect } from 'preact/hooks';\nimport { useTranslation, Trans } from '@/shared/i18n/hooks';\nimport { Button } from '@/shared/ui/Button';\nimport { Logo } from '@/shared/ui/Logo';\nimport { UserIcon } from '@heroicons/react/24/outline';\nimport { Form, FormField, FormItem, FormLabel, FormControl, FormMessage, type FormData } from '@/shared/ui/form';\nimport { DatePicker, Checkbox, Input } from '@/shared/ui/input';\nimport { schemas } from '@/shared/ui/validation/schemas';\n\ninterface PersonalInfoData extends FormData {\n  fullName: string;\n  birthday?: string;\n  agreedToTerms: boolean;\n}\n\n\ninterface PersonalInfoStepProps {\n  data: PersonalInfoData;\n  onComplete: (data: PersonalInfoData) => void;\n  isSubmitting?: boolean;\n}\n\nconst PersonalInfoStep = ({ data: _data, onComplete, isSubmitting: parentSubmitting = false }: PersonalInfoStepProps) => {\n  const { t } = useTranslation('common');\n  const [localSubmitting, setLocalSubmitting] = useState(false);\n  const mountedRef = useRef<boolean>(true);\n\n  useEffect(() => {\n    mountedRef.current = true;\n    return () => {\n      mountedRef.current = false;\n    };\n  }, []);\n\n  const handleSubmit = async (formData: PersonalInfoData) => {\n    if (parentSubmitting || localSubmitting) return;\n    \n    setLocalSubmitting(true);\n    \n    try {\n      await onComplete(formData);\n    } catch (error) {\n      console.error('Error submitting personal info:', error);\n    } finally {\n      if (mountedRef.current) {\n        setLocalSubmitting(false);\n      }\n    }\n  };\n\n\n  return (\n    <div className=\"min-h-screen bg-transparent flex flex-col justify-center px-4 py-12 sm:px-6 lg:px-8\">\n      {/* Header */}\n      <div className=\"mx-auto w-full max-w-md\">\n        <div className=\"flex justify-center mb-6\">\n          <Logo size=\"lg\" />\n        </div>\n\n        <h2 className=\"mt-6 text-center text-3xl font-extrabold text-input-text\">\n          {t('onboarding.step1.title')}\n        </h2>\n        <p className=\"mt-2 text-center text-sm text-input-placeholder\">\n          {t('onboarding.step1.subtitle')}\n        </p>\n      </div>\n\n      <div className=\"mt-8 mx-auto w-full max-w-md\">\n        <div className=\"glass-card py-8 px-6 sm:px-10\">\n          <Form<PersonalInfoData> \n            onSubmit={async (formData: PersonalInfoData): Promise<void> => {\n              await handleSubmit(formData);\n            }} \n            initialData={_data}\n            schema={schemas.onboarding.personalInfo}\n          >\n            <div className=\"space-y-4\">\n              {/* Full Name */}\n              <FormField name=\"fullName\">\n                {({ value, error, onChange }) => (\n                  <FormItem>\n                    <FormLabel>{t('onboarding.step1.fullName')}</FormLabel>\n                    <FormControl>\n                      <Input\n                        type=\"text\"\n                        required\n                        value={(value as string) || ''}\n                        onChange={(value) => onChange(value)}\n                        placeholder={t('onboarding.step1.fullNamePlaceholder')}\n                        icon={<UserIcon className=\"h-5 w-5 text-input-placeholder\" />}\n                        error={error?.message}\n                      />\n                    </FormControl>\n                    {error && (\n                      <FormMessage>{error.message}</FormMessage>\n                    )}\n                  </FormItem>\n                )}\n              </FormField>\n\n              {/* Birthday */}\n              <FormField name=\"birthday\">\n                {({ value, error, onChange }) => (\n                  <FormItem>\n                    <FormLabel>{t('onboarding.step1.birthday')}</FormLabel>\n                    <FormControl>\n                      <DatePicker\n                        value={(value as string) || ''}\n                        onChange={(date) => onChange(date as string)}\n                        placeholder={t('onboarding.step1.birthdayPlaceholder')}\n                        isBirthday\n                        format=\"date\"\n                        max={new Date().toISOString().split('T')[0]} // Prevent future dates\n                        required\n                        error={error?.message}\n                      />\n                    </FormControl>\n                    {error && (\n                      <FormMessage>{error.message}</FormMessage>\n                    )}\n                  </FormItem>\n                )}\n              </FormField>\n\n            </div>\n\n            {/* Terms Agreement */}\n            <FormField name=\"agreedToTerms\">\n              {({ value, error, onChange }) => (\n                <FormItem>\n                  <FormControl>\n                    <Checkbox\n                      id=\"agreedToTerms\"\n                      checked={(value as boolean) || false}\n                      onChange={(checked) => onChange(checked)}\n                      label={\n                        <Trans\n                          i18nKey=\"onboarding.step1.termsAgreement\"\n                          components={{\n                            termsLink: <a href=\"https://blawby.com/terms\" className=\"text-accent-600 dark:text-accent-400 hover:text-accent-500 dark:hover:text-accent-300 underline\" aria-label=\"Terms of Service\" target=\"_blank\" rel=\"noopener noreferrer\">Terms</a>,\n                            privacyLink: <a href=\"https://blawby.com/privacy\" className=\"text-accent-600 dark:text-accent-400 hover:text-accent-500 dark:hover:text-accent-300 underline\" aria-label=\"Privacy Policy\" target=\"_blank\" rel=\"noopener noreferrer\">Privacy Policy</a>\n                          }}\n                        />\n                      }\n                      error={error?.message}\n                    />\n                  </FormControl>\n                  {error && (\n                    <FormMessage>{error.message}</FormMessage>\n                  )}\n                </FormItem>\n              )}\n            </FormField>\n\n            {/* Action Buttons */}\n            <div className=\"space-y-3\">\n              <Button\n                type=\"submit\"\n                disabled={parentSubmitting || localSubmitting}\n                variant=\"primary\"\n                size=\"lg\"\n                className=\"w-full\"\n              >\n                {(parentSubmitting || localSubmitting) ? (\n                  <div className=\"w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin\" />\n                ) : (\n                  t('onboarding.step1.continue')\n                )}\n              </Button>\n            </div>\n          </Form>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PersonalInfoStep;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/onboarding/components/UseCaseStep.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/onboarding/steps/StripeOnboardingStep.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/onboarding/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/onboarding/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/payments/pages/ClientPaymentsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/practice-setup/components/PracticeSetup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/practice-setup/utils/status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/practice/components/PracticeNotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/practice/components/PracticeProfile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/practice/components/WorkspacePracticeDetailsError.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/pricing/components/PricingView.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":54,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":54,"endColumn":22,"suggestions":[{"fix":{"range":[2276,2336],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":103,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":103,"endColumn":20,"suggestions":[{"fix":{"range":[3720,3774],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport { useEffect, useState } from 'preact/hooks';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { Button } from '@/shared/ui/Button';\nimport { SegmentedToggle } from '@/shared/ui/input';\nimport { CheckIcon } from '@heroicons/react/20/solid';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { fetchPlans, type SubscriptionPlan } from '@/shared/utils/fetchPlans';\nimport { formatCurrency } from '@/shared/utils/currencyFormatter';\nimport { i18n } from '@/shared/i18n';\nimport { usePaymentUpgrade } from '@/shared/hooks/usePaymentUpgrade';\nimport { usePracticeManagement } from '@/shared/hooks/usePracticeManagement';\n\ntype BillingPeriod = 'monthly' | 'yearly';\n\ninterface PricingViewProps {\n  onUpgrade?: (planName: string) => Promise<boolean | void> | boolean | void;\n  className?: string;\n}\n\nconst PricingView: FunctionComponent<PricingViewProps> = ({ className, onUpgrade }) => {\n  const { t } = useTranslation(['pricing', 'common']);\n  const { showError } = useToastContext();\n  const { submitUpgrade, submitting } = usePaymentUpgrade();\n  const { currentPractice } = usePracticeManagement();\n\n  const [plan, setPlan] = useState<SubscriptionPlan | null>(null);\n  const [loadError, setLoadError] = useState<string | null>(null);\n  const [billingPeriod, setBillingPeriod] = useState<BillingPeriod>('monthly');\n\n  useEffect(() => {\n    let mounted = true;\n    const controller = new AbortController();\n\n    (async () => {\n      try {\n        const availablePlans = await fetchPlans({ signal: controller.signal });\n\n        if (!mounted) return;\n\n        const visiblePlans = availablePlans.filter((plan) => plan.isActive && plan.isPublic);\n        if (visiblePlans.length === 0) {\n          throw new Error('No active public subscription plans were returned by /api/subscriptions/plans.');\n        }\n        if (visiblePlans.length !== 1) {\n          throw new Error(`Expected exactly 1 active public plan but received ${visiblePlans.length}.`);\n        }\n\n        setPlan(visiblePlans[0]);\n        setLoadError(null);\n      } catch (error) {\n        if (controller.signal.aborted || !mounted) return;\n        const errorMsg = error instanceof Error ? error.message : String(error);\n        console.error('[PricingView] Failed to load plans:', error);\n        setLoadError(errorMsg);\n      }\n    })();\n\n    return () => {\n      mounted = false;\n      controller.abort();\n    };\n  }, []);\n\n  if (loadError) {\n    return (\n      <div className=\"flex items-center justify-center p-6 text-center\">\n        <div className=\"space-y-4\">\n          <p className=\"text-lg font-semibold text-red-500\">{t('common:errors.tryAgainLater')}</p>\n          <p className=\"text-sm text-input-placeholder\">{t('pricing:errorGeneric')}</p>\n        </div>\n      </div>\n    );\n  }\n  if (!plan) {\n    return (\n      <div className=\"flex items-center justify-center p-6 text-center\">\n        <p className=\"text-sm text-input-placeholder\">Loading</p>\n      </div>\n    );\n  }\n\n  const handleUpgrade = async (plan: SubscriptionPlan) => {\n    const hasYearly = Boolean(plan.stripeYearlyPriceId && plan.yearlyPrice);\n    const isYearly = billingPeriod === 'yearly';\n    const selectedPlanName = plan.name;\n    try {\n      if (!selectedPlanName) {\n        throw new Error('Missing subscription plan name for upgrade.');\n      }\n      if (onUpgrade) {\n        const result = await onUpgrade(selectedPlanName);\n        if (result === false) {\n          return;\n        }\n      }\n      await submitUpgrade({\n        practiceId: currentPractice?.id || undefined,\n        plan: selectedPlanName,\n        annual: isYearly && hasYearly\n      });\n    } catch (error) {\n      console.error('Error during upgrade process:', error);\n      const message = error instanceof Error ? error.message : t('common:errors.tryAgainLater');\n      showError(t('pricing:upgradeFailed'), message);\n    }\n  };\n\n  const isYearly = billingPeriod === 'yearly';\n  const hasYearly = Boolean(plan.stripeYearlyPriceId && plan.yearlyPrice);\n  const features = Array.isArray(plan.features)\n    ? plan.features.filter((feature): feature is string => typeof feature === 'string' && feature.trim().length > 0)\n    : [];\n  const monthlyPriceValue = Number.parseFloat(plan.monthlyPrice);\n  const yearlyPriceValue = plan.yearlyPrice ? Number.parseFloat(plan.yearlyPrice) : NaN;\n  const selectedPriceValue = isYearly && hasYearly\n    ? yearlyPriceValue\n    : monthlyPriceValue;\n  const resolvedPriceValue = Number.isFinite(selectedPriceValue) ? selectedPriceValue : 0;\n  const periodLabel = isYearly && hasYearly\n    ? t('pricing:billing.yearly')\n    : t('pricing:billing.monthly');\n  const billingDescription = isYearly && hasYearly\n    ? t('pricing:billing.billedAnnually')\n    : t('pricing:billing.billedMonthly');\n  const monthlyLabel = t('pricing:billing.monthly');\n  const annuallyLabel = t('pricing:billing.annually', {\n    defaultValue: t('pricing:billing.yearly')\n  });\n  const yearlyDiscountPercent = (() => {\n    if (!hasYearly || !Number.isFinite(monthlyPriceValue) || !Number.isFinite(yearlyPriceValue)) {\n      return null;\n    }\n    const annualizedMonthly = monthlyPriceValue * 12;\n    if (annualizedMonthly <= 0 || yearlyPriceValue <= 0 || yearlyPriceValue >= annualizedMonthly) {\n      return null;\n    }\n    const discount = ((annualizedMonthly - yearlyPriceValue) / annualizedMonthly) * 100;\n    const roundedDiscount = Math.round(discount);\n    return roundedDiscount > 0 ? roundedDiscount : null;\n  })();\n  const annuallyLabelWithDiscount = yearlyDiscountPercent\n    ? `${annuallyLabel} -${yearlyDiscountPercent}%`\n    : annuallyLabel;\n  const billingOptions: Array<{ value: BillingPeriod; label: string; disabled?: boolean }> = [\n    { value: 'monthly', label: monthlyLabel },\n    { value: 'yearly', label: annuallyLabelWithDiscount, disabled: !hasYearly }\n  ];\n  return (\n    <div className={`w-full text-input-text ${className ?? ''}`}>\n      <div className=\"mx-auto w-full max-w-xl px-2 pt-2 pb-2 md:px-3 md:pt-3 md:pb-3\">\n        <div className=\"flex justify-center pb-1\">\n          <SegmentedToggle<BillingPeriod>\n            className=\"w-full max-w-[420px]\"\n            value={billingPeriod}\n            options={billingOptions}\n            onChange={setBillingPeriod}\n            ariaLabel=\"Payment frequency\"\n            disabled={submitting}\n          />\n        </div>\n\n        <div className=\"mt-6 glass-card px-5 py-6 md:px-7 md:py-8\">\n          <div className=\"flex flex-col items-start text-left\">\n            <h1 data-testid=\"pricing-page-title\" className=\"text-3xl font-semibold tracking-tight text-input-text md:text-4xl\">\n              {plan.displayName || plan.name}\n            </h1>\n            {plan.description ? (\n              <p className=\"mt-4 max-w-xl text-base leading-7 text-input-placeholder\">\n                {plan.description}\n              </p>\n            ) : null}\n            <div className=\"mt-7 flex items-end gap-1.5\">\n              <span className=\"text-5xl font-semibold tracking-tight text-input-text md:text-6xl\">\n                {formatCurrency(resolvedPriceValue, plan.currency, i18n.language)}\n              </span>\n              <span className=\"pb-1 text-xl font-semibold text-input-placeholder md:pb-2 md:text-2xl\">/{periodLabel}</span>\n            </div>\n          </div>\n\n          <div className=\"mt-8\">\n            {features.length > 0 ? (\n              <ul className=\"space-y-3 text-base text-input-placeholder\">\n                {features.map((feature) => (\n                  <li key={feature} className=\"flex items-start gap-2\">\n                    <CheckIcon className=\"mt-0.5 h-5 w-5 flex-none text-accent-500\" />\n                    <span>{feature}</span>\n                  </li>\n                ))}\n              </ul>\n            ) : (\n              <p className=\"text-base text-input-placeholder\">{t('pricing:noFeatures')}</p>\n            )}\n          </div>\n\n          <div className=\"mt-8\">\n            <Button\n              onClick={() => handleUpgrade(plan)}\n              variant=\"primary\"\n              size=\"lg\"\n              className=\"h-14 w-full\"\n              disabled={submitting}\n            >\n              {submitting\n                ? t('pricing:modal.openingBilling')\n                : t('pricing:upgradeButton', {\n                    price: formatCurrency(\n                      resolvedPriceValue,\n                      plan.currency,\n                      i18n.language\n                    )\n                  })}\n            </Button>\n            <p className=\"mt-4 text-center text-sm text-input-placeholder\">\n              {billingDescription}\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PricingView;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/services/components/ServiceCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/services/components/ServiceForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/services/components/ServicesEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/services/components/ServicesList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/services/data/serviceCatalog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/services/hooks/useServices.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/services/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/services/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/services/utils/serviceNormalization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/__tests__/SettingsPage.integration.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/AppConnectionModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/DomainSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/EmailSettingsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/NotificationChannelSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/PasswordChangeForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/PlanFeaturesList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingDescription.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingRow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingSelect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingsBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingsDangerButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingsHelperText.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingsLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingsNotice.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingsPageLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/SettingsSubheader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/components/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/hooks/useNotificationSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/hooks/usePracticePageEffects.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":80,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":80,"endColumn":24,"suggestions":[{"fix":{"range":[2238,2294],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, type StateUpdater, type Dispatch } from 'preact/hooks';\nimport type { Practice } from '@/shared/hooks/usePracticeManagement';\n\nexport type EditPracticeFormState = {\n  name: string;\n  slug: string;\n  logo: string;\n};\n\ntype ShowToast = (title: string, message?: string) => void;\n\nexport const useLeadQueueAutoLoad = (loadLeadQueue: () => Promise<void> | void) => {\n  useEffect(() => {\n    void loadLeadQueue();\n  }, [loadLeadQueue]);\n};\n\nexport const usePracticeMembersSync = ({\n  practice,\n  setEditPracticeForm,\n  fetchMembers,\n  showError\n}: {\n  practice: Practice | null;\n  setEditPracticeForm: Dispatch<StateUpdater<EditPracticeFormState>>;\n  fetchMembers: (practiceId: string) => Promise<void>;\n  showError: ShowToast;\n}) => {\n  useEffect(() => {\n    if (!practice) return;\n    setEditPracticeForm({\n      name: practice.name,\n      slug: practice.slug || '',\n      logo: practice.logo || ''\n    });\n\n    const fetchMembersData = async () => {\n      try {\n        await fetchMembers(practice.id);\n      } catch (err) {\n        const message = err instanceof Error ? err.message : String(err);\n        showError(message || 'Failed to fetch practice members');\n      }\n    };\n\n    void fetchMembersData();\n  }, [practice, fetchMembers, setEditPracticeForm, showError]);\n};\n\nexport const usePracticeSyncParamRefetch = ({\n  location,\n  practiceId,\n  refetch,\n  showSuccess\n}: {\n  location: unknown;\n  practiceId: string | null | undefined;\n  refetch: () => Promise<void>;\n  showSuccess: ShowToast;\n}) => {\n  useEffect(() => {\n    const syncParam = (() => {\n      const q = (location as { query?: Record<string, unknown> } | undefined)?.query;\n      if (q && typeof q === 'object' && 'sync' in q) {\n        const v = q['sync'] as unknown;\n        return Array.isArray(v) ? v[0] : (v as string | undefined);\n      }\n      if (typeof window !== 'undefined') {\n        return new URLSearchParams(window.location.search).get('sync') ?? undefined;\n      }\n      return undefined;\n    })();\n\n    if (String(syncParam) === '1' && practiceId) {\n      refetch()\n        .then(() => {\n          showSuccess('Subscription updated', 'Your subscription status has been refreshed.');\n        })\n        .catch((error) => {\n          console.error('Failed to refresh subscription:', error);\n        })\n        .finally(() => {\n          if (typeof window !== 'undefined') {\n            const newUrl = new URL(window.location.href);\n            newUrl.searchParams.delete('sync');\n            window.history.replaceState({}, '', newUrl.toString());\n          }\n        });\n    }\n  }, [location, practiceId, refetch, showSuccess]);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/hooks/useSettingsNavigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/hooks/useUserProfile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/AccountPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":98,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":98,"endColumn":19,"suggestions":[{"fix":{"range":[5283,5363],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":138,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":138,"endColumn":20,"suggestions":[{"fix":{"range":[6749,6802],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":204,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":204,"endColumn":20,"suggestions":[{"fix":{"range":[9661,9734],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":243,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":243,"endColumn":24,"suggestions":[{"fix":{"range":[11068,11132],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":254,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":254,"endColumn":24,"suggestions":[{"fix":{"range":[11549,11605],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":329,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":329,"endColumn":21,"suggestions":[{"fix":{"range":[13990,14066],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":436,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":436,"endColumn":20,"suggestions":[{"fix":{"range":[18058,18108],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":557,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":557,"endColumn":20,"suggestions":[{"fix":{"range":[21844,21893],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":629,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":629,"endColumn":22,"suggestions":[{"fix":{"range":[24336,24385],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":654,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":654,"endColumn":20,"suggestions":[{"fix":{"range":[25114,25171],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef, useCallback, useMemo } from 'preact/hooks';\nimport { Button } from '@/shared/ui/Button';\nimport { Input, LogoUploadInput } from '@/shared/ui/input';\nimport { Combobox } from '@/shared/ui/input/Combobox';\nimport { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem } from '@/shared/ui/dropdown';\nimport { SectionDivider } from '@/shared/ui';\nimport Modal from '@/shared/components/Modal';\nimport ConfirmationDialog from '@/shared/components/ConfirmationDialog';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { signOut } from '@/shared/utils/auth';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { usePaymentUpgrade } from '@/shared/hooks/usePaymentUpgrade';\nimport { useLocation } from 'preact-iso';\nimport { usePracticeManagement } from '@/shared/hooks/usePracticeManagement';\nimport { formatDate } from '@/shared/utils/dateTime';\nimport { deleteUser, getSession, updateUser } from '@/shared/lib/authClient';\nimport { getCurrentSubscription, type CurrentSubscription } from '@/shared/lib/apiClient';\nimport { uploadWithProgress } from '@/shared/services/upload/UploadTransport';\nimport { ChevronDownIcon, XMarkIcon, GlobeAltIcon, PlusIcon } from '@heroicons/react/24/outline';\nimport type { UserLinks, EmailSettings } from '@/shared/types/user';\nimport { SettingRow } from '@/features/settings/components/SettingRow';\nimport { SettingSection } from '@/features/settings/components/SettingSection';\nimport { PlanFeaturesList, type PlanFeature } from '@/features/settings/components/PlanFeaturesList';\nimport { EmailSettingsSection } from '@/features/settings/components/EmailSettingsSection';\nimport { SettingsPageLayout } from '@/features/settings/components/SettingsPageLayout';\nimport { SettingsDangerButton } from '@/features/settings/components/SettingsDangerButton';\nimport { SettingsHelperText } from '@/features/settings/components/SettingsHelperText';\nimport { getPreferencesCategory, updatePreferencesCategory } from '@/shared/lib/preferencesApi';\nimport type { AccountPreferences } from '@/shared/types/preferences';\nimport { FormActions, FormLabel } from '@/shared/ui/form';\n\n\nexport interface AccountPageProps {\n  isMobile?: boolean;\n  onClose?: () => void;\n  className?: string;\n}\n\nconst DOMAIN_SELECT_VALUE = '__select__';\n\nconst parsePeriodEndDate = (value: string | number | null | undefined): Date | null => {\n  if (value === null || value === undefined) return null;\n  const numeric = Number(value);\n  if (Number.isFinite(numeric)) {\n    const d = new Date(numeric * 1000);\n    return isNaN(d.getTime()) ? null : d;\n  }\n  const d = new Date(value);\n  return isNaN(d.getTime()) ? null : d;\n};\n\nexport const AccountPage = ({\n  isMobile: _isMobile = false,\n  onClose: _onClose,\n  className = ''\n}: AccountPageProps) => {\n  const { showSuccess, showError } = useToastContext();\n  const location = useLocation();\n  const { navigate, navigateToPricing } = useNavigation();\n  const { t } = useTranslation(['settings', 'common']);\n  const { openBillingPortal, submitting } = usePaymentUpgrade();\n  const { currentPractice, loading: practiceLoading, refetch } = usePracticeManagement();\n  const { session, isPending, activeMemberRole, workspaceAccess } = useSessionContext();\n  const [links, setLinks] = useState<UserLinks | null>(null);\n  const [emailSettings, setEmailSettings] = useState<EmailSettings | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [currentSubscription, setCurrentSubscription] = useState<CurrentSubscription | null>(null);\n  const [subscriptionError, setSubscriptionError] = useState<string | null>(null);\n  const [subscriptionLoading, setSubscriptionLoading] = useState(true);\n  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);\n  const [showDomainModal, setShowDomainModal] = useState(false);\n  const [domainInput, setDomainInput] = useState('');\n  const [domainError, setDomainError] = useState<string | null>(null);\n  const [deleteVerificationSent, setDeleteVerificationSent] = useState(false);\n  const [passwordRequiredOverride, setPasswordRequiredOverride] = useState<boolean | null>(null);\n  const [avatarUploading, setAvatarUploading] = useState(false);\n  const [avatarUploadProgress, setAvatarUploadProgress] = useState<number | null>(null);\n  const [avatarPreviewUrl, setAvatarPreviewUrl] = useState<string | null>(null);\n  const avatarObjectUrlRef = useRef<string | null>(null);\n  \n\n  const hasSubscription = workspaceAccess.practice;\n  \n  // Get renewal date from subscription current_period_end first, then practice webhook period end.\n  const renewalDate = useMemo(() => {\n    if (!hasSubscription) return null;\n    return parsePeriodEndDate(currentSubscription?.currentPeriodEnd) || \n           parsePeriodEndDate(currentPractice?.subscriptionPeriodEnd);\n  }, [hasSubscription, currentSubscription?.currentPeriodEnd, currentPractice?.subscriptionPeriodEnd]);\n\n  const clearLocalAuthState = useCallback(() => {\n    try {\n      localStorage.removeItem('onboardingCompleted');\n      localStorage.removeItem('onboardingCheckDone');\n    } catch (error) {\n      console.warn('Failed to clear onboarding flags after account deletion:', error);\n    }\n  }, []);\n\n  // Ref to store verification timeout ID for cleanup\n  const verificationTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  // Ref to track if component is mounted to prevent state updates after unmount\n  const isMountedRef = useRef(true);\n  // Load account data from Better Auth session\n  const loadAccountData = useCallback(async () => {\n    if (!session?.user) return;\n    \n    try {\n      setError(null);\n      const prefs = await getPreferencesCategory<AccountPreferences>('account');\n      const user = session.user;\n      const customDomains = Array.isArray(prefs?.custom_domains) ? prefs?.custom_domains : [];\n      \n      const linksData: UserLinks = {\n        selectedDomain: prefs?.selected_domain || 'Select a domain',\n        linkedinUrl: null,\n        githubUrl: null,\n        customDomains: customDomains.map((domain) => ({\n          domain,\n          verified: false,\n          verifiedAt: null\n        }))\n      };\n      \n      // Convert user data to email settings format\n      const emailData: EmailSettings = {\n        email: user.email,\n        receiveFeedbackEmails: prefs?.receive_feedback_emails ?? false,\n        marketingEmails: prefs?.marketing_emails ?? false,\n        securityAlerts: prefs?.security_alerts ?? true\n      };\n      \n      setLinks(linksData);\n      setEmailSettings(emailData);\n    } catch (error) {\n      console.error('Failed to load account data:', error);\n      setError(error instanceof Error ? error.message : String(error));\n    }\n  }, [session?.user]);\n\n  // Load account data when component mounts or practice changes\n  // Only load when practice data is available (not loading) and session is available\n  useEffect(() => {\n    if (!practiceLoading && currentPractice !== undefined && session?.user) {\n      loadAccountData();\n    }\n  }, [loadAccountData, practiceLoading, currentPractice, session?.user]);\n\n  // Detect OAuth vs password users based on lastLoginMethod\n  const userWithExtendedProps = session?.user as typeof session.user & {\n    lastLoginMethod?: string;\n  };\n  const normalizedLoginMethod = userWithExtendedProps?.lastLoginMethod\n    ? String(userWithExtendedProps.lastLoginMethod).toLowerCase()\n    : null;\n  const loginMethodRequiresPassword = normalizedLoginMethod\n    ? ['email', 'credential', 'password'].includes(normalizedLoginMethod)\n    : false;\n  const requiresPassword = passwordRequiredOverride ?? loginMethodRequiresPassword;\n  const isOAuthUser = !requiresPassword;\n\n  const isOwner = activeMemberRole === 'owner';\n  const canManageBilling = isOwner;\n\n  const subscriptionStatus = (currentSubscription?.status ?? 'none').toLowerCase();\n  const subscriptionEnd = parsePeriodEndDate(currentSubscription?.currentPeriodEnd) || \n                           parsePeriodEndDate(currentPractice?.subscriptionPeriodEnd);\n  const hasActiveSubscription = currentSubscription !== null && \n    ['active', 'trialing', 'past_due'].includes((currentSubscription.status || '').toLowerCase());\n  const hasActivePeriod = Boolean(subscriptionEnd && subscriptionEnd.getTime() > Date.now());\n  const deletionBlockedBySubscription = isOwner && (hasActiveSubscription || hasActivePeriod);\n  const isDeleteBlocked = deletionBlockedBySubscription;\n  const deletionBlockedMessage = (() => {\n    if (!deletionBlockedBySubscription) {\n      return '';\n    }\n    if (subscriptionStatus === 'canceled' && subscriptionEnd) {\n      return `Subscription will end on ${formatDate(subscriptionEnd)}. You can delete your account after it ends.`;\n    }\n    if (subscriptionEnd) {\n      return `Subscription is active until ${formatDate(subscriptionEnd)}. Cancel it before deleting your account.`;\n    }\n    return 'Subscription must be canceled before deleting your account.';\n  })();\n\n  // SSR-safe origin for return URLs\n  const origin = (typeof window !== 'undefined' && window.location)\n    ? window.location.origin\n    : '';\n\n  const refreshSubscription = useCallback(async (signal?: AbortSignal) => {\n    if (!session?.user) return;\n    setSubscriptionLoading(true);\n    try {\n      const subscription = await getCurrentSubscription({ signal });\n      setCurrentSubscription(subscription);\n      setSubscriptionError(null);\n    } catch (fetchError) {\n      if (signal?.aborted) {\n        return;\n      }\n      console.error('[Account] Failed to load subscription state', fetchError);\n      setSubscriptionError('Unable to load subscription state from API.');\n      setCurrentSubscription(null);\n    } finally {\n      setSubscriptionLoading(false);\n    }\n  }, [session?.user]);\n\n  useEffect(() => {\n    if (!session?.user) {\n      setCurrentSubscription(null);\n      setSubscriptionError(null);\n      setSubscriptionLoading(false);\n      return;\n    }\n    const controller = new AbortController();\n    void refreshSubscription(controller.signal);\n    return () => controller.abort();\n  }, [refreshSubscription, session?.user]);\n\n  // Refetch after return from Stripe portal or checkout\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    const params = new URLSearchParams(window.location.search);\n    if (params.get('sync') === '1' && currentPractice?.id) {\n      const controller = new AbortController();\n      \n      // Cleanup URL immediately to avoid re-triggering on slow re-renders\n      const newUrl = new URL(window.location.href);\n      newUrl.searchParams.delete('sync');\n      location.route(newUrl.pathname + newUrl.search, true);\n\n      void (async () => {\n        let refreshSucceeded = false;\n        try {\n          await refreshSubscription(controller.signal);\n          refreshSucceeded = true;\n        } catch (error) {\n          if (controller.signal.aborted) return;\n          console.error('Failed to refresh current subscription:', error);\n        }\n\n        try {\n          // Note: refetch from usePracticeManagement does not currently support AbortSignal cancellation\n          await refetch();\n          if (!controller.signal.aborted && refreshSucceeded) {\n            showSuccess('Subscription updated', 'Your subscription status has been refreshed.');\n          }\n        } catch (error) {\n          if (controller.signal.aborted) return;\n          console.error('Failed to refresh subscription:', error);\n        }\n      })();\n\n      return () => controller.abort();\n    }\n  }, [currentPractice?.id, refetch, refreshSubscription, showSuccess, location]);\n\n  // Cleanup verification timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (verificationTimeoutRef.current !== null) {\n        clearTimeout(verificationTimeoutRef.current);\n      }\n      isMountedRef.current = false;\n    };\n  }, []);\n\n\n  // No need for custom event listeners - Better Auth handles reactivity automatically\n\n  // Simple computed values for demo - only compute when currentTier is available\n  const currentPlanFeatures = (() => {\n    const backendFeatures = currentSubscription?.plan?.features;\n    if (!Array.isArray(backendFeatures)) {\n      return [] as PlanFeature[];\n    }\n    return backendFeatures.map((feature): PlanFeature => ({\n      icon: PlusIcon,\n      text: feature\n    }));\n  })();\n  const emailAddress = emailSettings?.email || session?.user?.email || '';\n  const displayName = session?.user?.name || emailAddress || '';\n  const currentAvatarUrl = avatarPreviewUrl ?? session?.user?.image ?? null;\n\n  const handleAvatarChange = useCallback(async (files: FileList | File[]) => {\n    const fileList = Array.isArray(files) ? files : Array.from(files ?? []);\n    const [file] = fileList;\n    if (!file) return;\n\n    if (!currentPractice?.id) {\n      showError('Select a practice first', 'Choose a practice before uploading a profile photo.');\n      return;\n    }\n\n    if (!file.type.startsWith('image/')) {\n      showError('Invalid file', 'Please select an image file.');\n      return;\n    }\n\n    const maxSize = 5 * 1024 * 1024;\n    if (file.size > maxSize) {\n      showError('File too large', 'Please upload an image under 5 MB.');\n      return;\n    }\n\n    if (avatarObjectUrlRef.current) {\n      URL.revokeObjectURL(avatarObjectUrlRef.current);\n      avatarObjectUrlRef.current = null;\n    }\n\n    const previewUrl = URL.createObjectURL(file);\n    avatarObjectUrlRef.current = previewUrl;\n    setAvatarPreviewUrl(previewUrl);\n    setAvatarUploading(true);\n    setAvatarUploadProgress(0);\n\n    try {\n      const uploaded = await uploadWithProgress(file, {\n        practiceId: currentPractice.id,\n        onProgress: (progress) => setAvatarUploadProgress(progress.percentage)\n      });\n      await updateUser({ image: uploaded.url });\n      await getSession().catch((error) => {\n        console.warn('[Account] Session refresh failed after avatar update', error);\n      });\n\n      if (avatarObjectUrlRef.current) {\n        URL.revokeObjectURL(avatarObjectUrlRef.current);\n        avatarObjectUrlRef.current = null;\n      }\n      setAvatarPreviewUrl(null);\n      showSuccess('Profile photo updated', 'Your avatar has been saved.');\n    } catch (error) {\n      showError('Avatar upload failed', error instanceof Error ? error.message : 'Unable to upload image.');\n      if (avatarObjectUrlRef.current) {\n        URL.revokeObjectURL(avatarObjectUrlRef.current);\n        avatarObjectUrlRef.current = null;\n      }\n      setAvatarPreviewUrl(session?.user?.image ?? null);\n    } finally {\n      setAvatarUploading(false);\n      setAvatarUploadProgress(null);\n    }\n  }, [currentPractice?.id, session?.user?.image, showError, showSuccess]);\n\n  useEffect(() => {\n    return () => {\n      if (avatarObjectUrlRef.current) {\n        URL.revokeObjectURL(avatarObjectUrlRef.current);\n        avatarObjectUrlRef.current = null;\n      }\n    };\n  }, []);\n  const customDomainOptions = (links?.customDomains || []).map(domain => ({\n    value: domain.domain,\n    label: domain.domain\n  }));\n  const deleteListItems = t('settings:account.delete.listItems', { returnObjects: true }) as string[];\n  const _confirmLabel = t('settings:account.delete.confirmLabel', { email: emailAddress });\n  const selectedDomain = links?.selectedDomain && links.selectedDomain !== 'Select a domain'\n    ? links.selectedDomain\n    : DOMAIN_SELECT_VALUE;\n  const showLinksSection = false;\n  const showFeedbackToggle = false;\n\n\n  \n\n  const handleDeleteAccount = () => {\n    if (subscriptionLoading) {\n      showError('Checking subscription', 'Please wait while we verify your subscription status.');\n      return;\n    }\n    if (isDeleteBlocked) {\n      const endLabel = subscriptionEnd ? `Access ends on ${formatDate(subscriptionEnd)}.` : undefined;\n      const message = subscriptionStatus === 'canceled'\n        ? `Your subscription is scheduled to cancel. ${endLabel ?? ''} You can delete your account after it ends.`\n        : `Your subscription is still active. ${endLabel ?? ''} Please cancel it before deleting your account.`;\n      showError('Account deletion unavailable', message.trim());\n      return;\n    }\n    setShowDeleteConfirm(true);\n    setDeleteVerificationSent(false);\n    setPasswordRequiredOverride(null);\n  };\n\n  const passwordLabel = t('settings:account.delete.passwordLabel', {\n    defaultValue: 'Enter your password to confirm deletion.'\n  });\n  const passwordPlaceholder = t('settings:account.delete.passwordPlaceholder', {\n    defaultValue: 'Current password'\n  });\n  const passwordRequiredMessage = t('settings:account.delete.passwordRequired', {\n    defaultValue: 'Password is required to delete your account.'\n  });\n\n  const handleConfirmDelete = async ({ password }: { password?: string } = {}) => {\n    try {\n      if (isOAuthUser) {\n        // OAuth users: just call deleteUser, triggers verification email\n        await deleteUser();\n        setDeleteVerificationSent(true);\n        clearLocalAuthState();\n        showSuccess(\n          t('settings:account.delete.verificationSentTitle'),\n          t('settings:account.delete.verificationSentBody')\n        );\n      } else {\n        // Password users: call deleteUser with password (handled by Better Auth)\n        if (!password || password.trim().length === 0) {\n          throw new Error(passwordRequiredMessage);\n        }\n        await deleteUser({ password });\n        await signOut({ navigate }); // Use top-level signOut from utils/auth\n        setShowDeleteConfirm(false);\n        setDeleteVerificationSent(false);\n        setPasswordRequiredOverride(null);\n        clearLocalAuthState();\n        showSuccess(\n          t('settings:account.delete.toastSuccessTitle'),\n          t('settings:account.delete.toastSuccessBody')\n        );\n        if (_onClose) {\n          _onClose();\n        }\n        setTimeout(() => {\n          navigate('/', true);\n        }, 1000);\n      }\n    } catch (error) {\n      console.error('Failed to delete account:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      \n      // Type-safe error property extraction\n      const getErrorCode = (err: unknown): string | undefined => {\n        if (typeof err === 'object' && err !== null) {\n          const errorObj = err as Record<string, unknown>;\n          // Check for direct code property\n          if ('code' in errorObj && typeof errorObj.code === 'string') {\n            return errorObj.code;\n          }\n          // Check for nested data.code property\n          if ('data' in errorObj && typeof errorObj.data === 'object' && errorObj.data !== null) {\n            const dataObj = errorObj.data as Record<string, unknown>;\n            if ('code' in dataObj && typeof dataObj.code === 'string') {\n              return dataObj.code;\n            }\n          }\n        }\n        return undefined;\n      };\n      \n      const errorCode = getErrorCode(error);\n      const maybePasswordRequired =\n        errorCode === 'PASSWORD_REQUIRED' ||\n        /password/i.test(errorMessage);\n\n      if (maybePasswordRequired) {\n        setPasswordRequiredOverride(true);\n      }\n\n      throw error; // Let ConfirmationDialog handle error display\n    }\n  };\n\n  const handleCancelDelete = () => {\n    setShowDeleteConfirm(false);\n    setDeleteVerificationSent(false);\n    setPasswordRequiredOverride(null);\n  };\n\n  // Domain validation function\n  const validateDomain = (domain: string): string | null => {\n    const trimmed = domain.trim();\n    \n    if (!trimmed) {\n      return 'settings:account.domainErrors.empty';\n    }\n    \n    if (trimmed !== domain) {\n      return 'settings:account.domainErrors.spaces';\n    }\n    \n    // Basic domain format validation regex\n    const domainRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n    if (!domainRegex.test(trimmed)) {\n      return 'settings:account.domainErrors.format';\n    }\n    \n    // Check for duplicates (case-insensitive)\n    const existingDomains = links?.customDomains?.map(d => d.domain.toLowerCase()) || [];\n    if (existingDomains.includes(trimmed.toLowerCase())) {\n      return 'settings:account.domainErrors.duplicate';\n    }\n    \n    return null;\n  };\n\n  const handleOpenDomainModal = () => {\n    setShowDomainModal(true);\n    setDomainInput('');\n    setDomainError(null);\n  };\n\n  const handleCloseDomainModal = () => {\n    setShowDomainModal(false);\n    setDomainInput('');\n    setDomainError(null);\n  };\n\n  const handleDomainSubmit = async () => {\n    const errorKey = validateDomain(domainInput);\n    if (errorKey) {\n      const message = t(errorKey);\n      setDomainError(message);\n      showError(t('settings:account.links.invalidDomainToast.title'), message);\n      return;\n    }\n\n    const normalized = domainInput.trim().toLowerCase();\n    \n    try {\n      // Create updated custom domains array\n      const updatedCustomDomains = [\n        ...(links?.customDomains || []),\n        {\n          domain: normalized,\n          verified: false,\n          verifiedAt: null\n        }\n      ];\n      \n      // Update user in database with both selectedDomain and customDomains\n      await updatePreferencesCategory('account', {\n        selected_domain: normalized,\n        custom_domains: updatedCustomDomains.map((entry) => entry.domain)\n      });\n      \n      const updatedLinks = {\n        ...links,\n        selectedDomain: normalized,\n        customDomains: updatedCustomDomains\n      };\n      \n      setLinks(updatedLinks);\n      handleCloseDomainModal();\n      showSuccess(\n        t('settings:account.links.addDomainToast.title'),\n        t('settings:account.links.addDomainToast.body', { domain: normalized })\n      );\n    } catch (error) {\n      console.error('Failed to update domain:', error);\n      showError(\n        t('common:notifications.settingsSaveErrorTitle'),\n        t('common:notifications.settingsSaveErrorBody')\n      );\n    }\n    \n    // Simulate domain verification process with cancellable timeout\n    // Clear any existing verification timeout to prevent race conditions\n    if (verificationTimeoutRef.current !== null) {\n      clearTimeout(verificationTimeoutRef.current);\n    }\n    \n    verificationTimeoutRef.current = setTimeout(() => {\n      // Use functional state update to avoid overwriting concurrent changes\n      setLinks(currentLinks => {\n        if (!currentLinks) return currentLinks;\n        \n        const updatedVerifyLinks = {\n          ...currentLinks,\n          customDomains: currentLinks.customDomains?.map(domain => \n            domain.domain === normalized \n              ? { ...domain, verified: true, verifiedAt: new Date().toISOString() }\n              : domain\n          ) || []\n        };\n        \n        // Note: Domain verification would be handled by the backend\n        // For now, we just update the local state\n        \n        // Show success toast with translated strings\n        showSuccess(\n          t('settings:account.links.verifiedToast.title'),\n          t('settings:account.links.verifiedToast.body', { domain: normalized })\n        );\n        \n        return updatedVerifyLinks;\n      });\n      \n      // Clear the timeout reference\n      verificationTimeoutRef.current = null;\n    }, 3000); // Simulate 3-second verification process\n  };\n\n  const handleAddLinkedIn = () => {\n    showSuccess(\n      t('settings:account.links.linkedinToast.title'),\n      t('settings:account.links.linkedinToast.body')\n    );\n  };\n\n  const handleAddGitHub = () => {\n    showSuccess(\n      t('settings:account.links.githubToast.title'),\n      t('settings:account.links.githubToast.body')\n    );\n  };\n\n  const handleDomainChange = async (domain: string) => {\n    if (domain === 'verify-new') {\n      // Handle \"Verify new domain\" option\n      handleOpenDomainModal();\n    } else if (domain !== DOMAIN_SELECT_VALUE) {\n      try {\n      // Update user in database with current custom domains\n        await updatePreferencesCategory('account', {\n          selected_domain: domain,\n          custom_domains: (links?.customDomains || []).map((entry) => entry.domain)\n        });\n        \n        setLinks(prev => prev ? { ...prev, selectedDomain: domain } : prev);\n      } catch (error) {\n        console.error('Failed to update domain:', error);\n        showError(\n          t('common:notifications.settingsSaveErrorTitle'),\n          t('common:notifications.settingsSaveErrorBody')\n        );\n      }\n    } else {\n      setLinks(prev => (prev ? { ...prev, selectedDomain: prev.selectedDomain ?? domain } : prev));\n    }\n  };\n\n  const handleFeedbackEmailsChange = async (checked: boolean) => {\n    try {\n      await updatePreferencesCategory('account', { receive_feedback_emails: checked });\n      \n      setEmailSettings(prev => prev ? { \n        ...prev, \n        receiveFeedbackEmails: checked \n      } : { \n        email: '', \n        receiveFeedbackEmails: checked, \n        marketingEmails: false, \n        securityAlerts: false \n      });\n    } catch (error) {\n      console.error('Failed to update email settings:', error);\n      showError(\n        t('common:notifications.settingsSaveErrorTitle'),\n        t('common:notifications.settingsSaveErrorBody')\n      );\n    }\n  };\n\n  // Features are now loaded dynamically from the pricing service\n\n  // Show loading state while session or practice is loading\n  // Add timeout protection - if loading for more than 10 seconds, show error with retry\n  const [loadingTimeout, setLoadingTimeout] = useState(false);\n  useEffect(() => {\n    if (isPending || practiceLoading || subscriptionLoading) {\n      const timeout = setTimeout(() => {\n        setLoadingTimeout(true);\n      }, 10000); // 10 second timeout\n      return () => clearTimeout(timeout);\n    } else {\n      setLoadingTimeout(false);\n    }\n  }, [isPending, practiceLoading, subscriptionLoading]);\n\n  if ((isPending || practiceLoading || subscriptionLoading) && !loadingTimeout) {\n    return (\n      <div className={`h-full flex items-center justify-center ${className}`}>\n        <div className=\"w-8 h-8 border-2 border-accent-500 border-t-transparent rounded-full animate-spin\" />\n      </div>\n    );\n  }\n\n  if (loadingTimeout || error) {\n    throw new Error(\n      loadingTimeout\n        ? 'Loading timed out. Please check your connection and try again.'\n        : (error || 'An error occurred while loading your account information.')\n    );\n  }\n\n  const currentPlanLabel = hasSubscription\n    ? (currentSubscription?.plan?.displayName || currentSubscription?.plan?.name || t('settings:account.plan.tiers.free'))\n    : t('settings:account.plan.tiers.free');\n\n  return (\n    <SettingsPageLayout title={t('settings:account.title')} className={className}>\n      <SettingRow label={t('settings:account.nameLabel')}>\n        <span className=\"text-sm text-input-text\">\n          {displayName}\n        </span>\n      </SettingRow>\n      <SettingRow label=\"Profile photo\" description=\"Upload a square image (max 5 MB).\">\n        <div className=\"w-full\">\n          <LogoUploadInput\n            imageUrl={currentAvatarUrl}\n            name={displayName}\n            accept=\"image/*\"\n            multiple={false}\n            onChange={handleAvatarChange}\n            disabled={avatarUploading}\n            progress={avatarUploading ? avatarUploadProgress : null}\n          />\n        </div>\n      </SettingRow>\n\n      <SectionDivider />\n\n          {/* Subscription Plan Section */}\n          <SettingRow\n            label={currentPlanLabel}\n            labelClassName=\"text-input-text font-semibold\"\n            description={\n              hasSubscription && renewalDate\n                ? t('settings:account.plan.autoRenews', { date: formatDate(renewalDate) })\n                : undefined\n            }\n          >\n            <div className=\"flex gap-2\">\n              {hasSubscription ? (\n                currentPractice && isOwner && canManageBilling ? (\n                  <DropdownMenu>\n                    <DropdownMenuTrigger asChild>\n                      <Button\n                        variant=\"secondary\"\n                        size=\"sm\"\n                        disabled={submitting}\n                        icon={<ChevronDownIcon className=\"w-4 h-4\" />}\n                        iconPosition=\"right\"\n                      >\n                        {t('settings:account.plan.manage')}\n                      </Button>\n                    </DropdownMenuTrigger>\n                    <DropdownMenuContent align=\"end\">\n                      <DropdownMenuItem\n                        onSelect={() => {\n                          if (!currentPractice) return;\n                          void openBillingPortal({\n                            practiceId: currentPractice.id,\n                            returnUrl: origin ? `${origin}/settings/account?sync=1` : '/settings/account?sync=1'\n                          });\n                        }}\n                      >\n                        <span className=\"flex items-center gap-2 text-red-600 dark:text-red-400\">\n                          <XMarkIcon className=\"h-4 w-4\" />\n                          {t('settings:account.plan.cancelSubscription')}\n                        </span>\n                      </DropdownMenuItem>\n                    </DropdownMenuContent>\n                  </DropdownMenu>\n                ) : null\n              ) : (\n                <Button\n                  variant=\"secondary\"\n                  size=\"sm\"\n                  onClick={() => navigateToPricing()}\n                >\n                  {t('settings:account.plan.upgrade')}\n                </Button>\n              )}\n            </div>\n          </SettingRow>\n          {subscriptionError && (\n            <SettingsHelperText className=\"mt-2 text-red-500\">\n              {subscriptionError}\n            </SettingsHelperText>\n          )}\n\n          {/* Plan Features Section */}\n          <SettingRow\n            label=\"\"\n            labelNode={\n              <div className=\"space-y-3\">\n                {hasSubscription && (\n                  <p className=\"text-sm font-semibold text-input-text\">\n                    {t('settings:account.plan.thanksForSubscribing')}\n                  </p>\n                )}\n                <PlanFeaturesList features={currentPlanFeatures} />\n              </div>\n            }\n          />\n\n      <SectionDivider />\n\n          <SettingRow\n            label={t('settings:account.payments.sectionTitle')}\n            description={t('settings:account.payments.description')}\n          >\n            <Button\n              variant=\"secondary\"\n              size=\"sm\"\n              onClick={() => currentPractice && openBillingPortal({\n                practiceId: currentPractice.id,\n                returnUrl: origin ? `${origin}/settings/account?sync=1` : '/settings/account?sync=1'\n              })}\n              disabled={!currentPractice || !isOwner || !canManageBilling || submitting}\n            >\n              {t('settings:account.payments.manage')}\n            </Button>\n          </SettingRow>\n\n      <SectionDivider />\n\n          <SettingRow\n            label={t('settings:account.payouts.sectionTitle')}\n            description={t('settings:account.payouts.description')}\n          >\n            <Button\n              variant=\"secondary\"\n              size=\"sm\"\n              onClick={() => navigate('/settings/account/payouts')}\n            >\n              {t('settings:account.payouts.manage')}\n            </Button>\n          </SettingRow>\n\n      <SectionDivider />\n\n          {/* Delete account Section */}\n          <SettingRow\n            label={t('settings:account.delete.sectionTitle')}\n          >\n            {isDeleteBlocked ? (\n              <div className=\"flex items-center gap-2\">\n                <Button\n                  variant=\"secondary\"\n                  size=\"sm\"\n                  onClick={() => currentPractice && openBillingPortal({\n                    practiceId: currentPractice.id,\n                    returnUrl: origin ? `${origin}/settings/account?sync=1` : '/settings/account?sync=1'\n                  })}\n                  disabled={!currentPractice || !isOwner || !canManageBilling}\n                  data-testid=\"account-delete-action\"\n                >\n                  {t('settings:account.plan.manage')}\n                </Button>\n              </div>\n            ) : (\n              <SettingsDangerButton\n                size=\"sm\"\n                onClick={handleDeleteAccount}\n                data-testid=\"account-delete-action\"\n              >\n                {t('settings:account.delete.button')}\n              </SettingsDangerButton>\n            )}\n          </SettingRow>\n          {isDeleteBlocked && deletionBlockedMessage && (\n            <SettingsHelperText className=\"mt-2\">\n              {deletionBlockedMessage}\n            </SettingsHelperText>\n          )}\n\n      <SectionDivider />\n\n      {showLinksSection && (\n        <>\n          {/* Links Section */}\n          <SettingSection title={t('settings:account.links.title')}>\n            {/* Domain Selector */}\n            <SettingRow\n              label={t('settings:account.links.domainLabel')}\n              labelNode={\n                <div className=\"flex items-center gap-3\">\n                  <GlobeAltIcon className=\"w-5 h-5 text-input-placeholder\" />\n                  <FormLabel>{t('settings:account.links.domainLabel')}</FormLabel>\n                </div>\n              }\n            >\n              <Combobox\n                value={selectedDomain}\n                options={[\n                  { value: DOMAIN_SELECT_VALUE, label: t('settings:account.links.selectOption') },\n                  ...customDomainOptions,\n                  { value: 'verify-new', label: `+ ${t('settings:account.links.verifyNew')}` }\n                ]}\n                onChange={handleDomainChange}\n                placeholder={t('settings:account.links.selectOption')}\n                className=\"border-0 bg-transparent px-3 py-1 hover:bg-surface-glass/50 focus:ring-2 focus:ring-accent-500\"\n                searchable={false}\n              />\n            </SettingRow>\n\n            {/* LinkedIn */}\n            <SettingRow\n              label=\"LinkedIn\"\n              labelNode={\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"w-4 h-4 bg-black rounded flex items-center justify-center\">\n                    <span className=\"text-white text-xs font-bold\">in</span>\n                  </div>\n                  <FormLabel>LinkedIn</FormLabel>\n                </div>\n              }\n            >\n              <Button\n                variant=\"secondary\"\n                size=\"sm\"\n                onClick={handleAddLinkedIn}\n                icon={<PlusIcon className=\"w-4 h-4\" />}\n                iconPosition=\"right\"\n              >\n                {t('settings:account.links.addButton')}\n              </Button>\n            </SettingRow>\n\n            {/* GitHub */}\n            <SettingRow\n              label=\"GitHub\"\n              labelNode={\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"w-4 h-4\">\n                    <svg viewBox=\"0 0 24 24\" className=\"w-4 h-4 text-input-placeholder fill-current\">\n                      <path d=\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"/>\n                    </svg>\n                  </div>\n                  <FormLabel>GitHub</FormLabel>\n                </div>\n              }\n            >\n              <Button\n                variant=\"secondary\"\n                size=\"sm\"\n                onClick={handleAddGitHub}\n                icon={<PlusIcon className=\"w-4 h-4\" />}\n                iconPosition=\"right\"\n              >\n                {t('settings:account.links.addButton')}\n              </Button>\n            </SettingRow>\n          </SettingSection>\n\n          <SectionDivider />\n        </>\n      )}\n\n      {/* Email Section */}\n      <EmailSettingsSection\n        email={emailAddress}\n        receiveFeedbackEmails={emailSettings?.receiveFeedbackEmails || false}\n        onFeedbackChange={handleFeedbackEmailsChange}\n        title={t('settings:account.email.title')}\n        feedbackLabel={t('settings:account.email.receiveFeedback')}\n        showFeedbackToggle={showFeedbackToggle}\n      />\n\n      <SectionDivider />\n\n      {/* Delete Account Confirmation Dialog */}\n      <ConfirmationDialog\n        isOpen={showDeleteConfirm}\n        onClose={handleCancelDelete}\n        onConfirm={handleConfirmDelete}\n        title={t('settings:account.delete.heading')}\n        description={t('settings:account.delete.description')}\n        confirmText={t('settings:account.delete.confirmButton')}\n        cancelText={t('settings:account.delete.cancel')}\n        confirmationValue={emailAddress}\n        confirmationLabel={\n          isOAuthUser\n            ? t('settings:account.delete.confirmLabelOAuth', { email: emailAddress })\n            : t('settings:account.delete.confirmLabel', { email: emailAddress })\n        }\n        warningItems={deleteListItems}\n        successMessage={\n          deleteVerificationSent ? {\n            title: t('settings:account.delete.verificationSentTitle'),\n            body: t('settings:account.delete.checkYourEmail')\n          } : undefined\n        }\n        showSuccessMessage={deleteVerificationSent}\n        requirePassword={requiresPassword}\n        passwordLabel={passwordLabel}\n        passwordPlaceholder={passwordPlaceholder}\n        passwordMissingMessage={passwordRequiredMessage}\n      />\n\n      {/* Domain Input Modal */}\n      <Modal\n        isOpen={showDomainModal}\n        onClose={handleCloseDomainModal}\n        title={t('settings:account.domainModal.title')}\n        showCloseButton={true}\n        type=\"modal\"\n      >\n        <div className=\"space-y-4\">\n          <Input\n            id=\"domain-input\"\n            type=\"text\"\n            label={t('settings:account.domainModal.label')}\n            value={domainInput}\n            onChange={(value) => {\n              setDomainInput(value);\n              setDomainError(null);\n            }}\n            onKeyDown={(event) => {\n              if (event.key === 'Enter') {\n                void handleDomainSubmit();\n              }\n            }}\n            placeholder={t('settings:account.links.domainPlaceholder')}\n            error={domainError ?? undefined}\n          />\n          \n          <FormActions\n            className=\"justify-end\"\n            size=\"sm\"\n            onCancel={handleCloseDomainModal}\n            onSubmit={handleDomainSubmit}\n            submitType=\"button\"\n            cancelText={t('settings:account.domainModal.cancel')}\n            submitText={t('settings:account.domainModal.submit')}\n          />\n        </div>\n      </Modal>\n    </SettingsPageLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/AppDetailPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":20,"suggestions":[{"fix":{"range":[2156,2177],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":67,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":67,"endColumn":20,"suggestions":[{"fix":{"range":[2736,2757],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState } from 'preact/hooks';\nimport { ComponentChildren } from 'preact';\nimport { App, mockConnectApp, mockDisconnectApp } from './appsData';\nimport { AppConnectionModal } from '@/features/settings/components/AppConnectionModal';\nimport { Button } from '@/shared/ui/Button';\nimport { SectionDivider } from '@/shared/ui/layout';\nimport { SettingRow } from '@/features/settings/components/SettingRow';\nimport { SettingSection } from '@/features/settings/components/SettingSection';\nimport { SettingsPageLayout } from '@/features/settings/components/SettingsPageLayout';\nimport { SettingsBadge } from '@/features/settings/components/SettingsBadge';\nimport { Input } from '@/shared/ui/input';\nimport { ArrowLeftIcon, EllipsisVerticalIcon, GlobeAltIcon, PuzzlePieceIcon, Cog6ToothIcon } from '@heroicons/react/24/outline';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { formatDate } from '@/shared/utils/dateTime';\nimport { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem } from '@/shared/ui/dropdown';\n\ninterface AppDetailPageProps {\n  app: App;\n  onBack: () => void;\n  onUpdate: (appId: string, updates: Partial<App>) => void;\n}\n\nexport const AppDetailPage = ({ app, onBack, onUpdate }: AppDetailPageProps) => {\n  const { t } = useTranslation(['settings']);\n  const { showSuccess, showError } = useToastContext();\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [isDisconnecting, setIsDisconnecting] = useState(false);\n  const [showConnectModal, setShowConnectModal] = useState(false);\n  const isComingSoon = Boolean(app.comingSoon);\n\n  const handleConnectClick = () => {\n    setShowConnectModal(true);\n  };\n\n  const handleConnect = async () => {\n    setShowConnectModal(false);\n    setIsConnecting(true);\n    try {\n      const result = await mockConnectApp(app.id);\n      onUpdate(app.id, { connected: true, connectedAt: result.connectedAt });\n      showSuccess(\n        t('settings:apps.clio.toasts.connectSuccess.title'),\n        t('settings:apps.clio.toasts.connectSuccess.body')\n      );\n    } catch (error) {\n      console.error(error);\n      showError(\n        t('settings:apps.clio.toasts.error.title'),\n        t('settings:apps.clio.toasts.error.body')\n      );\n    } finally {\n      setIsConnecting(false);\n    }\n  };\n\n  const handleDisconnect = async () => {\n    setIsDisconnecting(true);\n    try {\n      await mockDisconnectApp(app.id);\n      onUpdate(app.id, { connected: false, connectedAt: undefined });\n      showSuccess(\n        t('settings:apps.clio.toasts.disconnectSuccess.title'),\n        t('settings:apps.clio.toasts.disconnectSuccess.body')\n      );\n    } catch (error) {\n      console.error(error);\n      showError(\n        t('settings:apps.clio.toasts.error.title'),\n        t('settings:apps.clio.toasts.error.body')\n      );\n    } finally {\n      setIsDisconnecting(false);\n    }\n  };\n\n  const handleOpenSettings = () => {\n    window.open(app.website, '_blank', 'noopener,noreferrer');\n  };\n\n  return (\n    <SettingsPageLayout\n      title={app.name}\n      wrapChildren={false}\n      contentClassName=\"pb-6\"\n      headerLeading={(\n        <Button\n          variant=\"icon\"\n          size=\"icon\"\n          onClick={onBack}\n          aria-label={t('settings:navigation.backToSettings')}\n          icon={<ArrowLeftIcon className=\"w-5 h-5\" />}\n        />\n      )}\n    >\n      <div className=\"pt-2 pb-6\">\n        <SettingRow\n          label={app.name}\n          labelNode={(\n            <div className=\"flex items-center gap-4\">\n              <div className=\"w-16 h-16 rounded-full bg-surface-glass/60 backdrop-blur-sm flex items-center justify-center border border-line-glass/30 overflow-hidden\">\n                {app.logo ? (\n                  <img\n                    src={app.logo}\n                    alt={`${app.name} logo`}\n                    className=\"w-full h-full object-cover\"\n                    loading=\"lazy\"\n                  />\n                ) : (\n                  <PuzzlePieceIcon className=\"w-8 h-8 text-input-text/80\" aria-hidden=\"true\" />\n                )}\n              </div>\n              <div className=\"flex items-center gap-2\">\n                <h2 className=\"text-2xl font-bold text-input-text\">{app.name}</h2>\n                {isComingSoon && (\n                  <SettingsBadge variant=\"warning\">\n                    {t('settings:apps.comingSoon')}\n                  </SettingsBadge>\n                )}\n              </div>\n            </div>\n          )}\n        >\n          <div className=\"flex items-center gap-2\">\n            <Button\n              variant={app.connected ? 'secondary' : 'primary'}\n              size=\"sm\"\n              onClick={app.connected ? handleDisconnect : handleConnectClick}\n              disabled={isConnecting || isDisconnecting || (!app.connected && isComingSoon)}\n            >\n              {isConnecting\n                ? t('common:actions.loading')\n                : isDisconnecting\n                  ? t('common:actions.loading')\n                  : app.connected\n                    ? t('settings:apps.clio.disconnect')\n                    : isComingSoon\n                      ? t('settings:apps.comingSoon')\n                      : t('settings:apps.clio.connect')}\n            </Button>\n            <DropdownMenu>\n              <DropdownMenuTrigger asChild>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  aria-label=\"More options\"\n                  icon={<EllipsisVerticalIcon className=\"w-5 h-5\" />}\n                />\n              </DropdownMenuTrigger>\n              <DropdownMenuContent align=\"end\">\n                <DropdownMenuItem onSelect={handleOpenSettings}>\n                  <div className=\"flex items-center gap-2\">\n                    <Cog6ToothIcon className=\"w-4 h-4\" aria-hidden=\"true\" />\n                    <span>{t('settings:apps.clio.settings')}</span>\n                  </div>\n                </DropdownMenuItem>\n              </DropdownMenuContent>\n            </DropdownMenu>\n          </div>\n        </SettingRow>\n      </div>\n\n      <SectionDivider />\n\n      {/* Information */}\n      <SettingSection title={t('settings:apps.clio.information')} className=\"py-6\">\n          {app.connected && app.connectedAt && (\n            <InfoRowSimple \n              label={t('settings:apps.clio.connectedOn')} \n              value={formatDate(app.connectedAt)} \n            />\n          )}\n          <InfoRowSimple label={t('settings:apps.clio.category')} value={app.category} />\n          <InfoRowSimple label={t('settings:apps.clio.developer')} value={app.developer} />\n          <InfoRowSimple\n            label={t('settings:apps.clio.website')}\n            value={\n              <a\n                href={app.website}\n                target=\"_blank\"\n                rel=\"noreferrer\"\n                className=\"inline-flex items-center gap-1 text-accent-600 dark:text-accent-400\"\n              >\n                {app.website}\n                <GlobeAltIcon className=\"w-4 h-4\" aria-hidden=\"true\" />\n              </a>\n            }\n          />\n          <InfoRowSimple\n            label={t('settings:apps.clio.privacyPolicy')}\n            value={\n              <a\n                href={app.privacyPolicy}\n                target=\"_blank\"\n                rel=\"noreferrer\"\n                className=\"inline-flex items-center gap-1 text-accent-600 dark:text-accent-400\"\n              >\n                {app.privacyPolicy}\n                <GlobeAltIcon className=\"w-4 h-4\" aria-hidden=\"true\" />\n              </a>\n            }\n          />\n      </SettingSection>\n\n      <SectionDivider />\n\n      {/* Actions */}\n      {app.actions && app.actions.length > 0 && (\n        <SettingSection title={t('settings:apps.clio.actions')} className=\"py-6\">\n          <div className=\"space-y-6\">\n            {app.actions.map((action) => (\n              <div key={action.name} className=\"space-y-2 w-full\">\n                <code className=\"text-sm font-mono font-semibold text-input-text block w-full\">\n                  {action.name}\n                </code>\n                {action.hasMetadata && (\n                  <span className=\"text-xs font-medium text-input-placeholder block w-full\">\n                    METADATA\n                  </span>\n                )}\n                <p className=\"text-sm text-input-placeholder font-normal w-full\">\n                  {action.description}\n                </p>\n                {action.visibility && (\n                  <div className=\"space-y-1 w-full\">\n                    <Input\n                      type=\"text\"\n                      label=\"Visibility\"\n                      value={action.visibility}\n                      readOnly\n                    />\n                  </div>\n                )}\n              </div>\n            ))}\n          </div>\n        </SettingSection>\n      )}\n\n      <AppConnectionModal\n        isOpen={showConnectModal}\n        onClose={() => setShowConnectModal(false)}\n        app={app}\n        onConnect={handleConnect}\n      />\n    </SettingsPageLayout>\n  );\n};\n\ninterface InfoRowSimpleProps {\n  label: string;\n  value: string | ComponentChildren;\n}\n\nconst InfoRowSimple = ({ label, value }: InfoRowSimpleProps) => {\n  return (\n    <SettingRow label={label}>\n      <span className=\"text-sm text-input-text text-right break-all\">\n        {value}\n      </span>\n    </SettingRow>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/AppsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/GeneralPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":22,"suggestions":[{"fix":{"range":[2484,2544],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":98,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":98,"endColumn":20,"suggestions":[{"fix":{"range":[3515,3569],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":153,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":153,"endColumn":20,"suggestions":[{"fix":{"range":[5347,5403],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useMemo, useCallback } from 'preact/hooks';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { SectionDivider } from '@/shared/ui';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { DEFAULT_LOCALE, detectBestLocale, setLocale, SUPPORTED_LOCALES } from '@/shared/i18n/hooks';\nimport type { Language } from '@/shared/types/user';\nimport { SettingSelect } from '@/features/settings/components/SettingSelect';\nimport { SettingsPageLayout } from '@/features/settings/components/SettingsPageLayout';\nimport { getPreferencesCategory, preferencesApi } from '@/shared/lib/preferencesApi';\nimport type { GeneralPreferences } from '@/shared/types/preferences';\n\nexport interface GeneralPageProps {\n  isMobile?: boolean;\n  onClose?: () => void;\n  className?: string;\n}\n\nexport const GeneralPage = ({\n  isMobile: _isMobile = false,\n  onClose: _onClose,\n  className = ''\n}: GeneralPageProps) => {\n  const { showSuccess, showError } = useToastContext();\n  const { t } = useTranslation(['settings', 'common']);\n  const [settings, setSettings] = useState({\n    theme: 'system' as 'light' | 'dark' | 'system',\n    language: 'auto-detect' as 'auto-detect' | Language,\n    spokenLanguage: 'auto-detect' as 'auto-detect' | Language\n  });\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Load settings from preferences API\n  useEffect(() => {\n    let isMounted = true;\n\n    // Helper function to validate language against supported options\n    const getValidLanguage = (lang: string | undefined): 'auto-detect' | Language => {\n      if (!lang || lang === 'auto-detect') return 'auto-detect';\n      // Check if it's a supported language in our i18n layer\n      return SUPPORTED_LOCALES.includes(lang as typeof SUPPORTED_LOCALES[number]) ? lang as Language : 'auto-detect';\n    };\n    \n    const loadPreferences = async () => {\n      try {\n        setIsLoading(true);\n        const prefs = await getPreferencesCategory<GeneralPreferences>('general');\n        if (!isMounted) return;\n        \n        setSettings({\n          theme: (prefs?.theme as 'light' | 'dark' | 'system') || 'system',\n          language: getValidLanguage(prefs?.language),\n          spokenLanguage: getValidLanguage(prefs?.spoken_language)\n        });\n\n        const validatedLanguage = getValidLanguage(prefs?.language);\n        if (validatedLanguage !== 'auto-detect') {\n          void setLocale(validatedLanguage);\n        }\n      } catch (error) {\n        console.error('Failed to load general preferences:', error);\n      } finally {\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    void loadPreferences();\n\n    return () => {\n      isMounted = false;\n    };\n  }, []);\n  const languageOptions = useMemo(() => ([\n    { value: 'auto-detect', label: t('common:language.auto') },\n    ...SUPPORTED_LOCALES.map(locale => ({\n      value: locale,\n      label: t(`common:language.${locale}`)\n    }))\n  ]), [t]);\n\n  const handleLocaleChange = useCallback(async (value: string) => {\n    try {\n      if (value === 'auto-detect') {\n        const detected = detectBestLocale();\n        await setLocale(detected);\n      } else {\n        const isSupported = SUPPORTED_LOCALES.includes(value as typeof SUPPORTED_LOCALES[number]);\n        await setLocale(isSupported ? value : DEFAULT_LOCALE);\n      }\n\n      showSuccess(\n        t('settings:general.language.toastTitle'),\n        t('settings:general.language.toastBody')\n      );\n    } catch (error) {\n       \n      console.error('Failed to apply locale change', error);\n    }\n  }, [showSuccess, t]);\n\n  const handleSettingChange = async (key: string, value: string | boolean) => {\n    const previousValue = settings[key as keyof typeof settings];\n    \n    setSettings(prev => {\n      const newSettings = { ...prev, [key]: value };\n      return newSettings;\n    });\n    \n    try {\n      const updatePayload: GeneralPreferences = {};\n      if (key === 'theme') {\n        updatePayload.theme = value as GeneralPreferences['theme'];\n      } else if (key === 'language') {\n        updatePayload.language = value as string;\n      } else if (key === 'spokenLanguage') {\n        updatePayload.spoken_language = value as string;\n      }\n\n      await preferencesApi.updateGeneral(updatePayload);\n      \n      // Apply theme immediately if changed\n      if (key === 'theme') {\n        if (value === 'dark') {\n          document.documentElement.classList.add('dark');\n          localStorage.setItem('theme', 'dark');\n        } else if (value === 'light') {\n          document.documentElement.classList.remove('dark');\n          localStorage.setItem('theme', 'light');\n        } else {\n          // System theme\n          const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n          if (prefersDark) {\n            document.documentElement.classList.add('dark');\n          } else {\n            document.documentElement.classList.remove('dark');\n          }\n          localStorage.removeItem('theme');\n        }\n      }\n      \n      if (key === 'language') {\n        void handleLocaleChange(value as string);\n      }\n      \n      if (key !== 'language') {\n        showSuccess(\n          t('common:notifications.settingsSavedTitle'),\n          t('common:notifications.settingsSavedBody')\n        );\n      }\n    } catch (error) {\n      console.error('Failed to update user settings:', error);\n      showError(\n        t('common:notifications.settingsSaveErrorTitle'),\n        t('common:notifications.settingsSaveErrorBody')\n      );\n      \n      // Revert the local state on error\n      setSettings(prev => ({ ...prev, [key]: previousValue }));\n    }\n  };\n\n  // Show loading state while session is loading\n  if (isLoading) {\n    return (\n      <div className={`h-full flex items-center justify-center ${className}`}>\n        <div className=\"w-8 h-8 border-2 border-accent-500 border-t-transparent rounded-full animate-spin\" />\n      </div>\n    );\n  }\n\n  // Use same layout for both mobile and desktop\n  return (\n    <SettingsPageLayout title={t('settings:general.title')} className={className}>\n      <SettingSelect\n        label={t('settings:general.theme.label')}\n        value={settings.theme}\n        options={[\n          { value: 'light', label: t('settings:general.theme.options.light') },\n          { value: 'dark', label: t('settings:general.theme.options.dark') },\n          { value: 'system', label: t('settings:general.theme.options.system') }\n        ]}\n        onChange={(value) => handleSettingChange('theme', value)}\n      />\n\n      <SectionDivider />\n\n      <SettingSelect\n        label={t('settings:general.language.label')}\n        description={t('settings:general.language.description')}\n        value={settings.language}\n        options={languageOptions}\n        onChange={(value) => handleSettingChange('language', value)}\n      />\n\n      <SectionDivider />\n\n      <SettingSelect\n        label={t('settings:general.spokenLanguage.label')}\n        description={t('settings:general.spokenLanguage.description')}\n        value={settings.spokenLanguage}\n        options={[\n          { value: 'auto-detect', label: t('common:language.auto') },\n          ...SUPPORTED_LOCALES.map(locale => ({\n            value: locale,\n            label: t(`common:language.${locale}`)\n          }))\n        ]}\n        onChange={(value) => handleSettingChange('spokenLanguage', value)}\n      />\n    </SettingsPageLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/HelpPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/MFAEnrollmentPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/NotificationsPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":176,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":176,"endColumn":20,"suggestions":[{"fix":{"range":[6310,6374],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":225,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":225,"endColumn":20,"suggestions":[{"fix":{"range":[8641,8707],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":248,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":248,"endColumn":20,"suggestions":[{"fix":{"range":[9727,9789],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":264,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":264,"endColumn":20,"suggestions":[{"fix":{"range":[10448,10519],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":281,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":281,"endColumn":20,"suggestions":[{"fix":{"range":[11252,11320],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo, useState } from 'preact/hooks';\nimport { SectionDivider } from '@/shared/ui';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { getNotificationDisplayText } from '@/shared/ui/validation/defaultValues';\nimport { SettingRow } from '@/features/settings/components/SettingRow';\nimport { NotificationChannelSelector } from '@/features/settings/components/NotificationChannelSelector';\nimport { SettingsPageLayout } from '@/features/settings/components/SettingsPageLayout';\nimport { SettingsSubheader } from '@/features/settings/components/SettingsSubheader';\nimport {\n  useNotificationSettings,\n  updateNotificationChannel,\n  updateDesktopPushEnabled,\n  updateMessagesMentionsOnly,\n  updateInAppCategory,\n  updateInAppFrequency\n} from '@/features/settings/hooks/useNotificationSettings';\nimport { Switch } from '@/shared/ui/input';\nimport {\n  getNotificationPermissionState,\n  optInDesktopNotifications,\n  optOutDesktopNotifications,\n  type NotificationPermissionState\n} from '@/shared/notifications/oneSignalClient';\nimport type { NotificationSettings } from '@/shared/types/user';\nimport type { NotificationCategory, InAppNotificationFrequency } from '@/shared/types/notifications';\n\nexport interface NotificationsPageProps {\n  className?: string;\n}\n\nconst CATEGORY_CONFIG: Array<{\n  key: NotificationCategory;\n  labelKey: string;\n  descriptionKey: string;\n  fallbackLabel: string;\n  fallbackDescription: string;\n}> = [\n  {\n    key: 'message',\n    labelKey: 'settings:notifications.categories.messages.title',\n    descriptionKey: 'settings:notifications.categories.messages.description',\n    fallbackLabel: 'Messages',\n    fallbackDescription: 'Message notifications for new conversation activity.'\n  },\n  {\n    key: 'system',\n    labelKey: 'settings:notifications.categories.system.title',\n    descriptionKey: 'settings:notifications.categories.system.description',\n    fallbackLabel: 'System',\n    fallbackDescription: 'Updates and alerts from Blawby.'\n  },\n  {\n    key: 'payment',\n    labelKey: 'settings:notifications.categories.payments.title',\n    descriptionKey: 'settings:notifications.categories.payments.description',\n    fallbackLabel: 'Payments',\n    fallbackDescription: 'Payment and billing updates.'\n  },\n  {\n    key: 'intake',\n    labelKey: 'settings:notifications.categories.intakes.title',\n    descriptionKey: 'settings:notifications.categories.intakes.description',\n    fallbackLabel: 'Intakes',\n    fallbackDescription: 'Client intake updates and submissions.'\n  },\n  {\n    key: 'matter',\n    labelKey: 'settings:notifications.categories.matters.title',\n    descriptionKey: 'settings:notifications.categories.matters.description',\n    fallbackLabel: 'Matters',\n    fallbackDescription: 'Matter status changes and updates.'\n  }\n];\n\nconst IN_APP_CATEGORY_CONFIG: Array<{\n  key: NotificationCategory;\n  labelKey: string;\n  descriptionKey: string;\n  fallbackLabel: string;\n  fallbackDescription: string;\n}> = [\n  {\n    key: 'message',\n    labelKey: 'settings:notifications.inApp.messages.title',\n    descriptionKey: 'settings:notifications.inApp.messages.description',\n    fallbackLabel: 'Messages (in-app)',\n    fallbackDescription: 'Bot updates inside conversation threads.'\n  },\n  {\n    key: 'system',\n    labelKey: 'settings:notifications.inApp.system.title',\n    descriptionKey: 'settings:notifications.inApp.system.description',\n    fallbackLabel: 'System (in-app)',\n    fallbackDescription: 'Required system updates from Blawby.'\n  },\n  {\n    key: 'payment',\n    labelKey: 'settings:notifications.inApp.payments.title',\n    descriptionKey: 'settings:notifications.inApp.payments.description',\n    fallbackLabel: 'Payments (in-app)',\n    fallbackDescription: 'Payment and billing updates in chat.'\n  },\n  {\n    key: 'intake',\n    labelKey: 'settings:notifications.inApp.intakes.title',\n    descriptionKey: 'settings:notifications.inApp.intakes.description',\n    fallbackLabel: 'Intakes (in-app)',\n    fallbackDescription: 'Intake updates posted by Blawby.'\n  },\n  {\n    key: 'matter',\n    labelKey: 'settings:notifications.inApp.matters.title',\n    descriptionKey: 'settings:notifications.inApp.matters.description',\n    fallbackLabel: 'Matters (in-app)',\n    fallbackDescription: 'Matter updates posted by Blawby.'\n  }\n];\n\nconst getCategorySettings = (settings: NotificationSettings, category: NotificationCategory) => {\n  switch (category) {\n    case 'message':\n      return settings.messages;\n    case 'system':\n      return settings.system;\n    case 'payment':\n      return settings.payments;\n    case 'intake':\n      return settings.intakes;\n    case 'matter':\n      return settings.matters;\n    default:\n      return settings.system;\n  }\n};\n\nconst inAppSettingKey: Record<NotificationCategory, keyof NotificationSettings['inApp']> = {\n  message: 'messages',\n  system: 'system',\n  payment: 'payments',\n  intake: 'intakes',\n  matter: 'matters'\n};\n\nexport const NotificationsPage = ({\n  className = ''\n}: NotificationsPageProps) => {\n  const { showSuccess, showError } = useToastContext();\n  const { t } = useTranslation(['settings', 'common']);\n  const { settings, isLoading, error } = useNotificationSettings();\n  const [permissionState, setPermissionState] = useState<NotificationPermissionState>(getNotificationPermissionState());\n\n  const isPermissionSupported = permissionState !== 'unsupported';\n\n  const handleChannelSelectionChange = async (\n    category: NotificationCategory,\n    currentSettings: NotificationSettings['messages'],\n    nextSelection: { push: boolean; email: boolean }\n  ) => {\n    const updates: Array<Promise<void>> = [];\n    if (currentSettings.push !== nextSelection.push) {\n      updates.push(updateNotificationChannel(category, 'push', nextSelection.push));\n    }\n    if (currentSettings.email !== nextSelection.email) {\n      updates.push(updateNotificationChannel(category, 'email', nextSelection.email));\n    }\n    if (updates.length === 0) return;\n\n    try {\n      await Promise.all(updates);\n      showSuccess(\n        t('common:notifications.settingsSavedTitle', { defaultValue: 'Settings saved' }),\n        t('settings:notifications.toastBody', { defaultValue: 'Your notification preferences have been updated.' })\n      );\n    } catch (error) {\n      console.error('Failed to update notification settings:', error);\n      showError(\n        t('common:notifications.settingsSaveErrorTitle', { defaultValue: 'Settings save failed' }),\n        t('common:notifications.settingsSaveErrorBody', { defaultValue: 'Unable to save your settings. Please try again.' })\n      );\n    }\n  };\n\n  const handleDesktopToggle = async (value: boolean) => {\n    try {\n      if (value) {\n        if (!isPermissionSupported) {\n          showError(\n            t('common:notifications.settingsSaveErrorTitle', { defaultValue: 'Settings save failed' }),\n            t('settings:notifications.desktop.permissionErrorBody', { defaultValue: 'We could not enable desktop notifications.' })\n          );\n          return;\n        }\n        const result = await optInDesktopNotifications();\n        setPermissionState(result.permission);\n        if (result.permission !== 'granted') {\n          showError(\n            t('settings:notifications.desktop.permissionDeniedTitle', { defaultValue: 'Permission blocked' }),\n            t('settings:notifications.desktop.permissionDeniedBody', { defaultValue: 'Enable notifications in your browser settings to receive alerts.' })\n          );\n          return;\n        }\n        if (!result.subscribed) {\n          showError(\n            t('settings:notifications.desktop.permissionErrorTitle', { defaultValue: 'Permission failed' }),\n            t('settings:notifications.desktop.permissionErrorBody', { defaultValue: 'We could not enable desktop notifications.' })\n          );\n          return;\n        }\n      } else {\n        const optOutSucceeded = await optOutDesktopNotifications();\n        if (!optOutSucceeded) {\n          showError(\n            t('settings:notifications.desktop.optOutFailedTitle', { defaultValue: 'Browser still subscribed' }),\n            t('settings:notifications.desktop.optOutFailedBody', { defaultValue: 'Disable notifications in your browser settings to stop this device from receiving alerts.' })\n          );\n        }\n      }\n      await updateDesktopPushEnabled(value);\n      showSuccess(\n        t('common:notifications.settingsSavedTitle', { defaultValue: 'Settings saved' }),\n        t('settings:notifications.desktop.toastBody', { defaultValue: 'Desktop notification preference updated.' })\n      );\n    } catch (error) {\n      console.error('Failed to update desktop push preference:', error);\n      showError(\n        t('common:notifications.settingsSaveErrorTitle', { defaultValue: 'Settings save failed' }),\n        t('common:notifications.settingsSaveErrorBody', { defaultValue: 'Unable to save your settings. Please try again.' })\n      );\n    }\n  };\n\n  const translations = useMemo(() => ({\n    push: t('settings:notifications.channels.push', { defaultValue: 'Push' }),\n    email: t('settings:notifications.channels.email', { defaultValue: 'Email' }),\n    none: t('settings:notifications.channels.none', { defaultValue: 'None' }),\n    required: t('settings:notifications.systemRequiredLabel', { defaultValue: 'Required' })\n  }), [t]);\n\n  const handleMentionsOnlyToggle = async (value: boolean) => {\n    try {\n      await updateMessagesMentionsOnly(value);\n      showSuccess(\n        t('common:notifications.settingsSavedTitle', { defaultValue: 'Settings saved' }),\n        t('settings:notifications.mentions.toastBody', { defaultValue: 'Mention preferences updated.' })\n      );\n    } catch (error) {\n      console.error('Failed to update mention preferences:', error);\n      showError(\n        t('common:notifications.settingsSaveErrorTitle', { defaultValue: 'Settings save failed' }),\n        t('common:notifications.settingsSaveErrorBody', { defaultValue: 'Unable to save your settings. Please try again.' })\n      );\n    }\n  };\n\n  const handleInAppToggle = async (category: NotificationCategory, value: boolean) => {\n    try {\n      await updateInAppCategory(category, value);\n      showSuccess(\n        t('common:notifications.settingsSavedTitle', { defaultValue: 'Settings saved' }),\n        t('settings:notifications.inApp.toastBody', { defaultValue: 'In-app preferences updated.' })\n      );\n    } catch (error) {\n      console.error('Failed to update in-app notification settings:', error);\n      showError(\n        t('common:notifications.settingsSaveErrorTitle', { defaultValue: 'Settings save failed' }),\n        t('common:notifications.settingsSaveErrorBody', { defaultValue: 'Unable to save your settings. Please try again.' })\n      );\n    }\n  };\n\n  const handleInAppFrequencyToggle = async (value: boolean) => {\n    const nextValue: InAppNotificationFrequency = value ? 'summaries_only' : 'all';\n    try {\n      await updateInAppFrequency(nextValue);\n      showSuccess(\n        t('common:notifications.settingsSavedTitle', { defaultValue: 'Settings saved' }),\n        t('settings:notifications.inApp.frequencyToast', { defaultValue: 'System conversation preferences updated.' })\n      );\n    } catch (error) {\n      console.error('Failed to update in-app summary preference:', error);\n      showError(\n        t('common:notifications.settingsSaveErrorTitle', { defaultValue: 'Settings save failed' }),\n        t('common:notifications.settingsSaveErrorBody', { defaultValue: 'Unable to save your settings. Please try again.' })\n      );\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className={`h-full flex items-center justify-center ${className}`}>\n        <div className=\"w-8 h-8 border-2 border-accent-500 border-t-transparent rounded-full animate-spin\" />\n      </div>\n    );\n  }\n\n  if (error || !settings) {\n    return (\n      <div className={`h-full flex items-center justify-center ${className}`}>\n        <p className=\"text-input-placeholder\">\n          {t('settings:notifications.loadError', { defaultValue: 'Failed to load notification settings' })}\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <SettingsPageLayout\n      title={t('settings:notifications.title', { defaultValue: 'Notifications' })}\n      className={className}\n    >\n      {CATEGORY_CONFIG.map((category, index) => {\n        const categorySettings = getCategorySettings(settings, category.key);\n        const isSystem = category.key === 'system';\n        const displayText = category.key === 'system'\n          ? translations.required\n          : getNotificationDisplayText(categorySettings, translations);\n        const channels = [\n          {\n            key: 'push',\n            label: translations.push,\n            checked: categorySettings.push,\n            disabled: isSystem\n          },\n          {\n            key: 'email',\n            label: translations.email,\n            checked: categorySettings.email,\n            disabled: isSystem\n          }\n        ];\n        const baseDescription = t(category.descriptionKey, { defaultValue: category.fallbackDescription });\n        const description = isSystem\n          ? (\n            <>\n              <span>{baseDescription}</span>\n              <span className=\"mt-1 block text-[11px] text-input-placeholder\">\n                {t('settings:notifications.systemRequiredHint', { defaultValue: 'System notifications are required for all members.' })}\n              </span>\n            </>\n          )\n          : baseDescription;\n\n        return (\n          <div key={category.key}>\n            <SettingRow\n              label={t(category.labelKey, { defaultValue: category.fallbackLabel })}\n              description={description}\n            >\n              <NotificationChannelSelector\n                displayText={displayText}\n                channels={channels}\n                noneLabel={translations.none}\n                bothLabel={`${translations.push} + ${translations.email}`}\n                onSelectionChange={(nextSelection) => {\n                  if (isSystem) {\n                    return;\n                  }\n                  void handleChannelSelectionChange(category.key, categorySettings, nextSelection);\n                }}\n              />\n            </SettingRow>\n            {category.key === 'message' && (\n              <>\n                <SectionDivider />\n                <SettingRow\n                  label={t('settings:notifications.mentions.title', { defaultValue: 'Mentions only' })}\n                  description={t('settings:notifications.mentions.description', { defaultValue: 'Only notify me when I am @mentioned in a conversation.' })}\n                >\n                  <Switch\n                    value={settings.messagesMentionsOnly}\n                    onChange={handleMentionsOnlyToggle}\n                    className=\"py-0\"\n                  />\n                </SettingRow>\n              </>\n            )}\n            {index < CATEGORY_CONFIG.length - 1 && <SectionDivider />}\n          </div>\n        );\n      })}\n\n      <SectionDivider />\n\n      <SettingsSubheader variant=\"section\" className=\"px-1 pb-2 text-left\">\n        {t('settings:notifications.inApp.sectionTitle', { defaultValue: 'In-app bot messages' })}\n      </SettingsSubheader>\n\n      {IN_APP_CATEGORY_CONFIG.map((category, index) => {\n        const isSystem = category.key === 'system';\n        const description = t(category.descriptionKey, { defaultValue: category.fallbackDescription });\n\n        return (\n          <div key={`in-app-${category.key}`}>\n            <SettingRow\n              label={t(category.labelKey, { defaultValue: category.fallbackLabel })}\n              description={description}\n            >\n              <Switch\n                value={settings.inApp[inAppSettingKey[category.key]]}\n                onChange={(value) => handleInAppToggle(category.key, value)}\n                disabled={isSystem}\n                className=\"py-0\"\n              />\n            </SettingRow>\n            {isSystem && (\n              <>\n                <SectionDivider />\n                <SettingRow\n                  label={t('settings:notifications.inApp.frequencyLabel', { defaultValue: 'System summaries only' })}\n                  description={t('settings:notifications.inApp.frequencyDescription', {\n                    defaultValue: 'Show a single summary message for the Blawby System conversation.'\n                  })}\n                >\n                  <Switch\n                    value={settings.inAppFrequency === 'summaries_only'}\n                    onChange={handleInAppFrequencyToggle}\n                    className=\"py-0\"\n                  />\n                </SettingRow>\n              </>\n            )}\n            {index < IN_APP_CATEGORY_CONFIG.length - 1 && <SectionDivider />}\n          </div>\n        );\n      })}\n\n      <SectionDivider />\n\n      <SettingRow\n        label={t('settings:notifications.desktop.title', { defaultValue: 'Desktop notifications' })}\n        description={t('settings:notifications.desktop.description', { defaultValue: 'Allow Blawby to send OS-level alerts.' })}\n      >\n        <div className=\"flex items-center gap-2\">\n          <Switch\n            value={settings.desktopPushEnabled}\n            onChange={handleDesktopToggle}\n            disabled={!isPermissionSupported}\n            className=\"py-0\"\n          />\n        </div>\n      </SettingRow>\n    </SettingsPageLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/PayoutsPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":66,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":66,"endColumn":19,"suggestions":[{"fix":{"range":[2848,2911],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { Button } from '@/shared/ui/Button';\nimport { SectionDivider } from '@/shared/ui';\nimport { SettingsPageLayout } from '@/features/settings/components/SettingsPageLayout';\nimport { SettingsHelperText } from '@/features/settings/components/SettingsHelperText';\nimport { SettingSection } from '@/features/settings/components/SettingSection';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { usePracticeManagement } from '@/shared/hooks/usePracticeManagement';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport {\n  createConnectedAccount,\n  getOnboardingStatusPayload\n} from '@/shared/lib/apiClient';\nimport { StripeOnboardingStep } from '@/features/onboarding/steps/StripeOnboardingStep';\nimport { extractStripeStatusFromPayload } from '@/features/onboarding/utils';\nimport type { StripeConnectStatus } from '@/features/onboarding/types';\nimport { getValidatedStripeOnboardingUrl } from '@/shared/utils/stripeOnboarding';\nimport { CheckCircleIcon, LockClosedIcon, ShieldCheckIcon, UserCircleIcon } from '@heroicons/react/24/outline';\n\nexport const PayoutsPage = ({ className = '' }: { className?: string }) => {\n  const { session, activeOrganizationId } = useSessionContext();\n  const { currentPractice } = usePracticeManagement({ fetchPracticeDetails: true });\n  const { showError } = useToastContext();\n  const organizationId = useMemo(() => activeOrganizationId, [activeOrganizationId]);\n  const lastOrganizationIdRef = useRef<string | null>(null);\n  const [stripeStatus, setStripeStatus] = useState<StripeConnectStatus | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const fetchStatus = useCallback(async (signal: AbortSignal) => {\n    if (!organizationId) {\n      if (lastOrganizationIdRef.current !== null) {\n        lastOrganizationIdRef.current = null;\n        setStripeStatus(null);\n      }\n      return;\n    }\n\n    if (lastOrganizationIdRef.current !== organizationId) {\n      lastOrganizationIdRef.current = organizationId;\n      setStripeStatus(null);\n    }\n\n    setIsLoading(true);\n    try {\n      const payload = await getOnboardingStatusPayload(organizationId, { signal });\n      if (signal.aborted) {\n        return;\n      }\n      const status = extractStripeStatusFromPayload(payload);\n      if (status) {\n        setStripeStatus(status);\n      }\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        return;\n      }\n      if ((error as { name?: string }).name === 'AbortError') {\n        return;\n      }\n      if (axios.isAxiosError(error) && error.response?.status === 404) {\n        setStripeStatus(null);\n        return;\n      }\n      console.warn('[PAYOUTS] Failed to load Stripe status:', error);\n      showError('Payouts', 'Unable to load payout account status.');\n    } finally {\n      if (!signal.aborted) {\n        setIsLoading(false);\n      }\n    }\n  }, [organizationId, showError]);\n\n  useEffect(() => {\n    const controller = new AbortController();\n    void fetchStatus(controller.signal);\n    if (typeof window !== 'undefined') {\n      const url = new URL(window.location.href);\n      if (url.searchParams.has('stripe')) {\n        url.searchParams.delete('stripe');\n        window.history.replaceState({}, '', url.toString());\n      }\n    }\n    return () => {\n      controller.abort();\n    };\n  }, [fetchStatus]);\n\n  const handleSubmitDetails = useCallback(async () => {\n    if (!organizationId) {\n      showError('Payouts', 'Missing active organization.');\n      return;\n    }\n\n    const email = currentPractice?.businessEmail || session?.user?.email || '';\n    if (!email) {\n      showError('Payouts', 'Add a business email before submitting details.');\n      return;\n    }\n\n    if (typeof window === 'undefined') {\n      showError('Payouts', 'Unable to start Stripe onboarding in this environment.');\n      return;\n    }\n    const returnUrl = new URL(window.location.href);\n    returnUrl.searchParams.set('stripe', 'return');\n    const refreshUrl = new URL(window.location.href);\n    refreshUrl.searchParams.set('stripe', 'refresh');\n\n    setIsSubmitting(true);\n    try {\n      const connectedAccount = await createConnectedAccount({\n        practiceEmail: email,\n        practiceUuid: organizationId,\n        returnUrl: returnUrl.toString(),\n        refreshUrl: refreshUrl.toString()\n      });\n\n      if (connectedAccount.onboardingUrl) {\n        const validatedUrl = getValidatedStripeOnboardingUrl(connectedAccount.onboardingUrl);\n        if (validatedUrl) {\n          window.location.href = validatedUrl;\n          return;\n        }\n        showError('Payouts', 'Received an invalid Stripe onboarding link. Please try again.');\n        return;\n      }\n\n      const message = 'Stripe hosted onboarding link was not provided. Please try again later.';\n      showError('Payouts', message);\n      return;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to start Stripe onboarding';\n      showError('Payouts', message);\n    } finally {\n      setIsSubmitting(false);\n    }\n  }, [organizationId, currentPractice?.businessEmail, session?.user?.email, showError]);\n\n  const detailsSubmitted = stripeStatus?.details_submitted === true;\n  return (\n    <SettingsPageLayout title=\"Payouts\" className={className} contentClassName=\"pb-8\">\n      <SettingSection title=\"External payout accounts\">\n        {detailsSubmitted ? (\n          <div className=\"flex items-start gap-3 text-sm text-input-placeholder\">\n            <span className=\"mt-0.5 flex h-8 w-8 items-center justify-center\">\n              <CheckCircleIcon className=\"h-5 w-5 text-emerald-600 dark:text-emerald-400\" />\n            </span>\n            <p>\n              Your Blawby payout account is set up and ready to receive payments. You can now start sending invoices and receiving payments.\n            </p>\n          </div>\n        ) : (\n          <div className=\"space-y-4\">\n            <div className=\"flex items-start gap-3 text-sm text-input-placeholder\">\n              <span className=\"mt-0.5 flex h-8 w-8 items-center justify-center\">\n                <ShieldCheckIcon className=\"h-5 w-5 text-input-placeholder\" />\n              </span>\n              <p>\n                Information about your business, and authorized representative(s) of your business, will need to be verified to comply with the law. This may require you to provide documents such as government-issued identification.\n              </p>\n            </div>\n            <div className=\"flex items-start gap-3 text-sm text-input-placeholder\">\n              <span className=\"mt-0.5 flex h-8 w-8 items-center justify-center\">\n                <UserCircleIcon className=\"h-5 w-5 text-input-placeholder\" />\n              </span>\n              <p>\n                It&apos;s recommended that the person filling out the information is either the owner of the business, or someone with a significant role in the business, such as a director or executive.\n              </p>\n            </div>\n            <div className=\"flex items-start gap-3 text-sm text-input-placeholder\">\n              <span className=\"mt-0.5 flex h-8 w-8 items-center justify-center\">\n                <LockClosedIcon className=\"h-5 w-5 text-input-placeholder\" />\n              </span>\n              <p>\n                Any information and documentation you submit will be securely handled in accordance with Blawby&apos;s Privacy Policy, and may be used to create a faster onboarding experience for you if you choose to use other Blawby products.\n              </p>\n            </div>\n          </div>\n        )}\n\n        {!detailsSubmitted && (\n          <div className=\"mt-4 flex flex-col gap-3 sm:flex-row sm:items-center\">\n            <Button\n              variant=\"primary\"\n              size=\"sm\"\n              onClick={handleSubmitDetails}\n              disabled={isSubmitting || isLoading}\n            >\n              {isSubmitting ? 'Preparing Stripe...' : 'Submit details'}\n            </Button>\n            <SettingsHelperText>\n              You will be prompted to complete Stripe verification.\n            </SettingsHelperText>\n          </div>\n        )}\n      </SettingSection>\n\n      {stripeStatus && !detailsSubmitted && (\n        <>\n          <SectionDivider />\n          <div className=\"mt-4\">\n            <StripeOnboardingStep\n              status={stripeStatus}\n              loading={isLoading}\n              showIntro={false}\n              showInfoCard={false}\n            />\n          </div>\n        </>\n      )}\n    </SettingsPageLayout>\n  );\n};\n\nexport default PayoutsPage;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/PracticePage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":451,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":451,"endColumn":21,"suggestions":[{"fix":{"range":[17048,17128],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useMemo, useCallback, useEffect } from 'preact/hooks';\nimport {\n  ChevronRightIcon,\n  GlobeAltIcon,\n  MapPinIcon,\n  PhoneIcon,\n  TrashIcon\n} from '@heroicons/react/24/outline';\nimport { usePracticeManagement, type Practice } from '@/shared/hooks/usePracticeManagement';\nimport { Button } from '@/shared/ui/Button';\nimport { FormActions } from '@/shared/ui/form';\nimport type { Address } from '@/shared/types/address';\nimport Modal from '@/shared/components/Modal';\nimport { Input, LogoUploadInput, Switch } from '@/shared/ui/input';\nimport { FormLabel } from '@/shared/ui/form/FormLabel';\nimport { AddressExperienceForm } from '@/shared/ui/address/AddressExperienceForm';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { formatDate } from '@/shared/utils/dateTime';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { useLocation } from 'preact-iso';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { StackedAvatars } from '@/shared/ui/profile';\nimport { PracticeProfileTextFields } from '@/shared/ui/practice/PracticeProfileTextFields';\nimport { usePracticeDetails } from '@/shared/hooks/usePracticeDetails';\nimport type { PracticeDetails } from '@/shared/lib/apiClient';\nimport { uploadPracticeLogo } from '@/shared/utils/practiceLogoUpload';\nimport { buildPracticeProfilePayloads } from '@/shared/utils/practiceProfile';\nimport { usePaymentUpgrade } from '@/shared/hooks/usePaymentUpgrade';\nimport { getFrontendHost } from '@/config/urls';\nimport { normalizePracticeRole } from '@/shared/utils/practiceRoles';\nimport { FormGrid, SectionDivider } from '@/shared/ui/layout';\nimport { SettingsPageLayout } from '@/features/settings/components/SettingsPageLayout';\nimport { SettingsSubheader } from '@/features/settings/components/SettingsSubheader';\nimport { SettingsNotice } from '@/features/settings/components/SettingsNotice';\nimport { SettingsHelperText } from '@/features/settings/components/SettingsHelperText';\nimport { SettingRow } from '@/features/settings/components/SettingRow';\nimport {\n  usePracticeMembersSync,\n  usePracticeSyncParamRefetch,\n  type EditPracticeFormState\n} from '@/features/settings/hooks/usePracticePageEffects';\nimport { normalizeAccentColor } from '@/shared/utils/accentColors';\n\ninterface OnboardingDetails {\n  contactPhone?: string;\n  businessEmail?: string;\n  website?: string;\n  address?: Address;\n  introMessage?: string;\n  description?: string;\n  accentColor?: string;\n  isPublic?: boolean;\n  services?: Array<Record<string, unknown>>;\n}\n\nconst resolveOnboardingData = (practice: Practice | null, details: PracticeDetails | null): OnboardingDetails => {\n  if (!practice) return {};\n  const buildAddress = (source: {\n    address?: string | null;\n    apartment?: string | null;\n    city?: string | null;\n    state?: string | null;\n    postalCode?: string | null;\n    country?: string | null;\n  }): Address | undefined => {\n    const address = source.address?.trim() || '';\n    const apartment = source.apartment?.trim() || undefined;\n    const city = source.city?.trim() || '';\n    const state = source.state?.trim() || '';\n    const postalCode = source.postalCode?.trim() || '';\n    const country = source.country?.trim() || '';\n    const hasAny = Boolean(address || apartment || city || state || postalCode || country);\n    if (!hasAny) return undefined;\n    return {\n      address,\n      apartment,\n      city,\n      state,\n      postalCode,\n      country\n    };\n  };\n  const baseFromDetails: OnboardingDetails = {};\n  if (details) {\n    const setIfDefined = <K extends keyof OnboardingDetails>(key: K, value: OnboardingDetails[K]) => {\n      if (value !== undefined) {\n        baseFromDetails[key] = value;\n      }\n    };\n    setIfDefined('website', details.website ?? undefined);\n    setIfDefined('address', buildAddress(details));\n    setIfDefined('introMessage', details.introMessage ?? undefined);\n    setIfDefined('description', details.description ?? undefined);\n    setIfDefined('accentColor', details.accentColor ?? undefined);\n    setIfDefined('isPublic', details.isPublic ?? undefined);\n    setIfDefined('services', details.services ?? undefined);\n    setIfDefined('contactPhone', details.businessPhone ?? undefined);\n    setIfDefined('businessEmail', details.businessEmail ?? undefined);\n  }\n  const baseFromPractice: OnboardingDetails = {\n    website: practice.website ?? undefined,\n    address: buildAddress(practice),\n    introMessage: practice.introMessage ?? undefined,\n    description: practice.description ?? undefined,\n    accentColor: practice.accentColor ?? undefined,\n    isPublic: practice.isPublic ?? undefined,\n    services: practice.services ?? undefined,\n    contactPhone: practice.businessPhone ?? undefined,\n    businessEmail: practice.businessEmail ?? undefined\n  };\n  return { ...baseFromPractice, ...baseFromDetails };\n};\n\nconst truncateText = (value: string, maxLength: number) => {\n  if (value.length <= maxLength) return value;\n  return `${value.slice(0, maxLength).trim()}...`;\n};\n\nconst isValidHttpUrl = (value: string): boolean => {\n  try {\n    const url = new URL(value);\n    return url.protocol === 'http:' || url.protocol === 'https:';\n  } catch {\n    return false;\n  }\n};\n\nconst formatAddressSummary = (data: OnboardingDetails) => {\n  const address = data.address?.address?.trim() || '';\n  const apartment = data.address?.apartment?.trim() || '';\n  const city = data.address?.city?.trim() || '';\n  const state = data.address?.state?.trim() || '';\n  const postal = data.address?.postalCode?.trim() || '';\n  const country = data.address?.country?.trim() || '';\n\n  const parts: string[] = [];\n  if (address) parts.push(address);\n  if (apartment) parts.push(apartment);\n  const cityState = [city, state].filter(Boolean).join(', ');\n  if (cityState) parts.push(cityState);\n  const postalCountry = [postal, country].filter(Boolean).join(' ');\n  if (postalCountry) parts.push(postalCountry);\n  return parts.join('  ');\n};\n\ninterface PracticePageProps {\n  className?: string;\n  onNavigate?: (path: string) => void;\n}\n\nexport const PracticePage = ({ className = '', onNavigate }: PracticePageProps) => {\n  const { session, isPending: sessionPending, activeMemberRole, activeOrganizationId } = useSessionContext();\n  const { \n    currentPractice,\n    getMembers,\n    loading, \n    error,\n    updatePractice,\n    createPractice,\n    deletePractice,\n    fetchMembers,\n    refetch,\n  } = usePracticeManagement({ fetchPracticeDetails: true });\n  const activePracticeId = currentPractice?.id ?? null;\n  const { details: practiceDetails, updateDetails } = usePracticeDetails(activePracticeId, currentPractice?.slug);\n  \n  const { showSuccess, showError, showWarning } = useToastContext();\n  const { navigate } = useNavigation();\n  const navigateTo = onNavigate ?? navigate;\n  const location = useLocation();\n  const { openBillingPortal, submitting } = usePaymentUpgrade();\n  const { t } = useTranslation(['settings']);\n  \n  // Get current user email from session\n  const currentUserEmail = session?.user?.email || '';\n  \n  // Form states\n  const [editPracticeForm, setEditPracticeForm] = useState<EditPracticeFormState>({\n    name: '',\n    slug: '',\n    logo: ''\n  });\n  \n  const [showCreateModal, setShowCreateModal] = useState(false);\n  const [createForm, setCreateForm] = useState({\n    name: '',\n    description: ''\n  });\n  \n  const [isEditPracticeModalOpen, setIsEditPracticeModalOpen] = useState(false);\n  const [showDeleteModal, setShowDeleteModal] = useState(false);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [deleteConfirmText, setDeleteConfirmText] = useState('');\n  const [logoUploadProgress, setLogoUploadProgress] = useState<number | null>(null);\n  const [logoUploading, setLogoUploading] = useState(false);\n\n  const practice = currentPractice ?? null;\n  const hasPractice = !!practice;\n  const members = useMemo(() => practice ? getMembers(practice.id) : [], [practice, getMembers]);\n  \n  // Better approach - get role directly from current practice context\n  const currentMember = useMemo(() => {\n    if (!practice || !currentUserEmail) return null;\n    return members.find(m => m.email && m.email.toLowerCase() === currentUserEmail.toLowerCase()) || \n           members.find(m => m.userId === session?.user?.id);\n  }, [practice, currentUserEmail, members, session?.user?.id]);\n\n  const roleFromMembers = currentMember?.role ?? null;\n  const currentUserRole = normalizePracticeRole(activeMemberRole) ?? roleFromMembers ?? 'member';\n  const isOwner = currentUserRole === 'owner';\n  const servicesList = useMemo(() => {\n    const source = practiceDetails?.services ?? practice?.services;\n    if (!Array.isArray(source)) return [];\n\n    const seen = new Set<string>();\n    const result: string[] = [];\n    const entries = source as Array<Record<string, unknown> | string>;\n    entries.forEach((entry) => {\n      if (typeof entry === 'string') {\n        const trimmed = entry.trim();\n        if (!trimmed) return;\n        const key = trimmed.toLowerCase();\n        if (seen.has(key)) return;\n        seen.add(key);\n        result.push(trimmed);\n        return;\n      }\n      if (entry && typeof entry === 'object') {\n        const record = entry as Record<string, unknown>;\n        const candidate = typeof record.name === 'string'\n          ? record.name\n          : (typeof record.title === 'string' ? record.title : '');\n        const trimmed = candidate.trim();\n        if (!trimmed) return;\n        const key = trimmed.toLowerCase();\n        if (seen.has(key)) return;\n        seen.add(key);\n        result.push(trimmed);\n      }\n    });\n    return result;\n  }, [practiceDetails?.services, practice?.services]);\n  const onboardingData = useMemo(\n    () => resolveOnboardingData(practice, practiceDetails),\n    [practice, practiceDetails]\n  );\n\n  const websiteValue = typeof onboardingData.website === 'string' ? onboardingData.website.trim() : '';\n  const addressSummary = formatAddressSummary(onboardingData);\n  const phoneValue = (typeof onboardingData.contactPhone === 'string'\n    ? onboardingData.contactPhone\n    : (practice?.businessPhone || '')).trim();\n  const introMessageValue = typeof onboardingData.introMessage === 'string'\n    ? onboardingData.introMessage.trim()\n    : '';\n  const accentColorValue = normalizeAccentColor(onboardingData.accentColor) ?? '#D4AF37';\n  const introPreview = introMessageValue ? truncateText(introMessageValue, 140) : 'Not set';\n  const isPublicValue = typeof onboardingData.isPublic === 'boolean'\n    ? onboardingData.isPublic\n    : false;\n  const practiceHost = useMemo(() => {\n    try {\n      return getFrontendHost();\n    } catch {\n      if (typeof window !== 'undefined' && window.location?.host) {\n        return window.location.host;\n      }\n      return '';\n    }\n  }, []);\n  const practicePath = `/public/${practice?.slug ?? 'your-practice'}`;\n  const practiceUrlValue = practiceHost\n    ? `${practiceHost}${practicePath}`\n    : practicePath;\n  const practiceUrlHref = useMemo(() => {\n    if (!practiceHost) {\n      return practicePath;\n    }\n    const protocol = typeof window !== 'undefined' && window.location?.protocol\n      ? window.location.protocol\n      : 'https:';\n    return `${protocol}//${practiceHost}${practicePath}`;\n  }, [practiceHost, practicePath]);\n  const hasSavedLogo = editPracticeForm.logo.trim().length > 0;\n  const teamAvatars = useMemo(\n    () => members.map((member) => ({\n      id: member.userId,\n      name: member.name || member.email,\n      image: member.image || null\n    })),\n    [members]\n  );\n\n  const [isSettingsSaving, setIsSettingsSaving] = useState(false);\n  const [isContactModalOpen, setIsContactModalOpen] = useState(false);\n  const [contactDraft, setContactDraft] = useState({\n    website: '',\n    businessEmail: '',\n    phone: '',\n    address: undefined,\n  });\n  const [introDraft, setIntroDraft] = useState('');\n  const [accentColorDraft, setAccentColorDraft] = useState('#D4AF37');\n  const modalContentClassName = 'bg-surface-glass bg-opacity-70 border-line-glass border-opacity-30 backdrop-blur-2xl';\n  const modalHeaderClassName = 'bg-surface-glass bg-opacity-60 border-line-glass border-opacity-30 backdrop-blur-xl';\n\n  // SSR-safe origin for return URLs\n  const origin = (typeof window !== 'undefined' && window.location)\n    ? window.location.origin\n    : '';\n\n  // Subscription guard for deletion\n  const subStatus = (practice?.subscriptionStatus ?? 'none').toLowerCase();\n  const deletionBlockedBySubscription = !(subStatus === 'canceled' || subStatus === 'none');\n  const deletionBlockedMessage = (() => {\n    if (!deletionBlockedBySubscription) return '';\n    const ts = practice?.subscriptionPeriodEnd;\n    const end = (typeof ts === 'number' && Number.isFinite(ts)) ? new Date(ts * 1000) : null;\n    if (end) {\n      return `Subscription must be canceled before deleting. Access ends on ${formatDate(end)}.`;\n    }\n    return 'Subscription must be canceled in Stripe before deleting this practice.';\n  })();\n\n\n  // Current user email is now derived from session - removed redirect to keep practice settings accessible\n\n  // Initialize form with current practice data\n  // Note: usePracticeManagement already fetches practice details during initialization,\n  // so we only need to fetch members here. Details are available via practiceDetailsStore.\n  usePracticeMembersSync({\n    practice,\n    setEditPracticeForm,\n    fetchMembers,\n    showError\n  });\n\n  // Refetch after return from portal\n  usePracticeSyncParamRefetch({\n    location,\n    practiceId: practice?.id ?? null,\n    refetch,\n    showSuccess\n  });\n\n  const handleCreatePractice = async () => {\n    if (isSettingsSaving) return;\n    if (!createForm.name.trim()) {\n      showError('Practice name is required');\n      return;\n    }\n\n    setIsSettingsSaving(true);\n    try {\n      await createPractice({\n        name: createForm.name,\n        description: createForm.description || undefined,\n      });\n      \n      showSuccess('Practice created successfully!');\n      setShowCreateModal(false);\n      setCreateForm({ name: '', description: '' });\n    } catch (err) {\n      showError(err instanceof Error ? err.message : 'Failed to create practice');\n    } finally {\n      setIsSettingsSaving(false);\n    }\n  };\n\n  const openEditPracticeModal = () => {\n    if (!practice) return;\n    setLogoUploadProgress(null);\n    setLogoUploading(false);\n    setEditPracticeForm({\n      name: practice.name,\n      slug: practice.slug || '',\n      logo: practice.logo || ''\n    });\n    setIntroDraft(introMessageValue);\n    setAccentColorDraft(accentColorValue);\n    setIsEditPracticeModalOpen(true);\n  };\n\n  const handleLogoChange = async (files: FileList | File[]) => {\n    if (!practice) return;\n    const [file] = Array.isArray(files) ? files : Array.from(files);\n    if (!file) {\n      return;\n    }\n\n    setLogoUploading(true);\n    setLogoUploadProgress(0);\n    try {\n      const logoUrl = await uploadPracticeLogo(file, practice.id, (percentage) => {\n        setLogoUploadProgress(percentage);\n      });\n      setEditPracticeForm(prev => ({ ...prev, logo: logoUrl }));\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Logo upload failed';\n      showError('Logo upload failed', message);\n    } finally {\n      setLogoUploading(false);\n      setLogoUploadProgress(null);\n    }\n  };\n\n  const handleUpdatePractice = async () => {\n    if (!practice) return;\n    if (!editPracticeForm.name.trim()) {\n      showError('Practice name is required');\n      return;\n    }\n    const trimmedLogo = editPracticeForm.logo.trim();\n    if (trimmedLogo && !isValidHttpUrl(trimmedLogo)) {\n      showError('Logo URL is invalid');\n      return;\n    }\n\n    setIsSettingsSaving(true);\n    try {\n      const trimmedIntro = introDraft.trim();\n      const normalizedAccentColor = normalizeAccentColor(accentColorDraft);\n      if (!normalizedAccentColor) {\n        throw new Error('Accent color must be a valid hex value (for example #3B82F6).');\n      }\n      const comparison = {\n        name: practice.name,\n        slug: practice.slug ?? null,\n        logo: practice.logo ?? null,\n        introMessage: practiceDetails?.introMessage ?? practice.introMessage ?? null,\n        accentColor: normalizeAccentColor(practiceDetails?.accentColor ?? practice.accentColor)\n      };\n      const { practicePayload, detailsPayload } = buildPracticeProfilePayloads({\n        name: editPracticeForm.name,\n        logo: trimmedLogo ? trimmedLogo : undefined,\n        introMessage: trimmedIntro ? trimmedIntro : undefined,\n        accentColor: normalizedAccentColor\n      }, { compareTo: comparison });\n\n      if (Object.keys(practicePayload).length > 0) {\n        await updatePractice(practice.id, practicePayload);\n      }\n\n      try {\n        if (Object.keys(detailsPayload).length > 0) {\n          await updateDetails(detailsPayload);\n        }\n        showSuccess('Practice updated successfully!');\n      } catch (detailsError) {\n        console.warn('Practice details update failed after core update:', detailsError);\n        showWarning(\n          'Practice updated with warning',\n          'Core fields were saved, but the description could not be updated. Please try again.'\n        );\n      }\n      setIsEditPracticeModalOpen(false);\n\t\t} catch (err) {\n      showError(err instanceof Error ? err.message : 'Failed to update practice');\n    } finally {\n      setIsSettingsSaving(false);\n    }\n  };\n\n  const saveOnboardingSettings = async (\n    updates: Partial<OnboardingDetails>,\n    toastBody: string\n  ): Promise<boolean> => {\n    if (!practice) return false;\n    setIsSettingsSaving(true);\n    try {\n      const { detailsPayload } = buildPracticeProfilePayloads({\n        businessEmail: updates.businessEmail,\n        businessPhone: updates.contactPhone,\n        website: updates.website,\n        address: updates.address?.address || null,\n        apartment: updates.address?.apartment || null,\n        city: updates.address?.city || null,\n        state: updates.address?.state || null,\n        postalCode: updates.address?.postalCode || null,\n        country: updates.address?.country || null,\n        introMessage: updates.introMessage,\n        description: updates.description,\n        isPublic: updates.isPublic,\n        services: updates.services\n      });\n\n      if (Object.keys(detailsPayload).length > 0) {\n        await updateDetails(detailsPayload);\n      }\n\n      showSuccess('Practice updated', toastBody);\n      return true;\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Failed to update practice settings';\n      showError('Update failed', message);\n      return false;\n    } finally {\n      setIsSettingsSaving(false);\n    }\n  };\n\n  const openContactModal = useCallback(() => {\n    setContactDraft({\n      website: websiteValue,\n      businessEmail: practiceDetails?.businessEmail ?? practice?.businessEmail ?? '',\n      phone: phoneValue,\n      address: onboardingData.address,\n    });\n    setIsContactModalOpen(true);\n  }, [onboardingData.address, phoneValue, practice?.businessEmail, practiceDetails?.businessEmail, websiteValue]);\n\n  const handleSaveContact = async () => {\n    const success = await saveOnboardingSettings(\n      {\n        website: (contactDraft.website ?? '').trim(),\n        businessEmail: (contactDraft.businessEmail ?? '').trim(),\n        contactPhone: (contactDraft.phone ?? '').trim(),\n        address: contactDraft.address,\n      },\n      'Contact details updated.'\n    );\n    if (success) {\n      setIsContactModalOpen(false);\n    }\n  };\n\n  useEffect(() => {\n    if (location.query?.setup === 'contact' && !isContactModalOpen) {\n      openContactModal();\n      navigate('/settings/practice', true);\n    }\n  }, [isContactModalOpen, location.query?.setup, navigate, openContactModal]);\n\n  const handleTogglePublic = async (nextValue: boolean) => {\n    await saveOnboardingSettings(\n      {\n        isPublic: nextValue\n      },\n      nextValue ? 'Practice is now public.' : 'Practice is now private.'\n    );\n  };\n\n  const handleDeletePractice = async () => {\n    if (!practice) return;\n    \n    if (deleteConfirmText.trim() !== practice.name) {\n      showError('Practice name must match exactly');\n      return;\n    }\n\n    setIsDeleting(true);\n    try {\n      await deletePractice(practice.id);\n      showSuccess('Practice deleted successfully!');\n      setShowDeleteModal(false);\n      setDeleteConfirmText('');\n      navigate('/');\n    } catch (err) {\n      showError(err instanceof Error ? err.message : 'Failed to delete practice');\n    } finally {\n      setIsDeleting(false);\n    }\n  };\n\n  // Loading state: show loading only when actively fetching\n  // Once loading is complete (loading=false, sessionPending=false), show the result:\n  // - practice data if available\n  // - error state if error\n  // - \"no data\" state if neither (this prompts user to reload)\n  const shouldShowLoading = loading || sessionPending;\n\n  if (shouldShowLoading) {\n    return (\n      <div className={`h-full flex items-center justify-center ${className}`}>\n        <div className=\"text-center\">\n          <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600 mx-auto mb-4\" />\n          <p className=\"text-sm text-input-placeholder\">Loading practice...</p>\n        </div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className={`h-full flex items-center justify-center ${className}`}>\n        <div className=\"text-center\">\n          <p className=\"text-sm text-red-600 mb-4\">{error}</p>\n          <Button size=\"sm\" onClick={refetch}>\n            Try Again\n          </Button>\n        </div>\n      </div>\n    );\n  }\n\n  if (!practice) {\n    return (\n      <div className={`h-full flex items-center justify-center ${className}`}>\n        <div className=\"text-center space-y-3\">\n          <p className=\"text-sm text-input-placeholder\">No practice data is available yet.</p>\n          <div className=\"flex items-center justify-center gap-2\">\n            <Button size=\"sm\" variant=\"secondary\" onClick={refetch}>\n              Reload\n            </Button>\n            {!activeOrganizationId && (\n              <Button size=\"sm\" onClick={() => setShowCreateModal(true)}>\n                Create Practice\n              </Button>\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <SettingsPageLayout title=\"Practice\" className={className}>\n      {hasPractice && (\n        <>\n              <SettingRow\n                label=\"Practice details\"\n                labelNode={(\n                  <div className=\"flex-1 min-w-0\">\n                    <h3 className=\"text-sm font-semibold text-input-text\">\n                      {practice.name || 'Practice'}\n                    </h3>\n                    <div className=\"mt-2 space-y-2\">\n                      <div className=\"flex items-start gap-3\">\n                        <SettingsSubheader className=\"w-20 text-[10px]\">Intro</SettingsSubheader>\n                        <SettingsHelperText>{introPreview}</SettingsHelperText>\n                      </div>\n                    </div>\n                  </div>\n                )}\n              >\n                <Button\n                  variant=\"secondary\"\n                  size=\"sm\"\n                  onClick={openEditPracticeModal}\n                >\n                  Edit\n                </Button>\n              </SettingRow>\n\n              <SectionDivider />\n\n              <SettingRow\n                label=\"Brand accent\"\n                labelNode={(\n                  <div>\n                    <h3 className=\"text-sm font-semibold text-input-text\">Brand accent</h3>\n                    <div className=\"mt-2 flex items-center gap-3\">\n                      <div\n                        className=\"h-5 w-5 rounded-full\"\n                        style={{ backgroundColor: accentColorValue }}\n                        aria-label={`Current accent color ${accentColorValue}`}\n                      />\n                      <SettingsHelperText>{accentColorValue}</SettingsHelperText>\n                    </div>\n                  </div>\n                )}\n              >\n                <Button\n                  variant=\"secondary\"\n                  size=\"sm\"\n                  onClick={openEditPracticeModal}\n                >\n                  Edit\n                </Button>\n              </SettingRow>\n\n              <SectionDivider />\n\n              <SettingRow\n                label=\"Workspace URL\"\n                description={practice?.slug ? 'Share with clients to view your public profile.' : 'Slug will be generated automatically after saving.'}\n              >\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => window.open(practiceUrlHref, '_blank', 'noopener,noreferrer')}\n                  className=\"font-medium text-brand-600 hover:text-brand-700 dark:text-brand-400 dark:hover:text-brand-300\"\n                >\n                  {practiceUrlValue}\n                </Button>\n              </SettingRow>\n\n              <SectionDivider />\n\n              <SettingRow\n                label=\"Contact\"\n                labelNode={(\n                  <div>\n                    <h3 className=\"text-sm font-semibold text-input-text\">Contact</h3>\n                    <div className=\"mt-2 space-y-2\">\n                      <div className=\"flex items-start gap-2\">\n                        <GlobeAltIcon className=\"w-4 h-4 text-input-placeholder mt-0.5\" aria-hidden=\"true\" />\n                        <SettingsHelperText>{websiteValue || 'Not set'}</SettingsHelperText>\n                      </div>\n                      <div className=\"flex items-start gap-2\">\n                        <PhoneIcon className=\"w-4 h-4 text-input-placeholder mt-0.5\" aria-hidden=\"true\" />\n                        <SettingsHelperText>{phoneValue || 'Not set'}</SettingsHelperText>\n                      </div>\n                      <div className=\"flex items-start gap-2\">\n                        <MapPinIcon className=\"w-4 h-4 text-input-placeholder mt-0.5\" aria-hidden=\"true\" />\n                        <SettingsHelperText>{addressSummary || 'Not set'}</SettingsHelperText>\n                      </div>\n                    </div>\n                  </div>\n                )}\n              >\n                <div className=\"flex items-center gap-2\">\n                  <Button\n                    variant=\"secondary\"\n                    size=\"sm\"\n                    onClick={openContactModal}\n                    className=\"hidden sm:inline-flex\"\n                  >\n                    Manage\n                  </Button>\n                  <Button\n                    variant=\"icon\"\n                    size=\"icon\"\n                    onClick={openContactModal}\n                    className=\"sm:hidden\"\n                    aria-label=\"Manage contact details\"\n                    icon={<ChevronRightIcon className=\"w-5 h-5\" aria-hidden=\"true\" />}\n                  />\n                </div>\n              </SettingRow>\n\n              <SectionDivider />\n\n              <SettingRow\n                label=\"Services\"\n                labelNode={(\n                  <div>\n                    <h3 className=\"text-sm font-semibold text-input-text\">Services</h3>\n                    {servicesList.length > 0 ? (\n                      <div className=\"mt-2 space-y-1\">\n                        {servicesList.map((service) => (\n                          <SettingsHelperText key={service}>{service}</SettingsHelperText>\n                        ))}\n                      </div>\n                    ) : (\n                      <SettingsHelperText className=\"mt-1\">\n                        No services configured yet\n                      </SettingsHelperText>\n                    )}\n                  </div>\n                )}\n              >\n                <div className=\"flex items-center gap-2\">\n                  <Button\n                    variant=\"secondary\"\n                    size=\"sm\"\n                    onClick={() => navigateTo('/settings/practice/services')}\n                    className=\"hidden sm:inline-flex\"\n                  >\n                    Manage\n                  </Button>\n                  <Button\n                    variant=\"icon\"\n                    size=\"icon\"\n                    onClick={() => navigateTo('/settings/practice/services')}\n                    className=\"sm:hidden\"\n                    aria-label=\"Manage services\"\n                    icon={<ChevronRightIcon className=\"w-5 h-5\" aria-hidden=\"true\" />}\n                  />\n                </div>\n              </SettingRow>\n\n              <SectionDivider />\n\n              <SettingRow\n                label=\"Pricing\"\n                labelNode={(\n                  <div>\n                    <h3 className=\"text-sm font-semibold text-input-text\">Pricing &amp; Fees</h3>\n                    <SettingsHelperText className=\"mt-1\">\n                      Configure consultation fees and billing increments.\n                    </SettingsHelperText>\n                  </div>\n                )}\n              >\n                <div className=\"flex items-center gap-2\">\n                  <Button\n                    variant=\"secondary\"\n                    size=\"sm\"\n                    onClick={() => navigateTo('/settings/practice/pricing')}\n                    className=\"hidden sm:inline-flex\"\n                  >\n                    Manage\n                  </Button>\n                  <Button\n                    variant=\"icon\"\n                    size=\"icon\"\n                    onClick={() => navigateTo('/settings/practice/pricing')}\n                    className=\"sm:hidden\"\n                    aria-label=\"Manage pricing\"\n                    icon={<ChevronRightIcon className=\"w-5 h-5\" aria-hidden=\"true\" />}\n                  />\n                </div>\n              </SettingRow>\n\n              <SectionDivider />\n\n              <SettingRow\n                label=\"Team\"\n                labelNode={(\n                  <div>\n                    <h3 className=\"text-sm font-semibold text-input-text\">\n                      Team Members\n                    </h3>\n                    {members.length > 0 ? (\n                      <div className=\"mt-2\">\n                        <StackedAvatars users={teamAvatars} size=\"sm\" />\n                      </div>\n                    ) : (\n                      <SettingsHelperText className=\"mt-1\">\n                        No team members yet\n                      </SettingsHelperText>\n                    )}\n                  </div>\n                )}\n              >\n                <div className=\"flex items-center gap-2\">\n                  <Button\n                    variant=\"secondary\"\n                    size=\"sm\"\n                    onClick={() => navigateTo(members.length === 0\n                      ? '/settings/practice/team?invite=1'\n                      : '/settings/practice/team')}\n                    className=\"hidden sm:inline-flex\"\n                  >\n                    {members.length === 0 ? 'Invite' : 'Manage'}\n                  </Button>\n                  <Button\n                    variant=\"icon\"\n                    size=\"icon\"\n                    onClick={() => navigateTo(members.length === 0\n                      ? '/settings/practice/team?invite=1'\n                      : '/settings/practice/team')}\n                    className=\"sm:hidden\"\n                    aria-label={members.length === 0 ? 'Invite team members' : 'Manage team members'}\n                    icon={<ChevronRightIcon className=\"w-5 h-5\" aria-hidden=\"true\" />}\n                  />\n                </div>\n              </SettingRow>\n\n              <SectionDivider />\n\n              {/* Visibility Toggle */}\n              <div className=\"py-3\">\n                <Switch\n                  label=\"Public listing\"\n                  description={isPublicValue\n                    ? 'Your practice appears in public listings.'\n                    : 'Your practice is private and not publicly listed.'}\n                  value={isPublicValue}\n                  onChange={handleTogglePublic}\n                  disabled={isSettingsSaving}\n                />\n              </div>\n\n              <SectionDivider />\n\n              {/* Delete Practice Section (Owner only) */}\n              {isOwner && (\n                <>\n                  <SettingRow\n                    label=\"Delete Practice\"\n                    labelNode={(\n                      <div>\n                        <h3 className=\"text-sm font-semibold text-input-text\">Delete Practice</h3>\n                        <SettingsHelperText className=\"mt-1\">\n                          Permanently delete this practice and all its data\n                        </SettingsHelperText>\n                      </div>\n                    )}\n                    className=\"py-3\"\n                  >\n                    {deletionBlockedBySubscription ? (\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={() => {\n                          if (!practice?.id) return;\n                          openBillingPortal({ \n                            practiceId: practice.id, \n                            returnUrl: origin ? `${origin}/settings/practice?sync=1` : '/settings/practice?sync=1' \n                          });\n                        }}\n                        disabled={submitting}\n                        data-testid=\"practice-delete-action\"\n                      >\n                        {t('settings:account.plan.manage')}\n                      </Button>\n                    ) : (\n                      <Button\n                        variant=\"danger-ghost\"\n                        size=\"sm\"\n                        onClick={() => setShowDeleteModal(true)}\n                        data-testid=\"practice-delete-action\"\n                      >\n                        <TrashIcon className=\"w-4 h-4 mr-2\" />\n                        Delete\n                      </Button>\n                    )}\n                  </SettingRow>\n                  {deletionBlockedBySubscription && deletionBlockedMessage && (\n                    <SettingsNotice variant=\"warning\" className=\"mt-2\" role=\"status\" aria-live=\"polite\">\n                      <p className=\"text-xs\">\n                        {deletionBlockedMessage}\n                      </p>\n                    </SettingsNotice>\n                  )}\n                </>\n              )}\n            </>\n          )}\n\n      {/* Edit Practice Modal */}\n      <Modal\n        isOpen={isEditPracticeModalOpen}\n        onClose={() => setIsEditPracticeModalOpen(false)}\n        title=\"Edit Practice\"\n        contentClassName={modalContentClassName}\n        headerClassName={modalHeaderClassName}\n      >\n        <div className=\"space-y-4\">\n          <FormGrid>\n            <div>\n              <FormLabel htmlFor=\"edit-practice-name\">Practice Name *</FormLabel>\n              <Input\n                id=\"edit-practice-name\"\n                value={editPracticeForm.name}\n                onChange={(value) => setEditPracticeForm(prev => ({ ...prev, name: value }))}\n                placeholder=\"Your Law Firm Name\"\n                required\n              />\n            </div>\n\n            <div>\n              <FormLabel>Workspace URL</FormLabel>\n              <SettingsHelperText className=\"mt-1\">\n                {practice?.slug ? practiceUrlValue : 'Slug will be generated automatically'}\n              </SettingsHelperText>\n            </div>\n          </FormGrid>\n\n          <div>\n            <LogoUploadInput\n              imageUrl={hasSavedLogo ? editPracticeForm.logo : null}\n              name={editPracticeForm.name || 'Practice'}\n              label=\"Upload logo (optional)\"\n              description=\"Upload a square logo. Maximum 5 MB.\"\n              accept=\"image/*\"\n              multiple={false}\n              onChange={handleLogoChange}\n              disabled={isSettingsSaving || logoUploading}\n              progress={logoUploading ? logoUploadProgress : null}\n            />\n          </div>\n\n          <div>\n            <PracticeProfileTextFields\n              introMessage={introDraft}\n              onIntroChange={setIntroDraft}\n              introRows={4}\n              introLabel=\"Intro Message\"\n              introPlaceholder=\"Welcome to our firm. How can we help?\"\n              disabled={isSettingsSaving}\n            />\n          </div>\n\n          <div className=\"space-y-2\">\n            <FormLabel htmlFor=\"practice-accent-color\">Accent Color</FormLabel>\n            <div className=\"flex items-center gap-2\">\n              <div\n                className=\"relative h-10 w-10 min-h-10 min-w-10 max-h-10 max-w-10 shrink-0 overflow-hidden rounded-full aspect-square\"\n                style={{ backgroundColor: normalizeAccentColor(accentColorDraft) ?? '#D4AF37' }}\n              >\n                <input\n                  id=\"practice-accent-color\"\n                  type=\"color\"\n                  value={normalizeAccentColor(accentColorDraft) ?? '#D4AF37'}\n                  onChange={(event) => {\n                    const value = (event.target as HTMLInputElement).value;\n                    setAccentColorDraft(normalizeAccentColor(value) ?? '#D4AF37');\n                  }}\n                  className=\"absolute inset-0 h-full w-full cursor-pointer opacity-0\"\n                  disabled={isSettingsSaving}\n                />\n              </div>\n              <Input\n                id=\"practice-accent-color-text\"\n                aria-label=\"Accent color (hex)\"\n                value={accentColorDraft}\n                onChange={(value) => setAccentColorDraft(normalizeAccentColor(value) ?? value.toUpperCase())}\n                placeholder=\"#3B82F6\"\n                disabled={isSettingsSaving}\n              />\n            </div>\n          </div>\n\n          <FormActions\n            className=\"justify-end\"\n            onCancel={() => setIsEditPracticeModalOpen(false)}\n            onSubmit={handleUpdatePractice}\n            submitType=\"button\"\n            submitText=\"Save Changes\"\n            submitDisabled={isSettingsSaving || logoUploading}\n            cancelDisabled={isSettingsSaving}\n          />\n        </div>\n      </Modal>\n\n      {/* Contact Modal */}\n      <Modal\n        isOpen={isContactModalOpen}\n        onClose={() => setIsContactModalOpen(false)}\n        title=\"Contact\"\n        contentClassName={modalContentClassName}\n        headerClassName={modalHeaderClassName}\n      >\n        <div className=\"space-y-4\">\n          {/* Contact Information Fields */}\n          <FormGrid>\n            <Input\n              label=\"Website\"\n              value={contactDraft.website || ''}\n              onChange={(value) => setContactDraft(prev => ({ ...prev, website: value }))}\n              disabled={isSettingsSaving}\n              placeholder=\"https://example.com\"\n            />\n\n            <Input\n              label=\"Business Email\"\n              value={contactDraft.businessEmail || ''}\n              onChange={(value) => setContactDraft(prev => ({ ...prev, businessEmail: value }))}\n              disabled={isSettingsSaving}\n              type=\"email\"\n              placeholder=\"business@example.com\"\n            />\n\n            <Input\n              label=\"Contact Phone\"\n              value={contactDraft.phone || ''}\n              onChange={(value) => setContactDraft(prev => ({ ...prev, phone: value }))}\n              disabled={isSettingsSaving}\n              type=\"tel\"\n              placeholder=\"+1 (555) 123-4567\"\n            />\n          </FormGrid>\n\n          {/* Address Fields */}\n          <div className=\"space-y-4\">\n            <h4 className=\"text-sm font-medium text-input-text\">Address</h4>\n            <AddressExperienceForm\n              initialValues={{ address: contactDraft.address }}\n              fields={['address']}\n              required={[]}\n              onValuesChange={(values) => {\n                if (values.address !== undefined) {\n                  setContactDraft(prev => ({\n                    ...prev,\n                    address: values.address as Address,\n                  }));\n                }\n              }}\n              showSubmitButton={false}\n              variant=\"plain\"\n              disabled={isSettingsSaving}\n            />\n          </div>\n\n          <FormActions\n            className=\"justify-end\"\n            onCancel={() => setIsContactModalOpen(false)}\n            onSubmit={handleSaveContact}\n            submitType=\"button\"\n            submitText=\"Save\"\n            disabled={isSettingsSaving}\n          />\n        </div>\n      </Modal>\n\n      {/* Create Practice Modal */}\n      <Modal\n        isOpen={showCreateModal}\n        onClose={() => setShowCreateModal(false)}\n        title=\"Create Practice\"\n        contentClassName={modalContentClassName}\n        headerClassName={modalHeaderClassName}\n      >\n        <div className=\"space-y-4\">\n          <FormGrid>\n            <div>\n              <FormLabel htmlFor=\"practice-name\">Practice Name *</FormLabel>\n              <Input\n                id=\"practice-name\"\n                value={createForm.name}\n                onChange={(value) => setCreateForm(prev => ({ ...prev, name: value }))}\n                placeholder=\"Your Law Firm Name\"\n                required\n              />\n            </div>\n\n            <div className=\"@md:col-span-2\">\n              <FormLabel htmlFor=\"practice-description\">Description (optional)</FormLabel>\n              <Input\n                id=\"practice-description\"\n                value={createForm.description}\n                onChange={(value) => setCreateForm(prev => ({ ...prev, description: value }))}\n                placeholder=\"Brief description of your practice\"\n              />\n            </div>\n          </FormGrid>\n          \n          <FormActions\n            className=\"justify-end\"\n            onCancel={() => setShowCreateModal(false)}\n            onSubmit={handleCreatePractice}\n            submitType=\"button\"\n            submitText=\"Create Practice\"\n            isLoading={isSettingsSaving}\n          />\n        </div>\n      </Modal>\n\n\n      {/* Delete Practice Modal */}\n      <Modal\n        isOpen={showDeleteModal}\n        onClose={() => setShowDeleteModal(false)}\n        title=\"Delete Practice\"\n        contentClassName={modalContentClassName}\n        headerClassName={modalHeaderClassName}\n      >\n        <div className=\"space-y-4\">\n          <SettingsNotice variant=\"danger\" className=\"p-4\">\n            <p className=\"text-sm\">\n               This action cannot be undone. This will permanently delete the practice and all its data.\n            </p>\n          </SettingsNotice>\n          \n          <div>\n            <FormLabel htmlFor=\"delete-confirm\">\n              Type the practice name to confirm: <strong>{practice?.name}</strong>\n            </FormLabel>\n            <Input\n              id=\"delete-confirm\"\n              value={deleteConfirmText}\n              onChange={setDeleteConfirmText}\n              placeholder=\"Enter practice name\"\n            />\n          </div>\n          \n          <FormActions\n            className=\"justify-end\"\n            onCancel={() => !isDeleting && setShowDeleteModal(false)}\n            onSubmit={handleDeletePractice}\n            submitType=\"button\"\n            submitVariant=\"danger-ghost\"\n            submitText=\"Delete Practice\"\n            isLoading={isDeleting}\n            submitDisabled={deleteConfirmText.trim() !== practice?.name}\n          />\n        </div>\n      </Modal>\n\n    </SettingsPageLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/PracticePricingPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/PracticeServicesPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/PracticeTeamPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/PrivacyPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":69,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":69,"endColumn":19,"suggestions":[{"fix":{"range":[2800,2859],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":87,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":87,"endColumn":20,"suggestions":[{"fix":{"range":[3366,3425],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useRef, useState } from 'preact/hooks';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { SettingSection } from '@/features/settings/components/SettingSection';\nimport { SettingToggle } from '@/features/settings/components/SettingToggle';\nimport { SectionDivider } from '@/shared/ui';\nimport { Button } from '@/shared/ui/Button';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport Modal from '@/shared/components/Modal';\nimport { SettingsPageLayout } from '@/features/settings/components/SettingsPageLayout';\nimport { SettingsNotice } from '@/features/settings/components/SettingsNotice';\n\ntype PrivacySettings = {\n  piiConsentGiven: boolean;\n  dataProcessingConsent: boolean;\n  dataRetentionConsent: boolean;\n  marketingConsent: boolean;\n};\n\nconst DEFAULT_PRIVACY_SETTINGS: PrivacySettings = {\n  piiConsentGiven: false,\n  dataProcessingConsent: false,\n  dataRetentionConsent: false,\n  marketingConsent: false\n};\n\nconst PRIVACY_STORAGE_KEY = 'privacyPreferences';\n\n// Critical consents that require confirmation when disabling\nconst CRITICAL_CONSENTS: (keyof PrivacySettings)[] = ['piiConsentGiven', 'dataProcessingConsent'];\n\nexport default function PrivacyPage() {\n  const { showSuccess, showError } = useToastContext();\n  const { navigate } = useNavigation();\n  const [settings, setSettings] = useState<PrivacySettings>(DEFAULT_PRIVACY_SETTINGS);\n  const [showConfirmDialog, setShowConfirmDialog] = useState(false);\n  const [pendingToggle, setPendingToggle] = useState<{ key: keyof PrivacySettings; value: boolean } | null>(null);\n  const isInitialLoad = useRef(true);\n  const shouldPersist = useRef(false);\n\n  // Load settings from localStorage on mount\n  useEffect(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    try {\n      const stored = window.localStorage.getItem(PRIVACY_STORAGE_KEY);\n      if (!stored) return;\n      const parsed = JSON.parse(stored);\n      \n      // Validate parsed data before merging\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        const validated: Partial<PrivacySettings> = {};\n        if (typeof parsed.piiConsentGiven === 'boolean') {\n          validated.piiConsentGiven = parsed.piiConsentGiven;\n        }\n        if (typeof parsed.dataProcessingConsent === 'boolean') {\n          validated.dataProcessingConsent = parsed.dataProcessingConsent;\n        }\n        if (typeof parsed.dataRetentionConsent === 'boolean') {\n          validated.dataRetentionConsent = parsed.dataRetentionConsent;\n        }\n        if (typeof parsed.marketingConsent === 'boolean') {\n          validated.marketingConsent = parsed.marketingConsent;\n        }\n        setSettings(prev => ({ ...prev, ...validated }));\n      }\n    } catch (error) {\n      console.warn('Failed to load privacy preferences:', error);\n    } finally {\n      isInitialLoad.current = false;\n    }\n  }, []);\n\n  // Sync settings to localStorage when they change (but not on initial load)\n  useEffect(() => {\n    if (isInitialLoad.current || !shouldPersist.current) {\n      return;\n    }\n\n    try {\n      if (typeof window !== 'undefined') {\n        window.localStorage.setItem(PRIVACY_STORAGE_KEY, JSON.stringify(settings));\n        showSuccess('Privacy updated', 'Your privacy preferences have been saved.');\n      }\n    } catch (error) {\n      console.error('Failed to update privacy settings:', error);\n      showError('Update failed', 'We could not save your privacy preferences. Please try again.');\n    } finally {\n      shouldPersist.current = false;\n    }\n  }, [settings, showError, showSuccess]);\n\n  const handleToggle = useCallback(async (key: keyof PrivacySettings, value: boolean) => {\n    // If disabling a critical consent, show confirmation dialog\n    if (!value && CRITICAL_CONSENTS.includes(key)) {\n      setPendingToggle({ key, value });\n      setShowConfirmDialog(true);\n      return;\n    }\n\n    // For enabling or non-critical toggles, proceed directly\n    shouldPersist.current = true;\n    setSettings(prev => ({ ...prev, [key]: value }));\n  }, []);\n\n  const handleConfirmToggle = useCallback(() => {\n    if (!pendingToggle) return;\n\n    shouldPersist.current = true;\n    setSettings(prev => ({ ...prev, [pendingToggle.key]: pendingToggle.value }));\n\n    setShowConfirmDialog(false);\n    setPendingToggle(null);\n  }, [pendingToggle]);\n\n  const handleCancelToggle = useCallback(() => {\n    setShowConfirmDialog(false);\n    setPendingToggle(null);\n  }, []);\n\n  return (\n    <SettingsPageLayout title=\"Privacy\">\n      <SettingSection\n        title=\"Consent & data use\"\n        description=\"Control how Blawby processes and retains your personal data.\"\n      >\n        <SettingToggle\n          id=\"privacy-pii-consent\"\n          label=\"Allow handling of sensitive personal data\"\n          description=\"Required for storing intake details and supporting documents. Disabling may limit service functionality.\"\n          value={settings.piiConsentGiven}\n          onChange={(value) => handleToggle('piiConsentGiven', value)}\n        />\n        <SettingToggle\n          id=\"privacy-processing-consent\"\n          label=\"Allow data processing for service delivery\"\n          description=\"Required for case analysis and communications. Disabling may limit service functionality.\"\n          value={settings.dataProcessingConsent}\n          onChange={(value) => handleToggle('dataProcessingConsent', value)}\n        />\n        <SettingToggle\n          id=\"privacy-retention-consent\"\n          label=\"Allow data retention for ongoing matters\"\n          description=\"Keeps your records available across future sessions.\"\n          value={settings.dataRetentionConsent}\n          onChange={(value) => handleToggle('dataRetentionConsent', value)}\n        />\n        <SettingToggle\n          id=\"privacy-marketing-consent\"\n          label=\"Allow product updates and marketing\"\n          description=\"Receive product updates, tips, and service announcements.\"\n          value={settings.marketingConsent}\n          onChange={(value) => handleToggle('marketingConsent', value)}\n        />\n      </SettingSection>\n\n      <SectionDivider />\n\n      <SettingSection\n        title=\"Data requests\"\n        description=\"Need a copy of your data or want to delete your account?\"\n      >\n        <div className=\"flex flex-col gap-3 py-3 sm:flex-row\">\n          <Button\n            variant=\"secondary\"\n            onClick={() => window.open('https://blawby.com/privacy', '_blank', 'noopener,noreferrer')}\n          >\n            View privacy policy\n          </Button>\n          <Button\n            variant=\"secondary\"\n            onClick={() => navigate('/settings/account')}\n          >\n            Manage account deletion\n          </Button>\n        </div>\n      </SettingSection>\n\n      {/* Confirmation Dialog for Critical Consents */}\n      <Modal\n        isOpen={showConfirmDialog}\n        onClose={handleCancelToggle}\n        title=\"Confirm Privacy Setting Change\"\n        disableBackdropClick={true}\n      >\n        <div className=\"space-y-4\">\n          <SettingsNotice variant=\"warning\" className=\"p-4\">\n            <p className=\"text-sm font-medium mb-2\">\n               Warning: Disabling this consent may limit service functionality\n            </p>\n            <p className=\"text-sm text-amber-700 dark:text-amber-300\">\n              {pendingToggle?.key === 'piiConsentGiven' && (\n                <>\n                  Disabling PII handling consent means we cannot store your intake details and supporting documents. \n                  This may prevent you from using core features of the service.\n                </>\n              )}\n              {pendingToggle?.key === 'dataProcessingConsent' && (\n                <>\n                  Disabling data processing consent means we cannot provide case analysis and communications. \n                  This may significantly limit the service functionality.\n                </>\n              )}\n            </p>\n          </SettingsNotice>\n\n          <SettingsNotice variant=\"info\">\n            <p className=\"text-sm\">\n              <strong>Note:</strong> Your existing data will remain stored according to your data retention preferences. \n              You can re-enable this consent at any time.\n            </p>\n          </SettingsNotice>\n\n          <div className=\"flex justify-end gap-3 pt-4\">\n            <Button variant=\"secondary\" onClick={handleCancelToggle}>\n              Cancel\n            </Button>\n            <Button \n              variant=\"danger-ghost\"\n              onClick={handleConfirmToggle}\n            >\n              Disable Anyway\n            </Button>\n          </div>\n        </div>\n      </Modal>\n    </SettingsPageLayout>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/SecurityPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":112,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":112,"endColumn":22,"suggestions":[{"fix":{"range":[4439,4500],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":169,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":169,"endColumn":22,"suggestions":[{"fix":{"range":[6206,6266],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":213,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":213,"endColumn":20,"suggestions":[{"fix":{"range":[7587,7634],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'preact/hooks';\nimport { Button } from '@/shared/ui/Button';\nimport { SectionDivider } from '@/shared/ui';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { authClient } from '@/shared/lib/authClient';\nimport Modal from '@/shared/components/Modal';\nimport { ExclamationTriangleIcon } from '@heroicons/react/24/outline';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport type { SecuritySettings } from '@/shared/types/user';\nimport { SettingSection } from '@/features/settings/components/SettingSection';\nimport { SettingToggle } from '@/features/settings/components/SettingToggle';\nimport { SettingRow } from '@/features/settings/components/SettingRow';\nimport { PasswordChangeForm } from '@/features/settings/components/PasswordChangeForm';\nimport { SettingsPageLayout } from '@/features/settings/components/SettingsPageLayout';\nimport { SettingsDangerButton } from '@/features/settings/components/SettingsDangerButton';\nimport { SettingsHelperText } from '@/features/settings/components/SettingsHelperText';\nimport { getPreferencesCategory, updatePreferencesCategory } from '@/shared/lib/preferencesApi';\nimport type { SecurityPreferences } from '@/shared/types/preferences';\nimport { FormActions } from '@/shared/ui/form';\n\n// Local interface for user with security-related fields\ninterface SecurityUser {\n  twoFactorEnabled?: boolean;\n  emailNotifications?: boolean;\n  loginAlerts?: boolean;\n  lastPasswordChange?: Date | string | number;\n}\n\n// Runtime validation for lastPasswordChange values\nconst isValidDate = (value: unknown): value is Date | string | number => {\n  if (value === null || value === undefined) {\n    return false;\n  }\n  \n  // If it's already a Date, check if it's valid\n  if (value instanceof Date) {\n    return !isNaN(value.getTime());\n  }\n  \n  // Handle numbers explicitly by checking if they produce valid dates\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return Number.isFinite(new Date(value).getTime());\n  }\n  \n  // For strings, use Date.parse\n  if (typeof value === 'string') {\n    const timestamp = Date.parse(value);\n    return isFinite(timestamp);\n  }\n  \n  return false;\n};\n\n// Safely convert lastPasswordChange to Date or undefined\nconst safeConvertLastPasswordChange = (value: unknown): Date | undefined => {\n  if (!isValidDate(value)) {\n    return undefined;\n  }\n  \n  const date = new Date(value as Date | string | number);\n  // Double-check the resulting Date is valid\n  return isNaN(date.getTime()) ? undefined : date;\n};\n\nexport interface SecurityPageProps {\n  isMobile?: boolean;\n  onClose?: () => void;\n  className?: string;\n}\n\nexport const SecurityPage = ({\n  isMobile: _isMobile = false,\n  onClose: _onClose,\n  className = ''\n}: SecurityPageProps) => {\n  const { showSuccess, showError } = useToastContext();\n  const { navigate } = useNavigation();\n  const { t } = useTranslation(['settings', 'common']);\n  const { session, isPending } = useSessionContext();\n  const [settings, setSettings] = useState<SecuritySettings | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isChangingPassword, setIsChangingPassword] = useState(false);\n  const [showDisableMFAConfirm, setShowDisableMFAConfirm] = useState(false);\n  const showMfa = false;\n  const [passwordForm, setPasswordForm] = useState({\n    currentPassword: '',\n    newPassword: '',\n    confirmPassword: ''\n  });\n\n  // Load settings from preferences API\n  useEffect(() => {\n    let isMounted = true;\n\n    const loadPreferences = async () => {\n      try {\n        setIsLoading(true);\n        const prefs = await getPreferencesCategory<SecurityPreferences>('security');\n        if (!isMounted) return;\n        const securitySettings: SecuritySettings = {\n          twoFactorEnabled: prefs?.two_factor_enabled ?? false,\n          emailNotifications: prefs?.email_notifications ?? true,\n          loginAlerts: prefs?.login_alerts ?? true,\n          sessionTimeout: prefs?.session_timeout,\n          lastPasswordChange: safeConvertLastPasswordChange((session?.user as SecurityUser | undefined)?.lastPasswordChange) ?? null,\n          connectedAccounts: [] // This would need to be populated from accounts table if needed\n        };\n        setSettings(securitySettings);\n      } catch (error) {\n        console.error('Failed to load security preferences:', error);\n        setSettings(null);\n      } finally {\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    void loadPreferences();\n\n    return () => {\n      isMounted = false;\n    };\n  }, [session?.user]);\n\n  // Refresh settings when component regains focus (e.g., returning from MFA enrollment)\n  useEffect(() => {\n    const handleFocus = () => {\n      // Settings will be refreshed automatically when session updates\n      // No need to manually reload since we're using reactive session data\n    };\n\n    window.addEventListener('focus', handleFocus);\n    return () => window.removeEventListener('focus', handleFocus);\n  }, []);\n\n  const handleToggleChange = async (key: string, value: boolean) => {\n    if (!settings) return;\n    \n    if (key === 'twoFactorEnabled') {\n      if (value) {\n        // Enable MFA: Navigate to enrollment page without updating state\n        navigate('/settings/mfa-enrollment');\n      } else {\n        // Disable MFA: Show confirmation dialog\n        setShowDisableMFAConfirm(true);\n      }\n    } else {\n      // Handle other toggles normally\n      const updatedSettings = { ...settings, [key]: value };\n      setSettings(updatedSettings);\n      \n      try {\n      const updateData: Partial<SecurityPreferences> = {};\n      if (key === 'emailNotifications') {\n        updateData.email_notifications = value;\n      } else if (key === 'loginAlerts') {\n        updateData.login_alerts = value;\n      }\n        await updatePreferencesCategory('security', updateData);\n        \n        showSuccess(\n          t('common:notifications.settingsSavedTitle'),\n          t('settings:security.toasts.settingsUpdated')\n        );\n      } catch (error) {\n        console.error('Failed to update security settings:', error);\n        showError(\n          t('common:notifications.settingsSaveErrorTitle'),\n          t('common:notifications.settingsSaveErrorBody')\n        );\n        \n        // Revert the local state on error\n        setSettings(settings);\n      }\n    }\n  };\n\n  const handleConfirmDisableMFA = async () => {\n    if (!settings) return;\n    \n    // Check if user session is authenticated\n    if (!session?.user) {\n      showError(\n        t('common:notifications.settingsSaveErrorTitle'),\n        t('common:notifications.sessionExpired')\n      );\n      setShowDisableMFAConfirm(false);\n      return;\n    }\n    \n    const updatedSettings = { ...settings, twoFactorEnabled: false };\n    setSettings(updatedSettings);\n    \n    try {\n      // Disable MFA using Better Auth twoFactor plugin (if available)\n      const twoFactorClient = (authClient as { twoFactor?: { disable: () => Promise<void> } }).twoFactor;\n      if (twoFactorClient) {\n        await twoFactorClient.disable();\n      } else {\n        throw new Error('Two-factor authentication is not available');\n      }\n      \n      await updatePreferencesCategory('security', { two_factor_enabled: false });\n      \n      showSuccess(\n        t('settings:security.mfa.disable.toastTitle'),\n        t('settings:security.mfa.disable.toastBody')\n      );\n    } catch (error) {\n      console.error('Failed to disable MFA:', error);\n      showError(\n        t('common:notifications.settingsSaveErrorTitle'),\n        t('common:notifications.settingsSaveErrorBody')\n      );\n      \n      // Revert the local state on error\n      setSettings(settings);\n    }\n    \n    setShowDisableMFAConfirm(false);\n  };\n\n  const handleCancelDisableMFA = () => {\n    setShowDisableMFAConfirm(false);\n  };\n\n  const handlePasswordChange = (field: string, value: string) => {\n    setPasswordForm(prev => ({ ...prev, [field]: value }));\n  };\n\n  const handleChangePassword = async () => {\n    if (!passwordForm.currentPassword || !passwordForm.newPassword || !passwordForm.confirmPassword) {\n      showError(\n        t('settings:security.password.errors.missing.title'),\n        t('settings:security.password.errors.missing.body')\n      );\n      return;\n    }\n\n    if (passwordForm.newPassword !== passwordForm.confirmPassword) {\n      showError(\n        t('settings:security.password.errors.mismatch.title'),\n        t('settings:security.password.errors.mismatch.body')\n      );\n      return;\n    }\n\n    if (passwordForm.newPassword.length < 8) {\n      showError(\n        t('settings:security.password.errors.weak.title'),\n        t('settings:security.password.errors.weak.body')\n      );\n      return;\n    }\n\n    try {\n      // Here you would call your API to change the password\n      // await authService.changePassword(passwordForm.currentPassword, passwordForm.newPassword);\n      \n      showSuccess(\n        t('settings:security.password.success.title'),\n        t('settings:security.password.success.body')\n      );\n      setPasswordForm({ currentPassword: '', newPassword: '', confirmPassword: '' });\n      setIsChangingPassword(false);\n    } catch (error) {\n      showError(\n        t('settings:security.password.errors.failed.title'),\n        error instanceof Error ? error.message : t('settings:security.password.errors.failed.body')\n      );\n    }\n  };\n\n  const handleResetPassword = () => {\n    // Here you would trigger a password reset email\n    showSuccess(\n      t('settings:security.password.reset.title'),\n      t('settings:security.password.reset.body')\n    );\n  };\n\n  const handleLogout = (type: 'current' | 'all') => {\n    if (type === 'current') {\n      showSuccess(\n        t('settings:security.logout.current.toastTitle'),\n        t('settings:security.logout.current.toastBody')\n      );\n    } else {\n      showSuccess(\n        t('settings:security.logout.all.toastTitle'),\n        t('settings:security.logout.all.toastBody')\n      );\n    }\n  };\n\n  // Show loading state while session or preferences are loading\n  if (isPending || isLoading) {\n    return (\n      <div className={`h-full flex items-center justify-center ${className}`}>\n        <div className=\"w-8 h-8 border-2 border-accent-500 border-t-transparent rounded-full animate-spin\" />\n      </div>\n    );\n  }\n\n\n  if (!settings) {\n    return (\n      <div className={`h-full flex items-center justify-center ${className}`}>\n        <p className=\"text-input-placeholder\">{t('settings:security.fallback')}</p>\n      </div>\n    );\n  }\n\n  return (\n    <SettingsPageLayout title={t('settings:security.title')} className={className}>\n      {/* Password Section */}\n      <SettingSection\n        title={t('settings:security.password.sectionTitle')}\n        description={t('settings:security.password.description')}\n      >\n        <div className=\"flex items-center justify-end gap-2 mb-4\">\n          <Button\n            variant=\"secondary\"\n            size=\"sm\"\n            onClick={() => setIsChangingPassword(!isChangingPassword)}\n          >\n            {isChangingPassword ? t('settings:security.password.cancelButton') : t('settings:security.password.changeButton')}\n          </Button>\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={handleResetPassword}\n            className=\"text-accent-600 dark:text-accent-400 hover:text-accent-700 dark:hover:text-accent-300\"\n          >\n            {t('settings:security.password.resetButton')}\n          </Button>\n        </div>\n\n        <PasswordChangeForm\n          currentPassword={passwordForm.currentPassword}\n          newPassword={passwordForm.newPassword}\n          confirmPassword={passwordForm.confirmPassword}\n          onCurrentPasswordChange={(value) => handlePasswordChange('currentPassword', value)}\n          onNewPasswordChange={(value) => handlePasswordChange('newPassword', value)}\n          onConfirmPasswordChange={(value) => handlePasswordChange('confirmPassword', value)}\n          onSubmit={handleChangePassword}\n          onCancel={() => {\n            setIsChangingPassword(false);\n            setPasswordForm({ currentPassword: '', newPassword: '', confirmPassword: '' });\n          }}\n          isOpen={isChangingPassword}\n        />\n      </SettingSection>\n\n      <SectionDivider />\n      {showMfa && (\n        <>\n          {/* Multi-factor authentication Section */}\n          <SettingToggle\n            label={t('settings:security.mfa.title')}\n            description={t('settings:security.mfa.description')}\n            value={settings.twoFactorEnabled}\n            onChange={(value) => handleToggleChange('twoFactorEnabled', value)}\n            id=\"mfa-toggle\"\n          />\n\n          <SectionDivider />\n        </>\n      )}\n\n      {/* Trusted Devices Section */}\n      <SettingRow\n        label={t('settings:security.trustedDevices.title')}\n        description={t('settings:security.trustedDevices.description')}\n      >\n        <SettingsHelperText\n          aria-label={t('settings:security.trustedDevices.comingSoonAria', { defaultValue: 'Trusted devices management is coming soon' })}\n        >\n          {t('settings:security.trustedDevices.comingSoon', { defaultValue: 'Coming soon' })}\n        </SettingsHelperText>\n      </SettingRow>\n\n      <SectionDivider />\n\n      {/* Log out of this device Section */}\n      <SettingRow\n        label={t('settings:security.logout.current.title')}\n      >\n        <Button\n          variant=\"secondary\"\n          size=\"sm\"\n          onClick={() => handleLogout('current')}\n        >\n          {t('settings:security.logout.current.button')}\n        </Button>\n      </SettingRow>\n\n      <SectionDivider />\n\n      {/* Log out of all devices Section */}\n      <SettingRow\n        label={t('settings:security.logout.all.title')}\n        description={t('settings:security.logout.all.description')}\n      >\n        <SettingsDangerButton\n          size=\"sm\"\n          onClick={() => handleLogout('all')}\n        >\n          {t('settings:security.logout.all.button')}\n        </SettingsDangerButton>\n      </SettingRow>\n\n      {showMfa && (\n        <>\n          {/* MFA Disable Confirmation Modal */}\n          <Modal\n            isOpen={showDisableMFAConfirm}\n            onClose={handleCancelDisableMFA}\n            title={t('settings:security.mfa.disable.modalTitle')}\n            showCloseButton={true}\n            type=\"modal\"\n          >\n            <div className=\"space-y-4\">\n              <div className=\"flex items-start gap-3\">\n                <div className=\"flex-shrink-0\">\n                  <ExclamationTriangleIcon className=\"w-6 h-6 text-orange-500\" />\n                </div>\n                <div className=\"flex-1\">\n                  <h3 className=\"text-lg font-semibold text-input-text mb-2\">\n                    {t('settings:security.mfa.disable.heading')}\n                  </h3>\n                  <p className=\"text-sm text-input-placeholder\">\n                    {t('settings:security.mfa.disable.description')}\n                  </p>\n                </div>\n              </div>\n              \n              <FormActions\n                className=\"justify-end\"\n                size=\"sm\"\n                onCancel={handleCancelDisableMFA}\n                onSubmit={handleConfirmDisableMFA}\n                submitType=\"button\"\n                submitVariant=\"warning\"\n                cancelText={t('settings:security.mfa.disable.cancel')}\n                submitText={t('settings:security.mfa.disable.confirm')}\n              />\n            </div>\n          </Modal>\n        </>\n      )}\n    </SettingsPageLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/SettingsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/__tests__/PracticePage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/pages/appsData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/features/settings/utils/notificationPolicy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/index.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":103,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":103,"endColumn":23,"suggestions":[{"fix":{"range":[4300,4369],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":131,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":131,"endColumn":23,"suggestions":[{"fix":{"range":[5335,5406],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":291,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":291,"endColumn":26,"suggestions":[{"fix":{"range":[12228,12313],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":296,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":296,"endColumn":22,"suggestions":[{"fix":{"range":[12494,12578],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":415,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":415,"endColumn":18,"suggestions":[{"fix":{"range":[15923,15970],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":449,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":449,"endColumn":21,"suggestions":[{"fix":{"range":[17126,17195],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":551,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":551,"endColumn":18,"suggestions":[{"fix":{"range":[19663,19710],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":640,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":640,"endColumn":18,"suggestions":[{"fix":{"range":[22098,22145],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":673,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":673,"endColumn":20,"suggestions":[{"fix":{"range":[23184,23235],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":677,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":677,"endColumn":24,"suggestions":[{"fix":{"range":[23327,23399],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":682,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":682,"endColumn":24,"suggestions":[{"fix":{"range":[23635,23892],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":692,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":692,"endColumn":28,"suggestions":[{"fix":{"range":[24021,24257],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":703,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":703,"endColumn":24,"suggestions":[{"fix":{"range":[24594,24645],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":707,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":707,"endColumn":28,"suggestions":[{"fix":{"range":[24746,24976],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":715,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":715,"endColumn":26,"suggestions":[{"fix":{"range":[25245,25371],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":721,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":721,"endColumn":26,"suggestions":[{"fix":{"range":[25515,25900],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":732,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":732,"endColumn":20,"suggestions":[{"fix":{"range":[26118,26245],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":836,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":836,"endColumn":20,"suggestions":[{"fix":{"range":[28936,28988],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":681,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":681,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23618,23621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23618,23621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { hydrate, prerender as ssr, Router, Route, useLocation, LocationProvider } from 'preact-iso';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { Suspense } from 'preact/compat';\nimport { I18nextProvider } from 'react-i18next';\nimport AuthPage from '@/pages/AuthPage';\nimport AcceptInvitationPage from '@/pages/AcceptInvitationPage';\nimport AwaitingInvitePage from '@/pages/AwaitingInvitePage';\nimport OnboardingPage from '@/pages/OnboardingPage';\nimport PricingPage from '@/pages/PricingPage';\nimport DebugStylesPage from '@/pages/DebugStylesPage';\nimport { SEOHead } from '@/app/SEOHead';\nimport { ToastProvider } from '@/shared/contexts/ToastContext';\nimport { SessionProvider, useSessionContext } from '@/shared/contexts/SessionContext';\nimport { getClient, getSession } from '@/shared/lib/authClient';\nimport { MainApp } from '@/app/MainApp';\nimport { SettingsPage } from '@/features/settings/pages/SettingsPage';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { usePracticeConfig } from '@/shared/hooks/usePracticeConfig';\nimport { useMobileDetection } from '@/shared/hooks/useMobileDetection';\nimport { handleError } from '@/shared/utils/errorHandler';\nimport { useWorkspace } from '@/shared/hooks/useWorkspace';\nimport { getSettingsReturnPath, getWorkspaceHomePath, resolveWorkspaceFromPath, setSettingsReturnPath } from '@/shared/utils/workspace';\nimport { usePracticeManagement } from '@/shared/hooks/usePracticeManagement';\nimport { PaySuccessPage } from '@/pages/PaySuccessPage';\nimport { AppGuard } from '@/app/AppGuard';\nimport { PracticeNotFound } from '@/features/practice/components/PracticeNotFound';\nimport { normalizePracticeRole } from '@/shared/utils/practiceRoles';\nimport { Button } from '@/shared/ui/Button';\nimport './index.css';\nimport { i18n, initI18n } from '@/shared/i18n';\nimport { initializeAccentColor } from '@/shared/utils/accentColors';\n\nconst LoadingScreen = () => (\n  <div className=\"flex h-screen items-center justify-center text-sm text-gray-500 dark:text-gray-400\">\n    Loading\n  </div>\n);\n\nconst NotFoundRoute = () => {\n  const { navigate } = useNavigation();\n\n  return (\n    <div className=\"flex h-screen flex-col items-center justify-center gap-4 text-sm text-gray-500 dark:text-gray-400\">\n      <div className=\"text-lg font-medium\">Page Not Found</div>\n      <div>The page you&apos;re looking for doesn&apos;t exist.</div>\n      <Button\n        type=\"button\"\n        variant=\"link\"\n        onClick={() => navigate('/')}\n      >\n        Return to Home\n      </Button>\n    </div>\n  );\n};\n\n// Client routes align with public structure\n\n// Main App component with routing\nexport function App() {\n  return (\n    <LocationProvider>\n      <SessionProvider>\n        <AppGuard>\n          <AppShell />\n        </AppGuard>\n      </SessionProvider>\n    </LocationProvider>\n  );\n}\n\nfunction AppShell() {\n  const location = useLocation();\n  const { navigate } = useNavigation();\n  const { session, isPending: sessionPending, activeOrganizationId } = useSessionContext();\n  const { defaultWorkspace, canAccessPractice, isPracticeLoading } = useWorkspace();\n  const { currentPractice, practices } = usePracticeManagement();\n  const lastActivePracticeRef = useRef<string | null>(null);\n\n  const handleRouteChange = useCallback((url: string) => {\n    if (typeof window === 'undefined') return;\n\n    if (!url.startsWith('/settings')) {\n      setSettingsReturnPath(url);\n    }\n\n    if (sessionPending || !session?.user) return;\n    const path = url.split('?')[0].split('#')[0];\n    const workspaceFromPath = resolveWorkspaceFromPath(path);\n    if (workspaceFromPath !== 'client' && workspaceFromPath !== 'practice') return;\n    if (workspaceFromPath === 'practice' && (isPracticeLoading || !canAccessPractice)) {\n      return;\n    }\n\n    if (workspaceFromPath === 'practice') {\n      const practiceIdCandidate = activeOrganizationId ?? null;\n\n      if (practiceIdCandidate && lastActivePracticeRef.current !== practiceIdCandidate) {\n        const previousActivePractice = lastActivePracticeRef.current;\n        lastActivePracticeRef.current = practiceIdCandidate;\n        const client = getClient();\n        client.organization.setActive({ organizationId: practiceIdCandidate }).catch((error) => {\n          console.warn('[Workspace] Failed to set active organization', error);\n          lastActivePracticeRef.current = previousActivePractice;\n        });\n      }\n    }\n  }, [activeOrganizationId, canAccessPractice, isPracticeLoading, session?.user, sessionPending]);\n\n  useEffect(() => {\n    if (sessionPending) return;\n    if (typeof window !== 'undefined') {\n      try {\n        const pendingPath = window.sessionStorage.getItem('intakeAwaitingInvitePath');\n        if (pendingPath) {\n          window.sessionStorage.removeItem('intakeAwaitingInvitePath');\n          if (pendingPath.startsWith('/') && !pendingPath.startsWith('//')) {\n            if (!location.path.startsWith('/auth/awaiting-invite')) {\n              navigate(pendingPath, true);\n            }\n            return;\n          }\n        }\n      } catch (error) {\n        try {\n          window.sessionStorage.removeItem('intakeAwaitingInvitePath');\n        } catch (_innerError) {\n          // Ignore secondary failure\n        }\n        if (import.meta.env.DEV) {\n          console.warn('[Workspace] Failed to read intake awaiting path', error);\n        }\n      }\n    }\n    const user = session?.user;\n    const requiresOnboarding =\n      Boolean(user) && !user?.isAnonymous && user?.onboardingComplete !== true;\n\n    if (requiresOnboarding) {\n      if (!location.path.startsWith('/onboarding') && !location.path.startsWith('/auth')) {\n        const targetUrl = location.url.startsWith('/')\n          ? location.url\n          : `/${location.url.replace(/^\\/+/, '')}`;\n        const encodedReturnTo = encodeURIComponent(targetUrl);\n        const onboardingUrl = encodedReturnTo\n          ? `/onboarding?returnTo=${encodedReturnTo}`\n          : '/onboarding';\n        navigate(onboardingUrl, true);\n      }\n      return;\n    }\n\n    if (!requiresOnboarding && location.path.startsWith('/onboarding')) {\n      const fallbackSlug = currentPractice?.slug ?? practices[0]?.slug ?? null;\n      const fallback = getWorkspaceHomePath(defaultWorkspace, fallbackSlug, '/');\n      navigate(fallback, true);\n    }\n  }, [currentPractice, defaultWorkspace, location.path, location.url, navigate, practices, session?.user, sessionPending]);\n\n  return (\n    <ToastProvider>\n      <Suspense fallback={<LoadingScreen />}>\n        <Router onRouteChange={handleRouteChange}>\n          <Route path=\"/auth\" component={AuthPage} />\n          <Route path=\"/auth/accept-invitation\" component={AcceptInvitationPage} />\n          <Route path=\"/auth/awaiting-invite\" component={AwaitingInvitePage} />\n          <Route path=\"/pricing\" component={PricingPage} />\n          <Route path=\"/onboarding\" component={OnboardingPage} />\n          <Route path=\"/debug/styles\" component={import.meta.env.DEV ? DebugStylesPage : NotFoundRoute} />\n          <Route path=\"/pay\" component={PaySuccessPage} />\n          <Route path=\"/settings\" component={SettingsRoute} />\n          <Route path=\"/settings/*\" component={SettingsRoute} />\n          <Route path=\"/public/:practiceSlug\" component={PublicPracticeRoute} workspaceView=\"home\" />\n          <Route path=\"/public/:practiceSlug/conversations\" component={PublicPracticeRoute} workspaceView=\"list\" />\n          <Route path=\"/public/:practiceSlug/conversations/:conversationId\" component={PublicPracticeRoute} workspaceView=\"conversation\" />\n          <Route path=\"/public/:practiceSlug/matters\" component={PublicPracticeRoute} workspaceView=\"matters\" />\n          <Route path=\"/client\" component={NotFoundRoute} />\n          <Route path=\"/client/:practiceSlug\" component={ClientPracticeRoute} workspaceView=\"home\" />\n          <Route path=\"/client/:practiceSlug/conversations\" component={ClientPracticeRoute} workspaceView=\"list\" />\n          <Route path=\"/client/:practiceSlug/conversations/:conversationId\" component={ClientPracticeRoute} workspaceView=\"conversation\" />\n          <Route path=\"/client/:practiceSlug/matters\" component={ClientPracticeRoute} workspaceView=\"matters\" />\n          <Route path=\"/practice\" component={NotFoundRoute} />\n          <Route path=\"/practice/:practiceSlug\" component={PracticeAppRoute} workspaceView=\"home\" />\n          <Route path=\"/practice/:practiceSlug/conversations\" component={PracticeAppRoute} workspaceView=\"list\" />\n          <Route path=\"/practice/:practiceSlug/conversations/:conversationId\" component={PracticeAppRoute} workspaceView=\"conversation\" />\n          <Route path=\"/practice/:practiceSlug/clients\" component={PracticeAppRoute} workspaceView=\"clients\" />\n          <Route path=\"/practice/:practiceSlug/clients/*\" component={PracticeAppRoute} workspaceView=\"clients\" />\n          <Route path=\"/practice/:practiceSlug/matters\" component={PracticeAppRoute} workspaceView=\"matters\" />\n          <Route path=\"/practice/:practiceSlug/matters/*\" component={PracticeAppRoute} workspaceView=\"matters\" />\n          <Route default component={RootRoute} />\n        </Router>\n      </Suspense>\n    </ToastProvider>\n  );\n}\n\nfunction SettingsRoute() {\n  const { defaultWorkspace } = useWorkspace();\n  const { activeOrganizationId } = useSessionContext();\n  const { navigate } = useNavigation();\n  const isClientWorkspace = defaultWorkspace === 'client';\n  const {\n    currentPractice,\n    practices,\n    loading: practicesLoading\n  } = usePracticeManagement();\n  const practiceById = (id: string | null) => practices.find((practice) => practice.id === id) ?? null;\n  const resolvedPractice =\n    practiceById(activeOrganizationId) ??\n    currentPractice ??\n    practices[0] ??\n    null;\n  const resolvedSlug = resolvedPractice?.slug ?? null;\n  const handleCloseSettings = useCallback(() => {\n    const returnPath = getSettingsReturnPath();\n    const fallback = getWorkspaceHomePath(defaultWorkspace, resolvedSlug, '/');\n    navigate(returnPath ?? fallback, true);\n  }, [defaultWorkspace, navigate, resolvedSlug]);\n\n  useEffect(() => {\n    if (!isClientWorkspace) return;\n    if (practicesLoading) return;\n    if (!resolvedSlug) {\n      navigate('/auth', true);\n      return;\n    }\n    navigate(`/client/${encodeURIComponent(resolvedSlug)}`, true);\n  }, [isClientWorkspace, navigate, practicesLoading, resolvedSlug]);\n\n  if (isClientWorkspace) {\n    if (practicesLoading) {\n      return <LoadingScreen />;\n    }\n    return (\n      <div className=\"flex h-screen flex-col items-center justify-center gap-3 text-sm text-gray-500 dark:text-gray-400\">\n        <div>Settings are available in your client portal.</div>\n        <Button\n          type=\"button\"\n          variant=\"primary\"\n          onClick={() => navigate('/auth', true)}\n        >\n          Go to sign in\n        </Button>\n      </div>\n    );\n  }\n\n  return (\n    <PracticeAppRoute\n      settingsMode={true}\n      onSettingsClose={handleCloseSettings}\n    />\n  );\n}\n\nfunction RootRoute() {\n  const { session, isPending, activeOrganizationId } = useSessionContext();\n  const {\n    defaultWorkspace,\n    canAccessPractice,\n    isPracticeLoading\n  } = useWorkspace();\n  const { navigate } = useNavigation();\n  const { currentPractice, practices, loading: practicesLoading } = usePracticeManagement();\n  const [activationError, setActivationError] = useState<string | null>(null);\n  const activationAttemptedRef = useRef(false);\n  const isMountedRef = useRef(true);\n\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    if (isPending || isPracticeLoading || practicesLoading) return;\n    if (!session?.user) return;\n    if (!canAccessPractice) return;\n    if (activeOrganizationId) return;\n    const targetPracticeId = currentPractice?.id ?? practices[0]?.id ?? null;\n    if (!targetPracticeId) return;\n    if (activationAttemptedRef.current) return;\n\n    activationAttemptedRef.current = true;\n    const client = getClient();\n    client.organization\n      .setActive({ organizationId: targetPracticeId })\n      .then(() => {\n        return getSession()\n          .catch((error) => {\n            console.error('[Workspace] Practice activated but failed to refresh session', error);\n            setActivationError('Practice activated but we could not refresh your session. Refresh the page to continue.');\n          });\n      })\n      .catch((error) => {\n        console.error('[Workspace] Failed to set active organization automatically', error);\n        setActivationError('We could not activate your practice automatically. Refresh to retry or pick a practice manually.');\n      });\n  }, [\n    canAccessPractice,\n    activeOrganizationId,\n    currentPractice?.id,\n    isPending,\n    isPracticeLoading,\n    practices,\n    practicesLoading,\n    session?.user\n  ]);\n\n  useEffect(() => {\n    if (isPending || isPracticeLoading || practicesLoading) return;\n\n    if (!session?.user) {\n      navigate('/auth', true);\n      return;\n    }\n\n    if (session.user.onboardingComplete !== true && !session.user.isAnonymous) {\n      return;\n    }\n\n    const hasPractice = Boolean(currentPractice?.id || practices.length > 0);\n    if (!canAccessPractice && !hasPractice) {\n      navigate('/pricing?returnTo=/', true);\n      return;\n    }\n\n    if (isMountedRef.current) {\n      const fallbackSlug = currentPractice?.slug ?? practices[0]?.slug ?? null;\n      const destination = getWorkspaceHomePath(defaultWorkspace, fallbackSlug, '/');\n      navigate(destination, true);\n    }\n  }, [\n    canAccessPractice,\n    defaultWorkspace,\n    isPracticeLoading,\n    practicesLoading,\n    isPending,\n    navigate,\n    activeOrganizationId,\n    session?.user,\n    currentPractice,\n    practices\n  ]);\n\n  if (activationError) {\n    return (\n      <div className=\"flex h-screen flex-col items-center justify-center gap-4 px-6 text-center text-sm text-red-300\">\n        <p className=\"text-base font-semibold text-red-200\">Activation stalled</p>\n        <p className=\"max-w-md text-red-100\">{activationError}</p>\n        <Button\n          type=\"button\"\n          variant=\"danger\"\n          onClick={() => window.location.reload()}\n        >\n          Reload and try again\n        </Button>\n      </div>\n    );\n  }\n\n  return <LoadingScreen />;\n}\n\n\nfunction PracticeAppRoute({\n  settingsMode = false,\n  onSettingsClose,\n  conversationId,\n  workspaceView = 'home',\n  practiceSlug\n}: {\n  settingsMode?: boolean;\n  onSettingsClose?: () => void;\n  conversationId?: string;\n  workspaceView?: 'home' | 'list' | 'conversation' | 'matters' | 'clients';\n  practiceSlug?: string;\n}) {\n  const { session, isPending, activeOrganizationId } = useSessionContext();\n  const { canAccessPractice, isPracticeLoading } = useWorkspace();\n  const { navigate } = useNavigation();\n  const isMobile = useMobileDetection();\n  const {\n    currentPractice,\n    practices,\n    loading: practicesLoading,\n    refetch\n  } = usePracticeManagement();\n  const normalizedPracticeSlug = (practiceSlug ?? '').trim();\n  const hasPracticeSlug = normalizedPracticeSlug.length > 0;\n  const slugPractice = hasPracticeSlug\n    ? practices.find((practice) => practice.slug === normalizedPracticeSlug)\n      ?? (currentPractice?.slug === normalizedPracticeSlug ? currentPractice : null)\n    : null;\n  const fallbackPracticeId = activeOrganizationId\n    ?? currentPractice?.id\n    ?? practices[0]?.id\n    ?? '';\n  const practiceIdCandidate = hasPracticeSlug\n    ? (slugPractice?.id ?? '')\n    : fallbackPracticeId;\n  const practiceRefreshKey = useMemo(() => {\n    if (!currentPractice) return null;\n    return [\n      currentPractice.updatedAt,\n      currentPractice.slug,\n      currentPractice.logo,\n      currentPractice.name\n    ]\n      .filter(Boolean)\n      .join('|');\n  }, [currentPractice]);\n\n  const handlePracticeError = useCallback((error: string) => {\n    console.error('Practice config error:', error);\n  }, []);\n\n  const shouldDelayPracticeConfig = practicesLoading;\n\n  const {\n    practiceConfig,\n    practiceNotFound,\n    isLoading: _isLoading\n  } = usePracticeConfig({\n    onError: handlePracticeError,\n    practiceId: shouldDelayPracticeConfig ? '' : practiceIdCandidate,\n    allowUnauthenticated: false,\n    refreshKey: practiceRefreshKey\n  });\n\n  const resolvedPracticeIdFromConfig = typeof practiceConfig.id === 'string' ? practiceConfig.id : '';\n  const resolvedPracticeId = resolvedPracticeIdFromConfig || practiceIdCandidate;\n\n  const activationTargetId = practiceIdCandidate;\n  const activationRef = useRef<string | null>(null);\n  useEffect(() => {\n    if (!activationTargetId) return;\n    if (activeOrganizationId === activationTargetId) return;\n    if (activationRef.current === activationTargetId || activationRef.current === `FAILED:${activationTargetId}`) return;\n\n    activationRef.current = activationTargetId;\n    const client = getClient();\n    client.organization\n      .setActive({ organizationId: activationTargetId })\n      .then(() => {\n        return getSession().catch(() => undefined);\n      })\n      .catch((error) => {\n        console.warn('[Workspace] Failed to set active organization', error);\n        activationRef.current = `FAILED:${activationTargetId}`;\n      });\n  }, [activationTargetId, activeOrganizationId]);\n\n  useEffect(() => {\n    if (isPending || isPracticeLoading) return;\n    if (!session?.user) return;\n    if (canAccessPractice) return;\n\n    if (normalizedPracticeSlug) {\n      navigate(`/client/${encodeURIComponent(normalizedPracticeSlug)}`, true);\n      return;\n    }\n\n    const fallbackSlug = currentPractice?.slug ?? practices[0]?.slug ?? null;\n    if (fallbackSlug) {\n      navigate(`/client/${encodeURIComponent(fallbackSlug)}`, true);\n      return;\n    }\n\n    navigate('/pricing?returnTo=/', true);\n  }, [\n    canAccessPractice,\n    currentPractice?.slug,\n    isPending,\n    isPracticeLoading,\n    navigate,\n    normalizedPracticeSlug,\n    practices,\n    session?.user\n  ]);\n\n  if (isPending || isPracticeLoading || practicesLoading || shouldDelayPracticeConfig) {\n    return <LoadingScreen />;\n  }\n\n  if (!session?.user) {\n    return <AuthPage />;\n  }\n\n  if (!canAccessPractice) {\n    return <LoadingScreen />;\n  }\n\n  if (hasPracticeSlug && !slugPractice && !practicesLoading) {\n    return (\n      <PracticeNotFound\n        practiceId={normalizedPracticeSlug}\n        onRetry={() => refetch()}\n      />\n    );\n  }\n\n  if (!resolvedPracticeId) {\n    if (practiceNotFound) {\n      return (\n        <PracticeNotFound\n          practiceId={normalizedPracticeSlug || activationTargetId || 'unknown'}\n          onRetry={() => refetch()}\n        />\n      );\n    }\n    return <LoadingScreen />;\n  }\n\n  if (settingsMode) {\n    return (\n      <SettingsPage\n        isMobile={isMobile}\n        onClose={onSettingsClose}\n        className=\"h-full\"\n      />\n    );\n  }\n\n  return (\n      <MainApp\n        practiceId={resolvedPracticeId}\n        practiceConfig={practiceConfig}\n        isPracticeView={true}\n        workspace=\"practice\"\n        routeConversationId={conversationId}\n        practiceWorkspaceView={workspaceView}\n        practiceSlug={normalizedPracticeSlug || undefined}\n      />\n  );\n}\n\nfunction ClientPracticeRoute({\n  practiceSlug,\n  conversationId,\n  workspaceView = 'home'\n}: {\n  practiceSlug?: string;\n  conversationId?: string;\n  workspaceView?: 'home' | 'list' | 'conversation' | 'matters';\n}) {\n  const location = useLocation();\n  const { session, isPending: sessionIsPending, activeMemberRole } = useSessionContext();\n  const { navigate } = useNavigation();\n  const handlePracticeError = useCallback((error: string) => {\n    console.error('Practice config error:', error);\n  }, []);\n\n  const slug = (practiceSlug ?? '').trim();\n\n  const {\n    practiceConfig,\n    practiceNotFound,\n    handleRetryPracticeConfig,\n    isLoading\n  } = usePracticeConfig({\n    onError: handlePracticeError,\n    practiceId: slug,\n    allowUnauthenticated: true\n  });\n  const resolvedPracticeId = useMemo(\n    () => (typeof practiceConfig.id === 'string' ? practiceConfig.id : ''),\n    [practiceConfig.id]\n  );\n\n  const normalizedRole = normalizePracticeRole(activeMemberRole);\n  const isAuthenticatedClient = Boolean(session?.user && !session.user.isAnonymous && normalizedRole === 'client');\n\n  useEffect(() => {\n    if (!slug || sessionIsPending) return;\n    if (isAuthenticatedClient && workspaceView === 'home') {\n      navigate(`/client/${encodeURIComponent(slug)}/conversations`, true);\n    } else if (!isAuthenticatedClient && workspaceView === 'matters') {\n      navigate(`/client/${encodeURIComponent(slug)}`, true);\n    }\n  }, [isAuthenticatedClient, workspaceView, slug, navigate, sessionIsPending, session]);\n\n  if (isLoading || sessionIsPending) {\n    return <LoadingScreen />;\n  }\n\n  if (!session?.user) {\n    return <AuthPage />;\n  }\n\n  if (practiceNotFound) {\n    return (\n      <PracticeNotFound\n        practiceId={slug || resolvedPracticeId}\n        onRetry={handleRetryPracticeConfig}\n      />\n    );\n  }\n\n  if (!resolvedPracticeId) {\n    return <LoadingScreen />;\n  }\n\n  const currentUrl = typeof window !== 'undefined'\n    ? `${window.location.origin}${location.url}`\n    : undefined;\n\n  return (\n    <>\n      <SEOHead\n        practiceConfig={practiceConfig}\n        currentUrl={currentUrl}\n      />\n      <MainApp\n        practiceId={resolvedPracticeId}\n        practiceConfig={practiceConfig}\n        isPracticeView={true}\n        workspace=\"client\"\n        clientPracticeSlug={slug || undefined}\n        routeConversationId={conversationId}\n        clientWorkspaceView={workspaceView}\n      />\n    </>\n  );\n}\n\nfunction PublicPracticeRoute({\n  practiceSlug,\n  conversationId,\n  workspaceView = 'home'\n}: {\n  practiceSlug?: string;\n  conversationId?: string;\n  workspaceView?: 'home' | 'list' | 'conversation' | 'matters';\n}) {\n  const location = useLocation();\n  const { session, isPending: sessionIsPending, activeMemberRole } = useSessionContext();\n  const { navigate } = useNavigation();\n  const handlePracticeError = useCallback((error: string) => {\n    console.error('Practice config error:', error);\n  }, []);\n\n  const slug = (practiceSlug ?? '').trim();\n\n  const {\n    practiceConfig,\n    practiceNotFound,\n    handleRetryPracticeConfig,\n    isLoading\n  } = usePracticeConfig({\n    onError: handlePracticeError,\n    practiceId: slug,\n    allowUnauthenticated: true\n  });\n  const resolvedPracticeId = useMemo(\n    () => (typeof practiceConfig.id === 'string' ? practiceConfig.id : ''),\n    [practiceConfig.id]\n  );\n\n  // Handle anonymous sign-in for widget users (clients chatting with practices)\n  // This runs immediately on mount, without waiting for practice details to load\n  useEffect(() => {\n    if (typeof window === 'undefined' || sessionIsPending) return;\n\n    // Only attempt if no session exists\n    if (!session?.user) {\n      const key = 'anonymous_signin_attempted';\n      const attemptStatus = sessionStorage.getItem(key);\n\n      // Only attempt once per browser session, or retry if previous attempt failed\n      if (!attemptStatus || attemptStatus === 'failed') {\n        sessionStorage.setItem(key, 'pending');\n        console.log('[Auth] Attempting anonymous sign-in');\n        (async () => {\n          try {\n            const client = getClient();\n            console.log('[Auth] Client obtained, checking for anonymous method...');\n\n            // Type assertion needed: Better Auth anonymous plugin types may not be fully exposed\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const signIn = client.signIn as any;\n            console.log('[Auth] signIn object:', {\n              hasSignIn: !!signIn,\n              signInKeys: signIn ? Object.keys(signIn) : null,\n              hasAnonymous: !!(signIn?.anonymous),\n              anonymousType: typeof signIn?.anonymous\n            });\n\n            const anonymousSignIn = signIn?.anonymous;\n\n            if (typeof anonymousSignIn !== 'function') {\n              console.error('[Auth] Anonymous sign-in method not available', {\n                signInKeys: signIn ? Object.keys(signIn) : null,\n                message: 'Better Auth anonymous plugin may not be configured correctly.'\n              });\n              handleError('Anonymous sign-in method not available', {\n                signInKeys: signIn ? Object.keys(signIn) : null,\n              }, { component: 'Auth', action: 'anonymous-sign-in', silent: import.meta.env.DEV });\n              sessionStorage.setItem(key, 'failed');\n              return;\n            }\n\n            console.log('[Auth] Calling anonymous sign-in...');\n            const result = await anonymousSignIn();\n\n            if (result?.error) {\n              console.error('[Auth] Anonymous sign-in failed', {\n                error: result.error,\n                message: 'The server needs to have the Better Auth anonymous plugin enabled. Check server logs for details.'\n              });\n              handleError(result.error, {}, { component: 'Auth', action: 'anonymous-sign-in', silent: import.meta.env.DEV });\n              sessionStorage.setItem(key, 'failed');\n            } else {\n              sessionStorage.setItem(key, 'success');\n              console.log('[Auth] Anonymous sign-in successful for widget user', {\n                hasData: !!result?.data\n              });\n            }\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            console.error('[Auth] Anonymous sign-in exception', {\n              error: errorMessage,\n              stack: error instanceof Error ? error.stack : undefined,\n              message: 'CRITICAL: Better Auth anonymous plugin must be configured on the API server. ' +\n                       'Check server logs and ensure anonymous() plugin is added to Better Auth config.'\n            });\n            handleError(error, {}, { component: 'Auth', action: 'anonymous-sign-in', silent: import.meta.env.DEV });\n            sessionStorage.setItem(key, 'failed');\n          }\n        })();\n      } else {\n        console.log('[Auth] Anonymous sign-in already attempted, skipping', {\n          status: sessionStorage.getItem(key)\n        });\n      }\n    }\n  }, [session?.user, sessionIsPending]);\n\n  const normalizedRole = normalizePracticeRole(activeMemberRole);\n  const isAuthenticatedClient = Boolean(session?.user && !session.user.isAnonymous && normalizedRole === 'client');\n\n  useEffect(() => {\n    if (!slug || sessionIsPending) return;\n    if (isAuthenticatedClient && workspaceView === 'home') {\n      navigate(`/public/${encodeURIComponent(slug)}/conversations`, true);\n    } else if (!isAuthenticatedClient && workspaceView === 'matters') {\n      navigate(`/public/${encodeURIComponent(slug)}`, true);\n    }\n  }, [isAuthenticatedClient, workspaceView, slug, navigate, sessionIsPending, session]);\n\n  if (isLoading) {\n    return <LoadingScreen />;\n  }\n\n  if (practiceNotFound) {\n    return (\n      <PracticeNotFound\n        practiceId={slug || resolvedPracticeId}\n        onRetry={handleRetryPracticeConfig}\n      />\n    );\n  }\n\n  if (!resolvedPracticeId) {\n    return <LoadingScreen />;\n  }\n\n  if (sessionIsPending) {\n    return <LoadingScreen />;\n  }\n\n  if (isAuthenticatedClient && workspaceView === 'home' && slug) {\n    return <LoadingScreen />;\n  }\n  if (!isAuthenticatedClient && workspaceView === 'matters' && slug) {\n    return <LoadingScreen />;\n  }\n\n  const currentUrl = typeof window !== 'undefined'\n    ? `${window.location.origin}${location.url}`\n    : undefined;\n\n  return (\n    <>\n      <SEOHead\n        practiceConfig={practiceConfig}\n        currentUrl={currentUrl}\n      />\n      <MainApp\n        practiceId={resolvedPracticeId}\n        practiceConfig={practiceConfig}\n        isPracticeView={true}\n        workspace=\"public\"\n        publicPracticeSlug={slug || undefined}\n        routeConversationId={conversationId}\n        publicWorkspaceView={workspaceView}\n      />\n    </>\n  );\n}\n\n\nconst FallbackLoader = () => (\n  <div className=\"flex h-screen items-center justify-center text-sm text-gray-500 dark:text-gray-400\">\n    Loading\n  </div>\n);\n\nfunction AppWithProviders() {\n  return (\n    <I18nextProvider i18n={i18n}>\n      <Suspense fallback={<FallbackLoader />}>\n        <App />\n      </Suspense>\n    </I18nextProvider>\n  );\n}\n\nasync function mountClientApp() {\n  const savedTheme = localStorage.getItem('theme');\n  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n  const shouldBeDark = savedTheme === 'dark' || (!savedTheme && prefersDark);\n\n  if (shouldBeDark) {\n    document.documentElement.classList.add('dark');\n  }\n\n  // Initialize default accent color before workspace/practice details load.\n  initializeAccentColor();\n\n  initI18n()\n    .then(() => {\n      hydrate(<AppWithProviders />, document.getElementById('app'));\n    })\n    .catch((_error) => {\n      console.error('Failed to initialize i18n:', _error);\n      hydrate(<AppWithProviders />, document.getElementById('app'));\n    });\n}\n\nif (typeof window !== 'undefined') {\n  mountClientApp();\n}\n\nexport async function prerender() {\n  await initI18n();\n  return await ssr(<AppWithProviders />);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/ar/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/de/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/es/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/fr/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/hi/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/id/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/it/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/ja/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/ko/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/nl/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/pl/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/pt/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/ru/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/th/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/tr/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/uk/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/vi/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/locales/zh/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/pages/AcceptInvitationPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":258,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":258,"endColumn":20,"suggestions":[{"fix":{"range":[9558,9628],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":291,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":291,"endColumn":19,"suggestions":[{"fix":{"range":[11112,11198],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":364,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":364,"endColumn":24,"suggestions":[{"fix":{"range":[14110,14268],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":376,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":376,"endColumn":24,"suggestions":[{"fix":{"range":[14556,14750],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":397,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":397,"endColumn":22,"suggestions":[{"fix":{"range":[15244,15407],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":414,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":414,"endColumn":26,"suggestions":[{"fix":{"range":[15938,16028],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":426,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":426,"endColumn":24,"suggestions":[{"fix":{"range":[16343,16475],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":431,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":431,"endColumn":24,"suggestions":[{"fix":{"range":[16503,16693],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ComponentChildren } from 'preact';\nimport { useCallback, useEffect, useMemo, useState } from 'preact/hooks';\nimport { useLocation } from 'preact-iso';\nimport { Button } from '@/shared/ui/Button';\nimport { Logo } from '@/shared/ui/Logo';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { getClient } from '@/shared/lib/authClient';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { signOut } from '@/shared/utils/auth';\nimport { linkConversationToUser } from '@/shared/lib/apiClient';\nimport AuthForm from '@/shared/components/AuthForm';\nimport { cn } from '@/shared/utils/cn';\n\ntype InvitationDetails = {\n  id: string;\n  email: string;\n  role: string | string[];\n  organizationId: string;\n  inviterId: string;\n  status: string;\n  expiresAt: string;\n  organizationName?: string;\n  organizationSlug?: string;\n  inviterName?: string;\n  inviterEmail?: string;\n};\n\ntype InviteFetchState =\n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'ready'; invitation: InvitationDetails; invitationId: string }\n  | { status: 'error'; message: string; invitationId: string | null };\n\ntype IntakeInvitePayload = {\n  email: string;\n  orgName: string;\n  orgSlug: string;\n  type: 'intake';\n  intakeId: string;\n  conversationId: string;\n};\n\ntype PrefillDetails = {\n  email: string;\n  organizationName: string;\n  organizationSlug: string;\n  intakeId?: string;\n  conversationId?: string;\n  payloadType?: string;\n};\n\ntype OrganizationSummary = {\n  id: string;\n  slug?: string | null;\n};\n\ntype PayloadParseResult = {\n  data: PrefillDetails | null;\n  error: string | null;\n};\n\nconst LoadingScreen = ({ message = 'Loading' }: { message?: string }) => (\n  <div className=\"flex h-screen items-center justify-center text-sm text-input-placeholder\">\n    {message}\n  </div>\n);\n\nconst resolveQueryValue = (value: string | string[] | undefined) => {\n  const raw = Array.isArray(value) ? value[0] : value;\n  if (typeof raw !== 'string') return '';\n  return raw.trim();\n};\n\nconst normalizeInviteResponse = (payload: unknown): InvitationDetails | null => {\n  if (!payload || typeof payload !== 'object') return null;\n  const record = payload as Record<string, unknown>;\n  const getString = (value: unknown) => (typeof value === 'string' ? value : '');\n  const roleValue = record.role;\n  const role = Array.isArray(roleValue)\n    ? roleValue.filter((item) => typeof item === 'string')\n    : typeof roleValue === 'string'\n      ? roleValue\n      : '';\n  const invitation: InvitationDetails = {\n    id: getString(record.id),\n    email: getString(record.email),\n    role,\n    organizationId: getString(record.organizationId ?? record.organization_id),\n    inviterId: getString(record.inviterId ?? record.inviter_id),\n    status: getString(record.status),\n    expiresAt: getString(record.expiresAt ?? record.expires_at),\n    organizationName: getString(record.organizationName ?? record.organization_name) || undefined,\n    organizationSlug: getString(record.organizationSlug ?? record.organization_slug) || undefined,\n    inviterName: getString(record.inviterName ?? record.inviter_name) || undefined,\n    inviterEmail: getString(record.inviterEmail ?? record.inviter_email) || undefined\n  };\n  if (!invitation.id || !invitation.organizationId) return null;\n  return invitation;\n};\n\nconst isValidDate = (d: unknown): d is string | number | Date => {\n  if (!d) return false;\n  const date = new Date(d as string | number | Date);\n  return !isNaN(date.getTime());\n};\n\nconst decodeBase64Url = (value: string): string => {\n  const normalized = value.replace(/-/g, '+').replace(/_/g, '/');\n  const padding = (4 - (normalized.length % 4)) % 4;\n  const padded = normalized + '='.repeat(padding);\n  const binary = atob(padded);\n  const bytes = Uint8Array.from(binary, (char) => char.charCodeAt(0));\n  return new TextDecoder().decode(bytes);\n};\n\nconst parsePrefillPayload = (raw: string): PayloadParseResult => {\n  if (!raw) return { data: null, error: null };\n\n  try {\n    const decoded = decodeBase64Url(raw);\n    const payload = JSON.parse(decoded) as Partial<IntakeInvitePayload> & Record<string, unknown>;\n\n    const email = typeof payload.email === 'string' ? payload.email.trim() : '';\n    const orgName = typeof payload.orgName === 'string' ? payload.orgName.trim() : '';\n    const orgSlug = typeof payload.orgSlug === 'string' ? payload.orgSlug.trim() : '';\n    const intakeId = typeof payload.intakeId === 'string' ? payload.intakeId.trim() : '';\n    const conversationId = typeof payload.conversationId === 'string' ? payload.conversationId.trim() : '';\n    const payloadType = typeof payload.type === 'string' ? payload.type.trim() : '';\n\n    if (!email || !orgName || !orgSlug) {\n      return { data: null, error: 'Invitation data is incomplete.' };\n    }\n\n    return {\n      data: {\n        email,\n        organizationName: orgName,\n        organizationSlug: orgSlug,\n        intakeId,\n        conversationId,\n        payloadType\n      },\n      error: null\n    };\n  } catch {\n    return { data: null, error: 'Invitation data is invalid.' };\n  }\n};\n\nconst buildRedirectTarget = (invitationId: string, dataParam: string) => {\n  const params = new URLSearchParams();\n  if (invitationId) params.set('invitationId', invitationId);\n  if (dataParam) params.set('data', dataParam);\n  const query = params.toString();\n  return query ? `/auth/accept-invitation?${query}` : '/auth/accept-invitation';\n};\n\nconst Card = ({ tone = 'default', children }: { tone?: 'default' | 'error'; children: ComponentChildren }) => (\n  <div className=\"min-h-screen bg-transparent px-6 py-12\">\n    <div\n      className={cn(\n        \"mx-auto max-w-xl rounded-2xl border p-6 text-sm\",\n        tone === 'error'\n          ? \"border-red-500/30 bg-red-500/5 text-red-100 backdrop-blur-xl\"\n          : \"glass-card text-input-text\"\n      )}\n    >\n      {children}\n    </div>\n  </div>\n);\n\nexport const AcceptInvitationPage = () => {\n  const location = useLocation();\n  const { navigate } = useNavigation();\n  const { session, isPending, activeOrganizationId } = useSessionContext();\n  const { showError, showSuccess } = useToastContext();\n  const [inviteState, setInviteState] = useState<InviteFetchState>({ status: 'idle' });\n  const [accepting, setAccepting] = useState(false);\n  const [recipientMismatch, setRecipientMismatch] = useState(false);\n  const [isLinkingConversation, setIsLinkingConversation] = useState(false);\n\n  const invitationId = useMemo(() => resolveQueryValue(location.query?.invitationId), [location.query?.invitationId]);\n  const dataParam = useMemo(() => resolveQueryValue(location.query?.data), [location.query?.data]);\n  const payloadResult = useMemo(() => parsePrefillPayload(dataParam), [dataParam]);\n\n  const isAuthenticated = Boolean(session?.user && !session.user.isAnonymous);\n  const redirectTarget = useMemo(() => buildRedirectTarget(invitationId, dataParam), [dataParam, invitationId]);\n\n  const flowType = invitationId ? 'invite' : dataParam ? 'intake' : 'invalid';\n  const prefill = payloadResult.data;\n  const invitedEmail = prefill?.email ?? '';\n  const organizationName = prefill?.organizationName ?? '';\n  const organizationSlug = prefill?.organizationSlug ?? '';\n  const intakeConversationId = prefill?.conversationId ?? '';\n  const payloadType = prefill?.payloadType?.toLowerCase() ?? '';\n\n  const sessionEmail = typeof session?.user?.email === 'string' ? session.user.email.trim() : '';\n  const effectiveInvitedEmail = invitedEmail || (inviteState.status === 'ready' ? inviteState.invitation.email : '');\n  const hasEmailMismatch = Boolean(\n    effectiveInvitedEmail &&\n    sessionEmail &&\n    effectiveInvitedEmail.trim().toLowerCase() !== sessionEmail.toLowerCase()\n  );\n\n  const preAuthError = useMemo(() => {\n    if (flowType === 'invalid') {\n      return payloadResult.error ?? 'This link is missing required information. Please request a new invite.';\n    }\n\n    if (flowType === 'intake') {\n      if (!prefill) {\n        return payloadResult.error ?? 'This link is missing required invitation details. Please use the latest email from your practice.';\n      }\n      if (payloadType !== 'intake') {\n        return 'Invitation data is invalid.';\n      }\n      if (!prefill.intakeId || !prefill.conversationId) {\n        return 'Invitation data is incomplete.';\n      }\n    }\n\n    return null;\n  }, [flowType, payloadResult.error, payloadType, prefill]);\n\n  const fetchInvitation = useCallback(async () => {\n    if (!invitationId) {\n      setInviteState({ status: 'error', message: 'Invitation ID is missing.', invitationId: null });\n      setRecipientMismatch(false);\n      return;\n    }\n\n    setInviteState({ status: 'loading' });\n\n    try {\n      const client = getClient();\n      const result = await (client as unknown as {\n        organization: {\n          getInvitation: (args: { query: { id: string } }) => Promise<unknown>;\n        };\n      }).organization.getInvitation({ query: { id: invitationId } });\n\n      const payload = (result && typeof result === 'object' && 'data' in result)\n        ? (result as { data?: unknown }).data\n        : result;\n\n      const invitation = normalizeInviteResponse(payload);\n      if (!invitation) {\n        setInviteState({ status: 'error', message: 'Invitation could not be loaded.', invitationId });\n        setRecipientMismatch(false);\n        return;\n      }\n\n      setInviteState({ status: 'ready', invitation, invitationId });\n      setRecipientMismatch(false);\n    } catch (error) {\n      console.error('[AcceptInvitation] Failed to fetch invitation', error);\n      const message = error instanceof Error ? error.message : 'Unable to load invitation. Please try again.';\n      const normalized = message.toLowerCase();\n      const isRecipientError = normalized.includes('recipient') || normalized.includes('you are not the recipient');\n      setRecipientMismatch(isRecipientError);\n      setInviteState({ status: 'error', message, invitationId });\n    }\n  }, [invitationId]);\n\n  useEffect(() => {\n    if (!isAuthenticated) return;\n    if (flowType !== 'invite') return;\n    if (!invitationId) return;\n    if (inviteState.status === 'loading') return;\n    const inviteStateId =\n      inviteState.status === 'ready' || inviteState.status === 'error'\n        ? inviteState.invitationId\n        : null;\n    if (inviteState.status === 'ready' && inviteStateId === invitationId) return;\n    if (inviteState.status === 'error' && inviteStateId === invitationId) return;\n    void fetchInvitation();\n  }, [fetchInvitation, flowType, invitationId, inviteState, isAuthenticated]);\n\n  const buildAuthUrl = useCallback((mode: 'signin' | 'signup') => {\n    const redirect = encodeURIComponent(redirectTarget);\n    const email = invitedEmail ? `&email=${encodeURIComponent(invitedEmail)}` : '';\n    return `/auth?mode=${mode}&redirect=${redirect}${email}`;\n  }, [invitedEmail, redirectTarget]);\n\n  const handleSwitchAccount = useCallback(async (mode: 'signin' | 'signup') => {\n    try {\n      await signOut({ skipReload: true });\n    } catch (error) {\n      console.warn('[AcceptInvitation] Failed to sign out before switching account', error);\n    }\n    navigate(buildAuthUrl(mode), true);\n  }, [buildAuthUrl, navigate]);\n\n  const handleAccept = useCallback(async () => {\n    if (inviteState.status !== 'ready') return;\n    const { invitation } = inviteState;\n    if (!invitation.organizationSlug) {\n      setInviteState({ status: 'error', message: 'Invitation is missing the organization slug.', invitationId });\n      setRecipientMismatch(false);\n      return;\n    }\n\n    setAccepting(true);\n    try {\n      const client = getClient();\n      const acceptResult = await (client as unknown as {\n        organization: {\n          acceptInvitation: (args: { invitationId: string }) => Promise<unknown>;\n          setActive: (args: { organizationId: string }) => Promise<unknown>;\n        };\n      }).organization.acceptInvitation({ invitationId: invitation.id });\n\n      if (acceptResult && typeof acceptResult === 'object' && 'error' in acceptResult) {\n        const errorMessage = (acceptResult as { error?: { message?: string } }).error?.message;\n        throw new Error(errorMessage || 'Failed to accept invitation');\n      }\n\n      await (client as unknown as {\n        organization: {\n          setActive: (args: { organizationId: string }) => Promise<unknown>;\n        };\n      }).organization.setActive({ organizationId: invitation.organizationId });\n\n      showSuccess('Invitation accepted', 'You now have access to the practice.');\n      navigate(`/public/${encodeURIComponent(invitation.organizationSlug)}`, true);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to accept invitation.';\n      showError('Invitation error', message);\n      const normalized = message.toLowerCase();\n      const isRecipientError = normalized.includes('recipient') || normalized.includes('you are not the recipient');\n      setRecipientMismatch(isRecipientError);\n      setInviteState({ status: 'error', message, invitationId });\n    } finally {\n      setAccepting(false);\n    }\n  }, [inviteState, invitationId, navigate, showError, showSuccess]);\n\n  const handleContinueIntake = useCallback(async () => {\n    if (!intakeConversationId) {\n      if (organizationSlug) {\n        navigate(`/public/${encodeURIComponent(organizationSlug)}`, true);\n      }\n      return;\n    }\n\n    setIsLinkingConversation(true);\n    try {\n      const client = getClient();\n      const previousOrgId = activeOrganizationId;\n      let targetOrgId = activeOrganizationId;\n      let didSwitch = false;\n\n      const { data: orgs } = await (client as unknown as {\n        organization: { list: () => Promise<{ data?: OrganizationSummary[] }> }\n      }).organization.list();\n      const orgList = Array.isArray(orgs) ? orgs : [];\n\n      let match: OrganizationSummary | null = null;\n      if (organizationSlug) {\n        match = orgList.find((o) => o.slug === organizationSlug || o.id === organizationSlug) ?? null;\n        if (!match) {\n          console.error('[AcceptInvitationPage] Organization slug not found', {\n            organizationSlug,\n            targetOrgId,\n            orgList\n          });\n          throw new Error('Unable to find the selected organization.');\n        }\n      } else if (targetOrgId) {\n        match = orgList.find((o) => o.id === targetOrgId) ?? null;\n        if (!match) {\n          const missingOrgId = targetOrgId;\n          targetOrgId = null;\n          console.error('[AcceptInvitationPage] Active organization missing from list', {\n            organizationSlug,\n            targetOrgId,\n            missingOrgId,\n            orgList\n          });\n          throw new Error('You do not have access to the selected organization.');\n        }\n      }\n\n      if (match) {\n        targetOrgId = match.id;\n        if (targetOrgId !== activeOrganizationId) {\n          await (client as unknown as {\n            organization: { setActive: (args: { organizationId: string }) => Promise<unknown> };\n          }).organization.setActive({ organizationId: targetOrgId });\n          didSwitch = true;\n        }\n      }\n\n      if (!targetOrgId) {\n        console.error('[AcceptInvitationPage] No active organization context available', {\n          organizationSlug,\n          targetOrgId,\n          orgList\n        });\n        throw new Error('Unable to determine your organization for this conversation.');\n      }\n\n      try {\n        await linkConversationToUser(intakeConversationId, targetOrgId);\n      } catch (linkError) {\n        if (didSwitch && previousOrgId) {\n          try {\n            await (client as unknown as {\n              organization: { setActive: (args: { organizationId: string }) => Promise<unknown> };\n            }).organization.setActive({ organizationId: previousOrgId });\n          } catch (revertError) {\n            console.error('[AcceptInvitationPage] Failed to revert active organization', revertError);\n          }\n        }\n        throw linkError;\n      }\n      \n      const matchedSlug = match && typeof match.slug === 'string' && match.slug.trim().length > 0\n        ? match.slug.trim()\n        : '';\n      const finalSlug = organizationSlug || matchedSlug;\n      if (!finalSlug) {\n        if (match) {\n          console.error('[AcceptInvitationPage] Matched organization missing slug', {\n            targetOrgId,\n            match\n          });\n        } else {\n          console.error('[AcceptInvitationPage] Missing organization slug for navigation', {\n            organizationSlug,\n            targetOrgId,\n            match,\n            orgList\n          });\n        }\n        throw new Error('Organization slug is missing. Please contact support.');\n      }\n      navigate(\n        `/public/${encodeURIComponent(finalSlug)}/conversations/${encodeURIComponent(intakeConversationId)}`,\n        true\n      );\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to link conversation.';\n      showError('Unable to open conversation', message);\n    } finally {\n      setIsLinkingConversation(false);\n    }\n  }, [activeOrganizationId, intakeConversationId, navigate, organizationSlug, showError]);\n\n  if (isPending) {\n    return <LoadingScreen />;\n  }\n\n  if (preAuthError) {\n    return (\n      <Card tone=\"error\">\n        <div className=\"flex justify-center mb-6\">\n          <Logo size=\"lg\" />\n        </div>\n        <h1 className=\"text-xl font-semibold text-input-text\">Unable to load invitation</h1>\n        <p className=\"mt-2 text-sm text-red-400\">{preAuthError}</p>\n        <div className=\"mt-4 flex flex-wrap gap-3\">\n          <Button variant=\"ghost\" onClick={() => navigate('/auth', true)}>\n            Back to sign in\n          </Button>\n        </div>\n      </Card>\n    );\n  }\n\n  if (!isAuthenticated) {\n    const inviterLabel = organizationName || 'the practice';\n    const subtitle = organizationName\n      ? `Sign up to accept ${inviterLabel}'s invitation to join Blawby.`\n      : 'Sign up to accept your invitation to join Blawby.';\n\n    return (\n      <Card>\n        <div className=\"flex justify-center mb-6\">\n          <Logo size=\"lg\" />\n        </div>\n        <div className=\"text-center\">\n          <h1 className=\"text-2xl font-semibold text-input-text\">\n            Accept your invitation to sign up{organizationName ? ` | ${organizationName}` : ''}\n          </h1>\n          <p className=\"mt-2 text-sm text-input-placeholder\">\n            {subtitle}\n          </p>\n        </div>\n        <div className=\"mt-6\">\n          <AuthForm\n            defaultMode=\"signup\"\n            initialEmail={invitedEmail}\n            showHeader={false}\n            showGoogleSignIn\n            showModeToggle\n            onSuccess={() => navigate(redirectTarget, true)}\n          />\n        </div>\n      </Card>\n    );\n  }\n\n  if (flowType === 'intake') {\n    return (\n      <Card>\n        <div className=\"flex justify-center mb-6\">\n          <Logo size=\"lg\" />\n        </div>\n        <h1 className=\"text-xl font-semibold text-input-text\">Youre signed in</h1>\n        <p className=\"mt-2 text-sm text-input-placeholder\">\n          Continue to {organizationName || organizationSlug} to finish your intake.\n        </p>\n        <div className=\"mt-4 space-y-2 text-sm text-input-placeholder\">\n          <div>\n            <span className=\"font-medium text-input-text\">Practice:</span> {organizationName || organizationSlug}\n          </div>\n          <div>\n            <span className=\"font-medium text-input-text\">Email:</span> {invitedEmail}\n          </div>\n          {sessionEmail && (\n            <div>\n              <span className=\"font-medium text-input-text\">Signed in as:</span> {sessionEmail}\n            </div>\n          )}\n        </div>\n        {hasEmailMismatch && (\n          <div className=\"mt-4 rounded-xl border border-amber-500/30 bg-amber-500/10 px-4 py-3 text-sm text-amber-200 backdrop-blur-xl\">\n            Youre signed in with a different email. Switch accounts to continue with the invited email.\n          </div>\n        )}\n        <div className=\"mt-6 flex flex-wrap gap-3\">\n          <Button\n            variant=\"primary\"\n            onClick={() => {\n              if (hasEmailMismatch) return;\n              handleContinueIntake();\n            }}\n            disabled={isLinkingConversation || hasEmailMismatch}\n            aria-disabled={isLinkingConversation || hasEmailMismatch}\n            className={hasEmailMismatch ? 'opacity-50 cursor-not-allowed' : ''}\n          >\n            {isLinkingConversation ? 'Opening conversation' : 'Continue to practice'}\n          </Button>\n          <Button variant=\"secondary\" onClick={() => handleSwitchAccount('signin')}>\n            Switch account\n          </Button>\n        </div>\n      </Card>\n    );\n  }\n\n  if (inviteState.status === 'loading' || inviteState.status === 'idle') {\n    return <LoadingScreen message=\"Loading invitation\" />;\n  }\n\n  if (inviteState.status === 'error') {\n    return (\n      <Card tone=\"error\">\n        <div className=\"flex justify-center mb-6\">\n          <Logo size=\"lg\" />\n        </div>\n        <h1 className=\"text-xl font-semibold text-input-text\">Unable to load invitation</h1>\n        <p className=\"mt-2 text-sm text-red-400\">{inviteState.message}</p>\n        <div className=\"mt-4 flex flex-wrap gap-3\">\n          <Button variant=\"secondary\" onClick={fetchInvitation}>\n            Try again\n          </Button>\n          {recipientMismatch ? (\n            <>\n              <Button variant=\"primary\" onClick={() => handleSwitchAccount('signin')}>\n                Sign in with invited email\n              </Button>\n              <Button variant=\"ghost\" onClick={() => handleSwitchAccount('signup')}>\n                Create an account\n              </Button>\n            </>\n          ) : (\n            <Button variant=\"ghost\" onClick={() => navigate('/auth', true)}>\n              Back to sign in\n            </Button>\n          )}\n        </div>\n      </Card>\n    );\n  }\n\n  const { invitation } = inviteState;\n  const roleLabel = Array.isArray(invitation.role)\n    ? (invitation.role.length > 0 ? invitation.role.join(', ') : 'client')\n    : invitation.role || 'client';\n\n  return (\n    <Card>\n      <div className=\"flex justify-center mb-6\">\n        <Logo size=\"lg\" />\n      </div>\n      <h1 className=\"text-xl font-semibold text-input-text\">Accept invitation</h1>\n      <p className=\"mt-2 text-sm text-input-placeholder\">\n        You&apos;ve been invited to join {invitation.organizationName ?? 'this practice'}.\n      </p>\n      <div className=\"mt-4 space-y-2 text-sm text-input-placeholder\">\n        {invitation.organizationSlug && (\n          <div>\n            <span className=\"font-medium text-input-text\">Practice:</span> {invitation.organizationName || invitation.organizationSlug}\n          </div>\n        )}\n        {(invitation.inviterName || invitation.inviterEmail) && (\n          <div>\n            <span className=\"font-medium text-input-text\">Invited by:</span> {invitation.inviterName ?? invitation.inviterEmail}\n          </div>\n        )}\n        <div>\n          <span className=\"font-medium text-input-text\">Role:</span> {roleLabel}\n        </div>\n        {invitation.expiresAt && (\n          <div>\n            <span className=\"font-medium text-input-text\">Expires:</span> {isValidDate(invitation.expiresAt) ? new Date(invitation.expiresAt).toLocaleString() : 'Unknown'}\n          </div>\n        )}\n        {effectiveInvitedEmail && (\n          <div>\n            <span className=\"font-medium text-input-text\">Invited email:</span> {effectiveInvitedEmail}\n          </div>\n        )}\n      </div>\n      {hasEmailMismatch && (\n        <div className=\"mt-4 rounded-xl border border-amber-500/30 bg-amber-500/10 px-4 py-3 text-sm text-amber-200 backdrop-blur-xl\">\n          Youre signed in with {sessionEmail}. Switch accounts to accept with {effectiveInvitedEmail}.\n        </div>\n      )}\n      <div className=\"mt-6 flex flex-wrap gap-3\">\n        <Button\n          variant=\"primary\"\n          onClick={handleAccept}\n          disabled={accepting || invitation.status !== 'pending' || hasEmailMismatch}\n        >\n          {accepting ? 'Accepting' : 'Accept invitation'}\n        </Button>\n        {hasEmailMismatch && (\n          <Button variant=\"secondary\" onClick={() => handleSwitchAccount('signin')}>\n            Switch account\n          </Button>\n        )}\n      </div>\n      {invitation.status !== 'pending' && (\n        <p className=\"mt-2 text-xs text-gray-500 dark:text-gray-400\">\n          This invitation is no longer pending.\n        </p>\n      )}\n    </Card>\n  );\n};\n\nexport default AcceptInvitationPage;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/pages/AuthPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/pages/AwaitingInvitePage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":38,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":38,"endColumn":17,"suggestions":[{"fix":{"range":[1439,1510],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":46,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":46,"endColumn":25,"suggestions":[{"fix":{"range":[1827,1964],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":51,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":51,"endColumn":25,"suggestions":[{"fix":{"range":[1996,2118],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":56,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":56,"endColumn":23,"suggestions":[{"fix":{"range":[2171,2348],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":64,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":64,"endColumn":19,"suggestions":[{"fix":{"range":[2437,2541],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":23,"suggestions":[{"fix":{"range":[2714,2784],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":79,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":79,"endColumn":20,"suggestions":[{"fix":{"range":[2987,3099],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":108,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":108,"endColumn":23,"suggestions":[{"fix":{"range":[3921,4003],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FunctionComponent } from 'preact';\nimport { useCallback, useEffect, useRef, useState } from 'preact/hooks';\nimport { useLocation } from 'preact-iso';\nimport { Button } from '@/shared/ui/Button';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { getPublicPracticeDetails, linkConversationToUser, triggerIntakeInvitation } from '@/shared/lib/apiClient';\n\nconst resolveQueryValue = (value?: string | string[]) => {\n  if (!value) return '';\n  return Array.isArray(value) ? value[0] : value;\n};\n\nexport const AwaitingInvitePage: FunctionComponent = () => {\n  const location = useLocation();\n  const { navigate } = useNavigation();\n  const [status, setStatus] = useState<'idle' | 'loading' | 'sent' | 'error'>('idle');\n  const [wasAlreadySent, setWasAlreadySent] = useState(false);\n  const [errorMessage, setErrorMessage] = useState('');\n  const hasRunRef = useRef(false);\n\n  const intakeUuid = resolveQueryValue(location.query?.intakeUuid);\n  const practiceSlug = resolveQueryValue(location.query?.practiceSlug);\n  const practiceName = resolveQueryValue(location.query?.practiceName);\n  const conversationId = resolveQueryValue(location.query?.conversationId);\n\n  const handleTriggerInvite = useCallback(async () => {\n    if (!intakeUuid) return;\n    setStatus('loading');\n    setErrorMessage('');\n\n    const payload = {\n      intakeUuid,\n      practiceSlug,\n      practiceName,\n      conversationId\n    };\n\n    console.info('[AwaitingInvitePage] Triggering intake invite', payload);\n    try {\n      if (conversationId && practiceSlug) {\n        try {\n          const practiceDetails = await getPublicPracticeDetails(practiceSlug);\n          const practiceId = practiceDetails?.practiceId;\n          if (practiceId) {\n            await linkConversationToUser(conversationId, practiceId);\n            console.info('[AwaitingInvitePage] Linked conversation to user', {\n              conversationId,\n              practiceId\n            });\n          } else {\n            console.warn('[AwaitingInvitePage] Missing practiceId for conversation link', {\n              practiceSlug\n            });\n          }\n        } catch (linkError) {\n          console.warn('[AwaitingInvitePage] Failed to link conversation before invite', {\n            conversationId,\n            practiceSlug,\n            error: linkError\n          });\n        }\n      }\n      const result = await triggerIntakeInvitation(intakeUuid);\n      console.info('[AwaitingInvitePage] Intake invite triggered', {\n        payload,\n        result\n      });\n      if (typeof window !== 'undefined') {\n        try {\n          window.sessionStorage.setItem(`intakeInviteSent:${intakeUuid}`, 'true');\n        } catch (e) {\n          console.warn('[AwaitingInvitePage] Failed to persist invite flag', e);\n        }\n      }\n      setWasAlreadySent(false);\n      setStatus('sent');\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to send invitation email.';\n      console.error('[AwaitingInvitePage] Failed to trigger intake invite', {\n        payload,\n        error\n      });\n      setErrorMessage(message);\n      setStatus('error');\n    }\n  }, [conversationId, intakeUuid, practiceName, practiceSlug]);\n\n  useEffect(() => {\n    if (hasRunRef.current) return;\n    hasRunRef.current = true;\n    if (!intakeUuid) {\n      setStatus('error');\n      setErrorMessage('Missing intake details. Please contact support.');\n      return;\n    }\n    if (typeof window !== 'undefined') {\n      try {\n        window.sessionStorage.removeItem('intakeAwaitingInvitePath');\n        const inviteKey = `intakeInviteSent:${intakeUuid}`;\n        const inviteAlreadySent = window.sessionStorage.getItem(inviteKey) === 'true';\n        if (inviteAlreadySent) {\n          setWasAlreadySent(true);\n          setStatus('sent');\n          return;\n        }\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.warn('[AwaitingInvitePage] Failed to handle intake awaiting path', error);\n        }\n      }\n    }\n    void handleTriggerInvite();\n  }, [handleTriggerInvite, intakeUuid]);\n\n  const heading = practiceName\n    ? `You are almost done with ${practiceName}`\n    : 'You are almost done';\n  \n  const description = wasAlreadySent\n    ? (practiceName \n        ? `A confirmation link was sent to your email. Open it to join ${practiceName} and continue your intake.`\n        : 'A confirmation link was sent to your email. Open it to continue your intake.')\n    : (practiceName\n        ? `We just sent a confirmation link to your email. Open it to join ${practiceName} and continue your intake.`\n        : 'We just sent a confirmation link to your email. Open it to continue your intake.');\n\n  return (\n    <div className=\"min-h-screen bg-transparent px-6 py-12\">\n      <div className=\"mx-auto max-w-xl glass-card p-6 text-sm text-input-text\">\n        <div className=\"flex flex-col items-center gap-4 text-center\">\n          <h1 className=\"text-xl font-semibold text-input-text\">{heading}</h1>\n          <p className=\"text-input-placeholder\">{description}</p>\n          {status === 'loading' && (\n            <p className=\"text-xs text-input-placeholder\">Sending invite</p>\n          )}\n          {status === 'error' && (\n            <p className=\"text-xs text-red-500\">{errorMessage}</p>\n          )}\n          <div className=\"flex flex-col gap-2 w-full\">\n            <Button\n              variant=\"primary\"\n              onClick={handleTriggerInvite}\n              disabled={status === 'loading'}\n            >\n              Resend confirmation email\n            </Button>\n            {practiceSlug && (\n              <Button\n                variant=\"secondary\"\n                onClick={() => navigate(`/public/${encodeURIComponent(practiceSlug)}`, true)}\n              >\n                Back to practice\n              </Button>\n            )}\n          </div>\n          <p className=\"text-xs text-input-placeholder\">\n            Once you confirm your email, you will return to your intake automatically.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default AwaitingInvitePage;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/pages/ClientHomePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/pages/DebugStylesPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/pages/OnboardingPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":45,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":45,"endColumn":21,"suggestions":[{"fix":{"range":[1660,1741],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo } from 'preact/hooks';\nimport { useLocation } from 'preact-iso';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { useWorkspace } from '@/shared/hooks/useWorkspace';\nimport { OnboardingFlow } from '@/features/onboarding/components/OnboardingFlow';\nimport { SetupShell } from '@/shared/ui/layout/SetupShell';\n\nconst LoadingScreen = () => (\n  <div className=\"flex h-screen items-center justify-center text-sm text-input-placeholder\">\n    Loading\n  </div>\n);\n\nconst resolveFallbackPath = (workspace: ReturnType<typeof useWorkspace>['defaultWorkspace']) => {\n  if (workspace === 'practice') return '/practice';\n  return '/client';\n};\n\nconst isSafeRedirectPath = (path: string | null | undefined): path is string => {\n  if (!path) return false;\n  const normalized = path.toLowerCase();\n  if (normalized.includes('\\\\') || normalized.includes('%5c')) return false;\n  if (!path.startsWith('/')) return false;\n  if (path.startsWith('//')) return false;\n  try {\n    const url = new URL(path, 'http://local.dev');\n    return url.pathname.startsWith('/');\n  } catch {\n    return false;\n  }\n};\n\nconst OnboardingPage = () => {\n  const { session, isPending, activeOrganizationId } = useSessionContext();\n  const { navigate } = useNavigation();\n  const { defaultWorkspace } = useWorkspace();\n  const location = useLocation();\n  let rawReturnTo: string | null = null;\n  if (typeof location.query?.returnTo === 'string') {\n    try {\n      rawReturnTo = decodeURIComponent(location.query.returnTo);\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.warn('Invalid returnTo value, ignoring', location.query.returnTo, error);\n      }\n      rawReturnTo = null;\n    }\n  }\n  const requestedReturnPath = isSafeRedirectPath(rawReturnTo) ? rawReturnTo : null;\n\n  const fallbackPath = useMemo(() => {\n    if (requestedReturnPath) return requestedReturnPath;\n    if (!activeOrganizationId) return '/pricing';\n    return resolveFallbackPath(defaultWorkspace);\n  }, [activeOrganizationId, defaultWorkspace, requestedReturnPath]);\n\n  const userId = session?.user?.id;\n  const userIsAnonymous = session?.user?.isAnonymous;\n  const userOnboardingComplete = session?.user?.onboardingComplete;\n\n  useEffect(() => {\n    if (isPending) return;\n    if (!userId || userIsAnonymous) {\n      navigate('/auth?mode=signup', true);\n      return;\n    }\n    if (userOnboardingComplete) {\n      navigate(fallbackPath, true);\n    }\n  }, [\n    fallbackPath,\n    isPending,\n    navigate,\n    userId,\n    userIsAnonymous,\n    userOnboardingComplete\n  ]);\n\n  const sessionUser = session?.user;\n\n  if (isPending) {\n    return <LoadingScreen />;\n  }\n\n  const user = sessionUser;\n  if (!user || user.isAnonymous) {\n    return <LoadingScreen />;\n  }\n\n  if (user.onboardingComplete) {\n    return <LoadingScreen />;\n  }\n\n  return (\n    <SetupShell>\n      <div className=\"min-h-screen bg-transparent flex flex-col\">\n        <OnboardingFlow\n          onClose={() => navigate(fallbackPath, true)}\n          onComplete={() => navigate(fallbackPath, true)}\n          active\n        />\n      </div>\n    </SetupShell>\n  );\n};\n\nexport default OnboardingPage;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/pages/PaySuccessPage.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":66,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":66,"endColumn":20,"suggestions":[{"fix":{"range":[2556,2629],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":100,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":100,"endColumn":22,"suggestions":[{"fix":{"range":[3630,3722],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":102,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":102,"endColumn":24,"suggestions":[{"fix":{"range":[3759,3833],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FunctionComponent } from 'preact';\nimport { useEffect, useRef, useState } from 'preact/hooks';\nimport { useLocation } from 'preact-iso';\nimport { apiClient, triggerIntakeInvitation } from '@/shared/lib/apiClient';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { Button } from '@/shared/ui/Button';\n\nconst resolveQueryValue = (value?: string | string[]) => {\n  if (!value) return undefined;\n  return Array.isArray(value) ? value[0] : value;\n};\n\nconst fetchPostPayStatus = async (sessionId: string): Promise<string | null> => {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), 10000);\n  try {\n    const params = new URLSearchParams({ session_id: sessionId });\n    const response = await apiClient.get(\n      `/api/practice/client-intakes/post-pay/status?${params.toString()}`,\n      { signal: controller.signal }\n    );\n    const payload = response.data as {\n      success?: boolean;\n      data?: { paid?: boolean; intake_uuid?: string };\n    } | null;\n    if (!payload?.success || !payload.data?.paid) {\n      return null;\n    }\n    return typeof payload.data.intake_uuid === 'string' ? payload.data.intake_uuid : null;\n  } catch {\n    return null;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n};\n\nexport const PaySuccessPage: FunctionComponent = () => {\n  const location = useLocation();\n  const { navigate } = useNavigation();\n  const { isAnonymous, isPending } = useSessionContext();\n  const [message, setMessage] = useState('Finalizing payment');\n  const [canRetry, setCanRetry] = useState(false);\n  const [isRetrying, setIsRetrying] = useState(false);\n  const hasRunRef = useRef(false);\n  const resolvedUuidRef = useRef<string | null>(null);\n\n  const intakeUuid = resolveQueryValue(location.query?.uuid);\n  const sessionId = resolveQueryValue(location.query?.session_id || location.query?.sessionId);\n  const rawReturnTo = resolveQueryValue(location.query?.return_to || location.query?.returnTo);\n  const returnTo = rawReturnTo && rawReturnTo.startsWith('/') && !rawReturnTo.startsWith('//')\n    ? rawReturnTo\n    : null;\n\n  const handleResend = async () => {\n    if (!resolvedUuidRef.current || isRetrying) return;\n    \n    setIsRetrying(true);\n    setCanRetry(false);\n    setMessage('Resending invitation');\n    \n    try {\n      await triggerIntakeInvitation(resolvedUuidRef.current);\n      setMessage('Payment confirmed. You can return to your conversation.');\n    } catch (error) {\n      console.error('[PayRedirect] Failed to resend intake invitation', error);\n      setMessage('Payment confirmed but invitation email failed to send.');\n      setCanRetry(true);\n    } finally {\n      setIsRetrying(false);\n    }\n  };\n\n  useEffect(() => {\n    if (hasRunRef.current) return;\n    if (isPending) return;\n    hasRunRef.current = true;\n\n    let cancelled = false;\n    const finalize = async () => {\n      let resolvedUuid = intakeUuid;\n      if (!resolvedUuid && sessionId) {\n        setMessage('Confirming payment');\n        resolvedUuid = await fetchPostPayStatus(sessionId);\n        if (cancelled) return;\n      }\n\n      if (resolvedUuid) {\n        resolvedUuidRef.current = resolvedUuid;\n        if (isAnonymous) {\n          setMessage('Payment confirmed. Please sign in to continue.');\n          return;\n        }\n        try {\n          // Attempt to trigger the invitation email\n          await triggerIntakeInvitation(resolvedUuid);\n          if (cancelled) return;\n\n          setMessage('Payment confirmed. You can return to your conversation.');\n          console.log('[PayRedirect] Payment flow complete - user should check email for magic link');\n        } catch (error) {\n          console.error('[PayRedirect] Failed to trigger intake invitation', error);\n          if (cancelled) return;\n          \n          setMessage('Payment confirmed but invitation email failed to send.');\n          setCanRetry(true);\n        }\n        // Explicit return to prevent any further navigation logic\n        return;\n      } else {\n        setMessage('Thanks for your payment. You can return to your conversation.');\n        return;\n      }\n      \n      // Removed automatic navigation logic below.\n      // The return_to parameter is used in the magic link, not here.\n    };\n\n    void finalize();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [intakeUuid, isAnonymous, isPending, sessionId]);\n\n  return (\n    <div className=\"min-h-screen bg-transparent px-6 py-12\">\n      <div className=\"mx-auto max-w-xl glass-card p-6 text-sm text-input-text\">\n        <div className=\"flex flex-col items-center gap-4 text-center\">\n          <p className=\"text-input-text\">{message}</p>\n          {canRetry && (\n            <Button\n              variant=\"secondary\"\n              onClick={handleResend}\n              disabled={isRetrying}\n            >\n              {isRetrying ? 'Resending' : 'Resend invitation'}\n            </Button>\n          )}\n          {returnTo && (\n            <Button\n              variant=\"primary\"\n              onClick={() => navigate(returnTo, true)}\n            >\n              Return to conversation\n            </Button>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PaySuccessPage;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/pages/PricingPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/AnnouncementBanner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/AuthForm.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":97,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":97,"endColumn":24,"suggestions":[{"fix":{"range":[2929,2975],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":122,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":122,"endColumn":24,"suggestions":[{"fix":{"range":[3852,3898],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":143,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":143,"endColumn":20,"suggestions":[{"fix":{"range":[4637,4671],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":197,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":197,"endColumn":22,"suggestions":[{"fix":{"range":[6293,6346],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":207,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":207,"endColumn":20,"suggestions":[{"fix":{"range":[6601,6642],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState, useCallback } from 'preact/hooks';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { UserIcon } from '@heroicons/react/24/outline';\nimport { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/shared/ui/form';\nimport { Input, EmailInput, PasswordInput } from '@/shared/ui/input';\nimport { Button } from '@/shared/ui/Button';\nimport { handleError } from '@/shared/utils/errorHandler';\nimport { getClient } from '@/shared/lib/authClient';\n\ntype AuthMode = 'signin' | 'signup';\n\ninterface AuthFormProps {\n  mode?: AuthMode;\n  defaultMode?: AuthMode;\n  initialEmail?: string;\n  signupVariant?: 'full' | 'minimal';\n  callbackURL?: string;\n  onSuccess?: (user: unknown) => void | Promise<void>;\n  onError?: (error: string) => void;\n  onModeChange?: (mode: AuthMode) => void;\n  showHeader?: boolean;\n  showGoogleSignIn?: boolean;\n  showModeToggle?: boolean;\n  className?: string;\n}\n\nconst AuthForm = ({\n  mode,\n  defaultMode = 'signin',\n  initialEmail,\n  signupVariant = 'full',\n  callbackURL,\n  onSuccess,\n  onError,\n  onModeChange,\n  showHeader = true,\n  showGoogleSignIn = true,\n  showModeToggle = true,\n  className = ''\n}: AuthFormProps) => {\n  const { t } = useTranslation('auth');\n  const [internalMode, setInternalMode] = useState<AuthMode>(mode ?? defaultMode);\n  const resolvedMode = mode ?? internalMode;\n  const isControlled = typeof mode !== 'undefined';\n  const [formData, setFormData] = useState({\n    name: '',\n    email: initialEmail ?? '',\n    password: '',\n    confirmPassword: ''\n  });\n  const [loading, setLoading] = useState(false);\n  const [message, setMessage] = useState('');\n  const [error, setError] = useState('');\n\n  useEffect(() => {\n    if (typeof initialEmail !== 'string') return;\n    setFormData((prev) => (\n      prev.email === initialEmail ? prev : { ...prev, email: initialEmail }\n    ));\n  }, [initialEmail]);\n\n  const notifySuccess = useCallback(async (user: unknown) => {\n    if (!onSuccess) return;\n\n    try {\n      await onSuccess(user);\n    } catch (callbackError) {\n      handleError(callbackError, {\n        component: 'AuthForm',\n        action: 'onSuccess-callback',\n        mode: resolvedMode\n      });\n    }\n  }, [onSuccess, resolvedMode]);\n\n  const handleSubmit = async (_data?: Record<string, unknown>) => {\n    setLoading(true);\n    setError('');\n    setMessage('');\n\n    try {\n      if (resolvedMode === 'signup') {\n        if (signupVariant === 'full' && formData.password !== formData.confirmPassword) {\n          setError(t('errors.passwordsDoNotMatch'));\n          setLoading(false);\n          return;\n        }\n\n        const client = getClient();\n        const result = await client.signUp.email({\n          email: formData.email,\n          password: formData.password,\n          name: formData.name || formData.email.split('@')[0] || t('defaults.demoUserName'),\n        });\n\n        if (result.error) {\n          console.error('Sign-up error:', result.error);\n          const signupMessage = result.error.message || '';\n          const normalized = signupMessage.toLowerCase();\n          if (normalized.includes('already') && normalized.includes('exist')) {\n            setError('An account with this email already exists. Try signing in instead.');\n          } else {\n            setError(signupMessage || t('errors.unknownError'));\n          }\n          setLoading(false);\n          if (onError) {\n            onError(signupMessage || t('errors.unknownError'));\n          }\n          return;\n        }\n\n        setMessage(t('messages.accountCreated'));\n        await notifySuccess(result.data?.user ?? null);\n      } else {\n        const client = getClient();\n        const result = await client.signIn.email({\n          email: formData.email,\n          password: formData.password,\n        });\n\n        if (result.error) {\n          console.error('Sign-in error:', result.error);\n          const signInMessage = result.error.message || '';\n          const normalized = signInMessage.toLowerCase();\n          if (normalized.includes('not found')) {\n            setError(t('errors.userNotFound'));\n          } else if (normalized.includes('invalid credentials')) {\n            setError(t('errors.invalidCredentials'));\n          } else {\n            setError(signInMessage || t('errors.invalidCredentials'));\n          }\n          setLoading(false);\n          if (onError) {\n            onError(signInMessage || t('errors.invalidCredentials'));\n          }\n          return;\n        }\n\n        setMessage(t('messages.signedIn'));\n        await notifySuccess(result.data?.user ?? null);\n      }\n    } catch (err) {\n      console.error('Auth error:', err);\n      let errorMessage = t('errors.unknownError');\n      if (err instanceof Error) {\n        if (err.message.includes('fetch')) {\n          errorMessage = 'Network error. Please check your connection and try again.';\n        } else {\n          errorMessage = err.message;\n        }\n      }\n      setError(errorMessage);\n      if (onError) {\n        onError(errorMessage);\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleGoogleSignIn = async () => {\n    setLoading(true);\n    setError('');\n    setMessage('');\n\n    try {\n      const client = getClient();\n      const currentUrl = new URL(window.location.href);\n      const redirectParam = currentUrl.searchParams.get('redirect');\n      let resolvedCallbackURL = window.location.origin;\n      if (typeof callbackURL === 'string' && callbackURL.trim().length > 0) {\n        const trimmed = callbackURL.trim();\n        try {\n          const url = new URL(trimmed, window.location.origin);\n          if (url.origin === window.location.origin) {\n            resolvedCallbackURL = url.href;\n          }\n        } catch {\n          // Fall back to origin\n        }\n      } else if (redirectParam) {\n        try {\n          const redirectUrl = new URL(redirectParam, window.location.origin);\n          if (redirectUrl.origin === window.location.origin) {\n            resolvedCallbackURL = redirectUrl.href;\n          }\n        } catch {\n          // Fall back to origin\n        }\n      }\n      const result = await client.signIn.social({\n        provider: 'google',\n        callbackURL: resolvedCallbackURL,\n      });\n\n      if (result.error) {\n        console.error('Google sign-in error:', result.error);\n        const errorMessage = result.error.message || t('errors.unknownError');\n        setError(errorMessage);\n        if (onError) {\n          onError(errorMessage);\n        }\n        setLoading(false);\n        return;\n      }\n    } catch (err) {\n      console.error('Google auth error:', err);\n      let errorMessage = t('errors.unknownError');\n      if (err instanceof Error) {\n        if (err.message.includes('fetch')) {\n          errorMessage = 'Network error. Please check your connection and try again.';\n        } else {\n          errorMessage = err.message;\n        }\n      }\n      setError(errorMessage);\n      if (onError) {\n        onError(errorMessage);\n      }\n      setLoading(false);\n    }\n  };\n\n  const handleToggleMode = () => {\n    const nextMode: AuthMode = resolvedMode === 'signup' ? 'signin' : 'signup';\n    if (!isControlled) {\n      setInternalMode(nextMode);\n    }\n    if (onModeChange) {\n      onModeChange(nextMode);\n    }\n    setError('');\n    setMessage('');\n    setFormData({ name: '', email: '', password: '', confirmPassword: '' });\n  };\n\n  return (\n    <div className={`w-full ${className}`}>\n      {showHeader && (\n        <div className=\"mb-6 text-center\">\n          <h2 className=\"text-2xl font-bold text-input-text\">\n            {resolvedMode === 'signup' ? t('signup.title') : t('signin.title')}\n          </h2>\n          <p className=\"mt-2 text-sm text-input-placeholder\">\n            {resolvedMode === 'signup' ? t('signup.subtitle') : t('signin.subtitle')}\n          </p>\n        </div>\n      )}\n\n      <div className=\"glass-card py-8 px-4 sm:px-10\">\n        {showGoogleSignIn && (\n          <div className=\"mb-6\">\n            <Button\n              type=\"button\"\n              variant=\"secondary\"\n              size=\"md\"\n              onClick={handleGoogleSignIn}\n              disabled={loading}\n              className=\"w-full justify-center\"\n              icon={\n                <svg className=\"w-5 h-5\" viewBox=\"0 0 24 24\">\n                  <path fill=\"#4285F4\" d=\"M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z\"/>\n                  <path fill=\"#34A853\" d=\"M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z\"/>\n                  <path fill=\"#FBBC05\" d=\"M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z\"/>\n                  <path fill=\"#EA4335\" d=\"M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z\"/>\n                </svg>\n              }\n              iconPosition=\"left\"\n            >\n              {t(resolvedMode === 'signup' ? 'signup.googleSignIn' : 'signin.googleSignIn')}\n            </Button>\n          </div>\n        )}\n\n        {showGoogleSignIn && (\n          <div className=\"relative mb-6\">\n            <div className=\"absolute inset-0 flex items-center\">\n              <div className=\"w-full border-t border-line-glass/30\" />\n            </div>\n            <div className=\"relative flex justify-center text-sm\">\n              <span className=\"px-2 bg-transparent text-input-placeholder font-medium backdrop-blur-sm\">{t('common.orContinueWithEmail')}</span>\n            </div>\n          </div>\n        )}\n\n        <Form onSubmit={handleSubmit}>\n          <div className=\"space-y-4\">\n            {resolvedMode === 'signup' && signupVariant === 'full' && (\n              <FormField name=\"name\">\n                {({ error: fieldError, onChange }) => (\n                  <FormItem>\n                    <FormLabel htmlFor=\"signup-fullname\">{t('signup.fullName')}</FormLabel>\n                    <FormControl>\n                      <Input\n                        id=\"signup-fullname\"\n                        type=\"text\"\n                        required={resolvedMode === 'signup'}\n                        value={formData.name}\n                        onChange={(value) => {\n                          onChange(value);\n                          setFormData(prev => ({ ...prev, name: String(value) }));\n                        }}\n                        placeholder={t('signup.fullNamePlaceholder')}\n                        icon={<UserIcon className=\"h-5 w-5 text-input-placeholder\" />}\n                        error={fieldError?.message}\n                        data-testid=\"signup-name-input\"\n                      />\n                    </FormControl>\n                    {fieldError && <FormMessage>{fieldError.message}</FormMessage>}\n                  </FormItem>\n                )}\n              </FormField>\n            )}\n\n            <FormField name=\"email\">\n              {({ error: fieldError, onChange }) => (\n                <FormItem>\n                  <FormControl>\n                    <EmailInput\n                      label={t(resolvedMode === 'signup' ? 'signup.email' : 'signin.email')}\n                      required\n                      value={formData.email}\n                      onChange={(value) => {\n                        onChange(value);\n                        setFormData(prev => ({ ...prev, email: String(value) }));\n                      }}\n                      placeholder={t(resolvedMode === 'signup' ? 'signup.emailPlaceholder' : 'signin.emailPlaceholder')}\n                      error={fieldError?.message}\n                      data-testid={resolvedMode === 'signup' ? 'signup-email-input' : 'signin-email-input'}\n                    />\n                  </FormControl>\n                  {fieldError && <FormMessage>{fieldError.message}</FormMessage>}\n                </FormItem>\n              )}\n            </FormField>\n\n            <FormField name=\"password\">\n              {({ error: fieldError, onChange }) => (\n                <FormItem>\n                  <FormControl>\n                    <PasswordInput\n                      id=\"password-field\"\n                      label={t(resolvedMode === 'signup' ? 'signup.password' : 'signin.password')}\n                      required\n                      value={formData.password}\n                      onChange={(value) => {\n                        onChange(value);\n                        setFormData(prev => ({ ...prev, password: String(value) }));\n                      }}\n                      placeholder={t(resolvedMode === 'signup' ? 'signup.passwordPlaceholder' : 'signin.passwordPlaceholder')}\n                      error={fieldError?.message}\n                      data-testid={resolvedMode === 'signup' ? 'signup-password-input' : 'signin-password-input'}\n                    />\n                  </FormControl>\n                  {fieldError && <FormMessage>{fieldError.message}</FormMessage>}\n                </FormItem>\n              )}\n            </FormField>\n\n            {resolvedMode === 'signup' && signupVariant === 'full' && (\n              <FormField name=\"confirmPassword\">\n                {({ error: fieldError, onChange }) => (\n                  <FormItem>\n                    <FormControl>\n                      <PasswordInput\n                        id=\"confirm-password-field\"\n                        label={t('signup.confirmPassword')}\n                        required={resolvedMode === 'signup'}\n                        value={formData.confirmPassword}\n                        onChange={(value) => {\n                          onChange(value);\n                          setFormData(prev => ({ ...prev, confirmPassword: String(value) }));\n                        }}\n                        placeholder={t('signup.confirmPasswordPlaceholder')}\n                        error={fieldError?.message}\n                        data-testid=\"signup-confirm-password-input\"\n                      />\n                    </FormControl>\n                    {fieldError && <FormMessage>{fieldError.message}</FormMessage>}\n                  </FormItem>\n                )}\n              </FormField>\n            )}\n          </div>\n\n          {error && (\n            <div className=\"mt-4 rounded-xl glass-panel border-red-500/20 p-3\">\n              <p className=\"text-sm text-red-400\">{error}</p>\n            </div>\n          )}\n\n          {message && (\n            <div className=\"mt-4 rounded-xl glass-panel border-emerald-500/20 p-3\">\n              <p className=\"text-sm text-emerald-400\">{message}</p>\n            </div>\n          )}\n\n          <div className=\"mt-4\">\n            <Button\n              type=\"submit\"\n              variant=\"primary\"\n              size=\"md\"\n              disabled={loading}\n              data-testid={resolvedMode === 'signup' ? 'signup-submit-button' : 'signin-submit-button'}\n              className=\"w-full justify-center\"\n              aria-busy={loading}\n              aria-label={loading\n                ? (resolvedMode === 'signup' ? t('signup.submitting') : t('signin.submitting'))\n                : undefined}\n            >\n              {loading ? (\n                <div className=\"w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin\" />\n              ) : (\n                resolvedMode === 'signup' ? t('signup.submit') : t('signin.submit')\n              )}\n            </Button>\n          </div>\n\n          {showModeToggle && (\n            <div className=\"mt-2 text-center\">\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                type=\"button\"\n                onClick={handleToggleMode}\n                disabled={loading}\n                className=\"text-accent-500 hover:text-accent-400\"\n              >\n                {resolvedMode === 'signup' \n                  ? t('signup.hasAccount', { signInLink: t('signup.signInLink') })\n                  : t('signin.noAccount', { signUpLink: t('signin.signUpLink') })}\n              </Button>\n            </div>\n          )}\n        </Form>\n      </div>\n    </div>\n  );\n};\n\nexport default AuthForm;\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/ConfirmationDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/DebugOverlay.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":32,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":32,"endColumn":20,"suggestions":[{"fix":{"range":[1163,1194],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":38,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":38,"endColumn":21,"suggestions":[{"fix":{"range":[1298,1330],"text":""},"messageId":"removeMethodCall","desc":"Remove the console method call."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":40,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":40,"endColumn":20,"suggestions":[{"fix":{"range":[1372,1403],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FunctionComponent } from 'preact';\nimport { useEffect, useState, useCallback, useRef } from 'preact/hooks';\n\nconst DEBUG_UPDATE_EVENT = 'blawby:debug-update';\nconst UPDATE_THROTTLE_MS = 1000;\nconst FALLBACK_POLL_INTERVAL_MS = 5000;\n\ninterface DebugOverlayProps {\n  isVisible?: boolean;\n}\n\ninterface ToolCall {\n  tool: string;\n  timestamp: number;\n  data: Record<string, unknown>;\n}\n\nexport const DebugOverlay: FunctionComponent<DebugOverlayProps> = ({ isVisible = false }) => {\n  const [toolCalls, setToolCalls] = useState<ToolCall[]>([]);\n  const [conversationState, setConversationState] = useState<string>('unknown');\n  const [error, setError] = useState<string | null>(null);\n  const [isExpanded, setIsExpanded] = useState<boolean>(false);\n  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);\n  const warningsRef = useRef<Record<string, boolean>>({});\n  const lastUpdateRef = useRef<number>(0);\n\n  const isDev = import.meta.env.DEV;\n  const shouldRender = isDev && isVisible;\n\n  const logMessage = useCallback((key: string, level: 'warn' | 'error' | 'debug', message: string, detail?: unknown) => {\n    if (level === 'debug') {\n      console.debug(message, detail);\n      return;\n    }\n\n    if (!warningsRef.current[key]) {\n      warningsRef.current[key] = true;\n      console[level](message, detail);\n    } else if (level === 'warn') {\n      console.debug(message, detail);\n    }\n  }, []);\n\n  const getWindowProperty = useCallback((key: string): unknown => {\n    try {\n      return (window as unknown as Record<string, unknown>)[key];\n    } catch (accessError) {\n      logMessage(`window-${key}`, 'warn', `Failed to access window.${key}`, accessError);\n      return undefined;\n    }\n  }, [logMessage]);\n\n  const validateToolCalls = useCallback((data: unknown): ToolCall[] => {\n    if (!Array.isArray(data)) {\n      logMessage('toolcalls-array', 'warn', '__toolCalls is not an array, using empty array as fallback', data);\n      return [];\n    }\n\n    return data.filter((item): item is ToolCall => {\n      if (typeof item !== 'object' || item === null) {\n        logMessage('toolcalls-item', 'warn', 'Invalid tool call item (not an object)', item);\n        return false;\n      }\n\n      const call = item as Record<string, unknown>;\n      const isValid =\n        typeof call.tool === 'string' &&\n        typeof call.timestamp === 'number' &&\n        call.data !== undefined;\n\n      if (!isValid) {\n        logMessage('toolcalls-structure', 'warn', 'Invalid tool call structure', call);\n      }\n\n      return isValid;\n    });\n  }, [logMessage]);\n\n  const validateConversationState = useCallback((data: unknown): string => {\n    if (typeof data === 'string') {\n      return data;\n    }\n\n    logMessage('conversation-state', 'warn', '__conversationState is not a string, using \"unknown\" as fallback', data);\n    return 'unknown';\n  }, [logMessage]);\n\n  const updateToolCalls = useCallback((): boolean => {\n    try {\n      const rawCalls = getWindowProperty('__toolCalls');\n      const validatedCalls = validateToolCalls(rawCalls);\n      setToolCalls(validatedCalls);\n      return true;\n    } catch (toolError) {\n      logMessage('toolcalls-error', 'error', 'Error updating tool calls', toolError);\n      const message = toolError instanceof Error ? toolError.message : 'Unknown error';\n      setError(`Tool calls error: ${message}`);\n      setToolCalls([]);\n      return false;\n    }\n  }, [getWindowProperty, validateToolCalls, logMessage]);\n\n  const updateConversationState = useCallback((): boolean => {\n    try {\n      const rawState = getWindowProperty('__conversationState');\n      const validatedState = validateConversationState(rawState);\n      setConversationState(validatedState);\n      return true;\n    } catch (stateError) {\n      logMessage('conversation-error', 'error', 'Error updating conversation state', stateError);\n      const message = stateError instanceof Error ? stateError.message : 'Unknown error';\n      setError(`Conversation state error: ${message}`);\n      setConversationState('unknown');\n      return false;\n    }\n  }, [getWindowProperty, validateConversationState, logMessage]);\n\n  const updateFromGlobals = useCallback((force = false) => {\n    if (!shouldRender) {\n      return;\n    }\n\n    const now = Date.now();\n    if (!force && now - lastUpdateRef.current < UPDATE_THROTTLE_MS) {\n      return;\n    }\n\n    lastUpdateRef.current = now;\n\n    const toolCallsSuccess = updateToolCalls();\n    const conversationStateSuccess = updateConversationState();\n\n    if (toolCallsSuccess && conversationStateSuccess) {\n      setError(null);\n      setLastUpdated(new Date());\n    }\n  }, [shouldRender, updateToolCalls, updateConversationState]);\n\n  useEffect(() => {\n    if (!shouldRender || typeof window === 'undefined') {\n      return;\n    }\n\n    updateFromGlobals(true);\n\n    const handleDebugUpdate = () => updateFromGlobals(false);\n    window.addEventListener(DEBUG_UPDATE_EVENT, handleDebugUpdate);\n\n    const fallbackInterval = window.setInterval(handleDebugUpdate, FALLBACK_POLL_INTERVAL_MS);\n\n    return () => {\n      window.removeEventListener(DEBUG_UPDATE_EVENT, handleDebugUpdate);\n      window.clearInterval(fallbackInterval);\n    };\n  }, [shouldRender, updateFromGlobals]);\n\n  // Keyboard navigation handler\n  const handleKeyDown = useCallback((event: KeyboardEvent) => {\n    // Don't interfere with typing in input fields\n    const target = event.target as HTMLElement;\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.contentEditable === 'true') {\n      return;\n    }\n\n    if (event.key === 'Escape') {\n      setIsExpanded(false);\n    } else if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault();\n      setIsExpanded(!isExpanded);\n    }\n  }, [isExpanded]);\n\n  // Add keyboard event listener when visible\n  useEffect(() => {\n    if (!shouldRender) return;\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [shouldRender, handleKeyDown]);\n\n  if (!shouldRender) return null;\n\n  return (\n    <div \n      className=\"fixed top-4 left-4 bg-black bg-opacity-80 text-white p-4 rounded-lg text-xs font-mono max-w-sm z-50\" \n      data-testid=\"debug-overlay\"\n      role=\"region\"\n      aria-label=\"Debug information overlay\"\n      aria-live=\"polite\"\n    >\n      <div className=\"mb-2 flex justify-between items-center\">\n        <strong>Debug Overlay</strong>\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-white hover:text-gray-300 focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-50 rounded px-1\"\n          aria-label={isExpanded ? 'Collapse debug overlay' : 'Expand debug overlay'}\n          aria-expanded={isExpanded}\n        >\n          {isExpanded ? '' : '+'}\n        </button>\n      </div>\n      \n      {error && (\n        <div className=\"mb-2 p-2 bg-red-600 bg-opacity-50 rounded border border-red-400\" role=\"alert\" aria-live=\"assertive\">\n          <div className=\"text-red-200 font-semibold\">Error:</div>\n          <div className=\"text-red-100 text-xs\">{error}</div>\n        </div>\n      )}\n      \n      <div className=\"mb-2\">\n        <div><strong>Conversation State:</strong> <span aria-label={`Current conversation state is ${conversationState}`}>{conversationState}</span></div>\n      </div>\n      \n      <div className=\"mb-2\">\n        <div><strong>Tool Calls ({toolCalls.length}):</strong></div>\n        {toolCalls.length === 0 ? (\n          <div className=\"text-gray-400\" aria-label=\"No tool calls have been detected\">No tool calls detected</div>\n        ) : (\n          <div className=\"max-h-32 overflow-y-auto\" role=\"list\" aria-label=\"List of tool calls\">\n            {toolCalls.map((call, index) => (\n              <div \n                key={index} \n                className=\"text-green-400\" \n                role=\"listitem\"\n                aria-label={`Tool call ${index + 1}: ${call.tool} at ${new Date(call.timestamp).toLocaleTimeString()}`}\n              >\n                {call.tool} ({new Date(call.timestamp).toLocaleTimeString()})\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n      \n      <div className=\"text-xs text-gray-400\" aria-label={lastUpdated ? `Last updated at ${lastUpdated.toLocaleTimeString()}` : 'No successful updates yet'}>\n        Last updated: {lastUpdated ? lastUpdated.toLocaleTimeString() : 'Never'}\n      </div>\n      \n      {isExpanded && (\n        <div className=\"mt-2 pt-2 border-t border-gray-600\" role=\"region\" aria-label=\"Additional debug information\">\n          <div className=\"text-xs text-gray-300\">\n            <div>Press <kbd className=\"bg-gray-700 px-1 rounded\">Esc</kbd> to collapse</div>\n            <div>Press <kbd className=\"bg-gray-700 px-1 rounded\">Enter</kbd> or <kbd className=\"bg-gray-700 px-1 rounded\">Space</kbd> to toggle</div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/LeftSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/LoadingIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/MobileTopNav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/Modal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/PlaceholderPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/Toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/ToastContainer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/components/UserProfile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/contexts/SessionContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/contexts/ToastContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/forms/SmartForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/forms/configs/client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/forms/configs/intake.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/forms/configs/practice.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/forms/fieldRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/__tests__/usePracticeManagement.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useActivity.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":171,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":171,"endColumn":22,"suggestions":[{"fix":{"range":[5456,5500],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'preact/hooks';\nimport { features } from '@/config/features';\n\nexport interface ActivityEvent {\n  id: string;\n  uid: string;\n  type: 'matter_event' | 'conversation_event';\n  eventType: string;\n  title: string;\n  description: string;\n  eventDate: string;\n  actorType?: 'user' | 'lawyer' | 'system';\n  actorId?: string;\n  metadata?: Record<string, unknown>;\n  createdAt: string;\n}\n\nexport interface UseActivityOptions {\n  matterId?: string;\n  conversationId?: string;\n  practiceId?: string;\n  limit?: number; // default 25, max 50\n  since?: string; // ISO 8601 timestamp\n  until?: string; // ISO 8601 timestamp\n  type?: string[]; // event types to filter by\n  actorType?: 'user' | 'lawyer' | 'system';\n  enablePagination?: boolean; // default true\n}\n\nexport interface UseActivityResult {\n  events: ActivityEvent[];\n  loading: boolean;\n  error: string | null;\n  hasMore: boolean;\n  total?: number;\n  refresh: () => Promise<void>;\n  loadMore: () => Promise<void>; // Load next page using cursor\n  reset: () => void; // Reset to first page\n  // Caching support\n  etag?: string;\n  lastModified?: string;\n}\n\nexport function useActivity(options: UseActivityOptions): UseActivityResult {\n  const {\n    matterId,\n    conversationId,\n    practiceId,\n    limit = 25,\n    since,\n    until,\n    type,\n    actorType\n  } = options;\n\n  const [events, setEvents] = useState<ActivityEvent[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [hasMore, setHasMore] = useState(false);\n  const [total, setTotal] = useState<number | undefined>();\n  const [etag, setEtag] = useState<string | undefined>();\n  const [lastModified, setLastModified] = useState<string | undefined>();\n  \n  const nextCursorRef = useRef<string | undefined>();\n  const enabled = features.enableActivity;\n\n  const buildQueryParams = useCallback(() => {\n    const params = new URLSearchParams();\n    \n    if (practiceId) params.set('practiceId', practiceId);\n    if (matterId) params.set('matterId', matterId);\n    if (conversationId) params.set('conversationId', conversationId);\n    if (limit) params.set('limit', limit.toString());\n    if (since) params.set('since', since);\n    if (until) params.set('until', until);\n    if (type && type.length > 0) params.set('type', type.join(','));\n    if (actorType) params.set('actorType', actorType);\n    if (nextCursorRef.current) params.set('cursor', nextCursorRef.current);\n    \n    return params.toString();\n  }, [practiceId, matterId, conversationId, limit, since, until, type, actorType]);\n\n  const fetchActivity = useCallback(async (isLoadMore = false) => {\n    if (!enabled) {\n      // Feature-flagged off: Activity is not yet migrated to staging-api.\n      // TODO(activity): switch to staging-api endpoint and remove this guard.\n      return;\n    }\n    if (!practiceId) {\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const queryParams = buildQueryParams();\n      const url = `/api/activity?${queryParams}`;\n      \n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json'\n      };\n      \n      // Add conditional request headers for caching\n      if (etag && !isLoadMore) {\n        headers['If-None-Match'] = etag;\n      }\n      if (lastModified && !isLoadMore) {\n        headers['If-Modified-Since'] = lastModified;\n      }\n\n      const response = await fetch(url, {\n        method: 'GET',\n        headers,\n        credentials: 'include' // Include cookies for session authentication\n      });\n\n      // Handle 304 Not Modified\n      if (response.status === 304) {\n        setLoading(false);\n        return;\n      }\n\n      // Handle rate limiting\n      if (response.status === 429) {\n        const errorData = await response.json() as { retryAfter?: number; error?: string };\n        const retryAfter = errorData.retryAfter || 60;\n        setError(`Rate limit exceeded. Please try again in ${retryAfter} seconds.`);\n        setLoading(false);\n        return;\n      }\n\n      if (!response.ok) {\n        const errorData = await response.json() as { error?: string };\n        throw new Error(errorData.error || `HTTP ${response.status}`);\n      }\n\n      const data = await response.json() as { success: boolean; error?: string; data: { items: ActivityEvent[]; hasMore: boolean; total?: number; nextCursor?: string } };\n      \n      if (!data.success) {\n        throw new Error(data.error || 'Failed to fetch activity');\n      }\n\n      const result = data.data;\n      \n      // Update cache headers\n      const newEtag = response.headers.get('ETag');\n      const newLastModified = response.headers.get('Last-Modified');\n      \n      if (newEtag) setEtag(newEtag);\n      if (newLastModified) setLastModified(newLastModified);\n\n      if (isLoadMore) {\n        // Append new events for pagination\n        setEvents(prev => [...prev, ...result.items]);\n      } else {\n        // Replace events for refresh\n        setEvents(result.items);\n      }\n      \n      setHasMore(result.hasMore);\n      setTotal(result.total);\n      nextCursorRef.current = result.nextCursor;\n\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch activity';\n      setError(errorMessage);\n      // Log error for debugging in development\n      if (typeof window !== 'undefined' && window.location.hostname === 'localhost') {\n         \n        console.error('Activity fetch error:', err);\n      }\n    } finally {\n      setLoading(false);\n    }\n  }, [enabled, practiceId, buildQueryParams, etag, lastModified]);\n\n  const refresh = useCallback(async () => {\n    nextCursorRef.current = undefined;\n    await fetchActivity(false);\n  }, [fetchActivity]);\n\n  const loadMore = useCallback(async () => {\n    if (hasMore && !loading && nextCursorRef.current) {\n      await fetchActivity(true);\n    }\n  }, [hasMore, loading, fetchActivity]);\n\n  const reset = useCallback(() => {\n    setEvents([]);\n    setError(null);\n    setHasMore(false);\n    setTotal(undefined);\n    nextCursorRef.current = undefined;\n    setEtag(undefined);\n    setLastModified(undefined);\n  }, []);\n\n  // Initial load\n  useEffect(() => {\n    if (enabled && practiceId) {\n      refresh();\n    }\n  }, [enabled, practiceId, refresh]);\n\n  return {\n    events,\n    loading,\n    error,\n    hasMore,\n    total,\n    refresh,\n    loadMore,\n    reset,\n    etag,\n    lastModified\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useChatScroll.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useChatSession.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":19,"suggestions":[{"fix":{"range":[1947,2013],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":76,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":76,"endColumn":19,"suggestions":[{"fix":{"range":[2445,2512],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":19,"suggestions":[{"fix":{"range":[5073,5131],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'preact/hooks';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { getSessionsEndpoint } from '@/config/api';\n\nconst STORAGE_PREFIX = 'session:';\n\ninterface SessionResponsePayload {\n  sessionId: string;\n  sessionToken?: string | null;\n  state?: string;\n  lastActive?: string;\n  expiresAt?: string;\n}\n\nexport interface ChatSessionState {\n  sessionId: string | null;\n  sessionToken: string | null;\n  isInitializing: boolean;\n  error: string | null;\n  refreshSession: () => Promise<SessionResponsePayload | void>;\n  clearStoredSession: () => void;\n}\n\nexport function useChatSessionWithContext(): ChatSessionState {\n  const { activePracticeId } = useSessionContext();\n  return useChatSession(activePracticeId);\n}\n\n/**\n * Legacy hook that requires practiceId parameter\n * @deprecated Use useChatSessionWithContext() instead\n */\nexport function useChatSession(practiceId?: string | null): ChatSessionState {\n  const [sessionId, setSessionId] = useState<string | null>(null);\n  const [sessionToken, setSessionToken] = useState<string | null>(null);\n  const [isInitializing, setIsInitializing] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const isDisposedRef = useRef(false);\n  const handshakePracticeRef = useRef<{ practiceId: string | null; promise: Promise<SessionResponsePayload | void> } | null>(null);\n\n  useEffect(() => {\n    return () => {\n      isDisposedRef.current = true;\n    };\n  }, []);\n\n  const getStorageKey = useCallback(() => {\n    if (!practiceId) return null;\n    \n    return `${STORAGE_PREFIX}${practiceId}`;\n  }, [practiceId]);\n\n  const readStoredSessionId = useCallback(() => {\n    if (typeof window === 'undefined') return null;\n    const storageKey = getStorageKey();\n    if (!storageKey) return null;\n    try {\n      return window.localStorage.getItem(storageKey);\n    } catch (storageError) {\n      console.warn('Failed to read session from storage', storageError);\n      return null;\n    }\n  }, [getStorageKey]);\n\n  const writeStoredSessionId = useCallback((value: string | null) => {\n    if (typeof window === 'undefined') return;\n    const storageKey = getStorageKey();\n    if (!storageKey) return;\n    try {\n      if (value) {\n        window.localStorage.setItem(storageKey, value);\n      } else {\n        window.localStorage.removeItem(storageKey);\n      }\n    } catch (storageError) {\n      console.warn('Failed to persist session to storage', storageError);\n    }\n  }, [getStorageKey]);\n\n  const clearStoredSession = useCallback(() => {\n    writeStoredSessionId(null);\n    if (!isDisposedRef.current) {\n      setSessionId(null);\n      setSessionToken(null);\n    }\n  }, [writeStoredSessionId]);\n\n  const performHandshake = useCallback(async (): Promise<SessionResponsePayload | void> => {\n    if (!practiceId) {\n      return;\n    }\n\n    // Prevent multiple simultaneous handshakes for the same practice\n    if (handshakePracticeRef.current && handshakePracticeRef.current.practiceId === practiceId) {\n      return handshakePracticeRef.current.promise;\n    }\n\n    // Create the handshake promise and store it with the practice ID\n    const handshakePromise = (async (): Promise<SessionResponsePayload | void> => {\n      const storedSessionId = readStoredSessionId();\n      const body: Record<string, unknown> = { practiceId };\n      if (storedSessionId) {\n        body.sessionId = storedSessionId;\n      }\n\n      if (!isDisposedRef.current) {\n        setIsInitializing(true);\n      }\n\n    try {\n      const response = await fetch(getSessionsEndpoint(), {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        credentials: 'include',\n        body: JSON.stringify(body)\n      });\n\n      if (!response.ok) {\n        throw new Error(`Session initialization failed (${response.status})`);\n      }\n\n      const json = await response.json() as { success?: boolean; error?: string; data?: SessionResponsePayload };\n      if (!json?.success) {\n        throw new Error(json?.error || 'Session initialization failed');\n      }\n\n      const data = json.data;\n      if (!data || typeof data.sessionId !== 'string' || !data.sessionId) {\n        throw new Error('Session ID missing from response');\n      }\n\n      writeStoredSessionId(data.sessionId);\n\n      // Only update state if this handshake is still for the current practice\n      if (!isDisposedRef.current && handshakePracticeRef.current?.practiceId === practiceId) {\n        setSessionId(data.sessionId);\n        setSessionToken(typeof data.sessionToken === 'string' ? data.sessionToken : null);\n        setError(null);\n      }\n\n      return data;\n    } catch (handshakeError) {\n      const message = handshakeError instanceof Error\n        ? handshakeError.message\n        : 'Unknown session error';\n      // Only update error state if this handshake is still for the current practice\n      if (!isDisposedRef.current && handshakePracticeRef.current?.practiceId === practiceId) {\n        setError(message);\n      }\n      console.warn('Session handshake failed:', handshakeError);\n      throw handshakeError;\n    } finally {\n      // Only clear handshake state if this handshake is still for the current practice\n      if (handshakePracticeRef.current?.practiceId === practiceId) {\n        handshakePracticeRef.current = null;\n        // Only clear isInitializing if this handshake is still the active one\n        if (!isDisposedRef.current) {\n          setIsInitializing(false);\n        }\n      }\n    }\n    })();\n\n    // Store the promise with the practice ID\n    handshakePracticeRef.current = { practiceId, promise: handshakePromise };\n    \n    return handshakePromise;\n  }, [practiceId, readStoredSessionId, writeStoredSessionId]);\n\n  useEffect(() => {\n    if (!practiceId) {\n      clearStoredSession();\n      handshakePracticeRef.current = null;\n      if (!isDisposedRef.current) {\n        setIsInitializing(false);\n      }\n      return;\n    }\n\n    let cancelled = false;\n    (async () => {\n      try {\n        await performHandshake();\n      } catch {\n        if (cancelled) return;\n        // Error state already handled inside performHandshake\n      }\n    })();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [practiceId, clearStoredSession, performHandshake]); // Only re-run when practiceId actually changes\n\n  return {\n    sessionId,\n    sessionToken,\n    isInitializing,\n    error,\n    refreshSession: performHandshake,\n    clearStoredSession\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useConversation.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":302,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":302,"endColumn":21,"suggestions":[{"fix":{"range":[10411,10472],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":644,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":644,"endColumn":27,"suggestions":[{"fix":{"range":[21549,21605],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":671,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":671,"endColumn":29,"suggestions":[{"fix":{"range":[22627,22678],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":717,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":717,"endColumn":21,"suggestions":[{"fix":{"range":[24024,24100],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":724,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":724,"endColumn":21,"suggestions":[{"fix":{"range":[24232,24282],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'preact/hooks';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { getConversationMessagesEndpoint, getCurrentConversationEndpoint, getConversationEndpoint, getConversationWsEndpoint } from '@/config/api';\nimport type { Conversation, ConversationMessage, ConversationMessageUI } from '@/shared/types/conversation';\n\ninterface UseConversationOptions {\n  conversationId: string;\n  practiceId?: string;\n  onError?: (error: string) => void;\n}\n\ninterface UseConversationReturn {\n  conversation: Conversation | null;\n  messages: ConversationMessageUI[];\n  isLoading: boolean;\n  isLoadingMore: boolean;\n  error: string | null;\n  sendMessage: (content: string, attachments?: string[]) => Promise<void>;\n  loadMore: () => Promise<void>;\n  refresh: () => Promise<void>;\n  hasMore: boolean;\n  nextCursor: string | null;\n}\n\nconst CHAT_PROTOCOL_VERSION = 1;\nconst SOCKET_READY_TIMEOUT_MS = 8000;\nconst GAP_FETCH_LIMIT = 50;\nconst MAX_GAP_FETCH_ATTEMPTS = 3;\nconst GAP_FETCH_RETRY_DELAY_MS = 1000;\nconst RECONNECT_BASE_DELAY_MS = 800;\nconst RECONNECT_MAX_DELAY_MS = 12000;\nconst RECONNECT_MAX_ATTEMPTS = 5;\n\nconst createClientId = (): string => {\n  if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {\n    return crypto.randomUUID();\n  }\n  return `client-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n};\n\n/**\n * Hook for managing a single conversation\n * Fetches conversation details and messages, uses WebSocket for realtime updates\n */\nexport function useConversationWithContext(options: Omit<UseConversationOptions, 'practiceId'>): UseConversationReturn {\n  const { activePracticeId } = useSessionContext();\n  return useConversation({ ...options, practiceId: activePracticeId ?? undefined });\n}\n\n/**\n * Hook for getting or creating current conversation for a practice\n * Automatically fetches the current conversation (or creates one) and returns conversation data\n * Note: The API endpoint automatically creates a conversation if one doesn't exist\n */\nexport function useCurrentConversation(\n  practiceId: string | undefined,\n  options?: { onError?: (error: string) => void }\n): UseConversationReturn & { conversationId: string | null } {\n  const [conversationId, setConversationId] = useState<string | null>(null);\n  const [isLoadingCurrent, setIsLoadingCurrent] = useState<boolean>(true);\n  const [errorCurrent, setErrorCurrent] = useState<string | null>(null);\n  const onErrorRef = useRef(options?.onError);\n  \n  // Keep onError ref in sync\n  useEffect(() => {\n    onErrorRef.current = options?.onError;\n  }, [options?.onError]);\n  \n  // Fetch current conversation\n  useEffect(() => {\n    if (!practiceId) {\n      setIsLoadingCurrent(false);\n      return;\n    }\n    \n    const fetchCurrent = async () => {\n      setIsLoadingCurrent(true);\n      setErrorCurrent(null);\n      \n      try {\n        const headers: Record<string, string> = { 'Content-Type': 'application/json' };\n\n        const params = new URLSearchParams({ practiceId });\n        const response = await fetch(\n          `${getCurrentConversationEndpoint()}?${params.toString()}`,\n          {\n            method: 'GET',\n            headers,\n            credentials: 'include',\n          }\n        );\n        \n        if (!response.ok) {\n          const errorData = await response.json().catch(() => ({})) as { error?: string };\n          throw new Error(errorData.error || `HTTP ${response.status}`);\n        }\n        \n        const data = await response.json() as { \n          success: boolean; \n          error?: string; \n          data?: { conversation: Conversation } \n        };\n        \n        if (!data.success || !data.data?.conversation) {\n          throw new Error(data.error || 'Failed to get current conversation');\n        }\n        \n        setConversationId(data.data.conversation.id);\n        setErrorCurrent(null);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to get conversation';\n        setErrorCurrent(errorMessage);\n        onErrorRef.current?.(errorMessage);\n      } finally {\n        setIsLoadingCurrent(false);\n      }\n    };\n    \n    fetchCurrent();\n  }, [practiceId]); // Only depend on practiceId to avoid infinite re-renders\n  \n  // Use existing useConversation hook with the conversationId\n  const conversationHook = useConversation({ \n    conversationId: conversationId || '', \n    practiceId,\n    onError: options?.onError \n  });\n  \n  // Combine loading states\n  const isLoading = isLoadingCurrent || (conversationId ? conversationHook.isLoading : false);\n  const error = errorCurrent || conversationHook.error;\n  \n  return {\n    conversation: conversationHook.conversation,\n    messages: conversationHook.messages,\n    isLoading,\n    isLoadingMore: conversationHook.isLoadingMore,\n    error,\n    sendMessage: conversationHook.sendMessage,\n    loadMore: conversationHook.loadMore,\n    refresh: conversationHook.refresh,\n    hasMore: conversationHook.hasMore,\n    nextCursor: conversationHook.nextCursor,\n    conversationId,\n  };\n}\n\n/**\n * Legacy hook that requires practiceId parameter\n * @deprecated Use useConversationWithContext() instead\n */\nexport function useConversation({\n  conversationId,\n  practiceId,\n  onError,\n}: UseConversationOptions): UseConversationReturn {\n  const { session } = useSessionContext();\n  const sessionReady = session !== null;\n  const [conversation, setConversation] = useState<Conversation | null>(null);\n  const [messages, setMessages] = useState<ConversationMessageUI[]>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [isLoadingMore, setIsLoadingMore] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const [hasMore, setHasMore] = useState<boolean>(false);\n  const [nextCursor, setNextCursor] = useState<string | null>(null);\n  const currentUserId = session?.user?.id ?? null;\n\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const isDisposedRef = useRef(false);\n  const wsRef = useRef<WebSocket | null>(null);\n  const wsReadyRef = useRef<Promise<void> | null>(null);\n  const wsReadyResolveRef = useRef<(() => void) | null>(null);\n  const wsReadyRejectRef = useRef<((error: Error) => void) | null>(null);\n  const socketSessionRef = useRef(0);\n  const isSocketReadyRef = useRef(false);\n  const lastSeqRef = useRef(0);\n  const lastReadSeqRef = useRef(0);\n  const messageIdSetRef = useRef(new Set<string>());\n  const pendingAckRef = useRef(new Map<string, {\n    resolve: (ack: { messageId: string; seq: number; serverTs: string; clientId: string }) => void;\n    reject: (error: Error) => void;\n    timeoutId: ReturnType<typeof setTimeout>;\n  }>());\n  const pendingClientMessageRef = useRef(new Map<string, string>());\n  const connectChatRoomRef = useRef<() => void>(() => {});\n  const reconnectAttemptRef = useRef(0);\n  const reconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const isClosingSocketRef = useRef(false);\n\n  // Convert API message to UI message\n  const toUIMessage = useCallback((msg: ConversationMessage): ConversationMessageUI => {\n    const senderId = typeof msg.user_id === 'string' && msg.user_id.trim().length > 0\n      ? msg.user_id\n      : null;\n    const isUser = msg.role === 'user'\n      && Boolean(senderId && currentUserId && senderId === currentUserId);\n\n    return {\n      ...msg,\n      isUser,\n      timestamp: new Date(msg.created_at).getTime(),\n      files: msg.metadata?.attachments ? (msg.metadata.attachments as string[]).map((fileId: string) => ({\n        id: fileId,\n        name: 'File',\n        size: 0,\n        type: 'application/octet-stream',\n        url: '', // TODO: Generate file URL from file ID\n      })) : undefined,\n    };\n  }, [currentUserId]);\n\n  const initSocketReadyPromise = useCallback(() => {\n    wsReadyRef.current = new Promise((resolve, reject) => {\n      wsReadyResolveRef.current = resolve;\n      wsReadyRejectRef.current = reject;\n    });\n    isSocketReadyRef.current = false;\n  }, []);\n\n  const resolveSocketReady = useCallback(() => {\n    isSocketReadyRef.current = true;\n    wsReadyResolveRef.current?.();\n    wsReadyResolveRef.current = null;\n    wsReadyRejectRef.current = null;\n  }, []);\n\n  const rejectSocketReady = useCallback((error: Error) => {\n    isSocketReadyRef.current = false;\n    wsReadyRejectRef.current?.(error);\n    wsReadyResolveRef.current = null;\n    wsReadyRejectRef.current = null;\n  }, []);\n\n  const flushPendingAcks = useCallback((error: Error) => {\n    for (const pending of pendingAckRef.current.values()) {\n      clearTimeout(pending.timeoutId);\n      pending.reject(error);\n    }\n    pendingAckRef.current.clear();\n  }, []);\n\n  useEffect(() => {\n    return () => {\n      isDisposedRef.current = true;\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      flushPendingAcks(new Error('Chat connection closed'));\n      if (wsRef.current) {\n        wsRef.current.close();\n        wsRef.current = null;\n      }\n    };\n  }, [flushPendingAcks]);\n\n  const waitForSocketReady = useCallback(async () => {\n    if (!wsReadyRef.current) {\n      throw new Error('Chat connection not initialized');\n    }\n    let timeoutId: ReturnType<typeof setTimeout> | null = null;\n    const timeoutPromise = new Promise<void>((_resolve, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(new Error('Chat connection timed out'));\n      }, SOCKET_READY_TIMEOUT_MS);\n    });\n\n    try {\n      await Promise.race([wsReadyRef.current, timeoutPromise]);\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }, []);\n\n  const sendFrame = useCallback((frame: { type: string; data: Record<string, unknown>; request_id?: string }) => {\n    const ws = wsRef.current;\n    if (!ws || ws.readyState !== WebSocket.OPEN) {\n      throw new Error('Chat connection not open');\n    }\n    ws.send(JSON.stringify(frame));\n  }, []);\n\n  const sendReadUpdate = useCallback((seq: number) => {\n    if (!conversationId || !isSocketReadyRef.current) {\n      return;\n    }\n    if (seq <= lastReadSeqRef.current) {\n      return;\n    }\n    lastReadSeqRef.current = seq;\n    try {\n      sendFrame({\n        type: 'read.update',\n        data: {\n          conversation_id: conversationId,\n          last_read_seq: seq\n        }\n      });\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.warn('[ChatRoom] Failed to send read.update', error);\n      }\n    }\n  }, [conversationId, sendFrame]);\n\n  const applyServerMessages = useCallback((incoming: ConversationMessage[]) => {\n    if (incoming.length === 0 || isDisposedRef.current) {\n      return;\n    }\n\n    let nextLatestSeq = lastSeqRef.current;\n    const replacements = new Map<string, ConversationMessageUI>();\n    const additions: ConversationMessageUI[] = [];\n\n    for (const message of incoming) {\n      if (!message?.id) {\n        continue;\n      }\n      const seqValue = typeof message.seq === 'number' && Number.isFinite(message.seq)\n        ? message.seq\n        : null;\n      if (seqValue !== null) {\n        nextLatestSeq = Math.max(nextLatestSeq, seqValue);\n      }\n      if (messageIdSetRef.current.has(message.id)) {\n        continue;\n      }\n      messageIdSetRef.current.add(message.id);\n      const uiMessage = toUIMessage(message);\n      const pendingId = pendingClientMessageRef.current.get(message.client_id);\n      if (pendingId) {\n        replacements.set(pendingId, uiMessage);\n        pendingClientMessageRef.current.delete(message.client_id);\n      } else {\n        additions.push(uiMessage);\n      }\n    }\n\n    if (replacements.size === 0 && additions.length === 0) {\n      if (nextLatestSeq > lastSeqRef.current) {\n        lastSeqRef.current = nextLatestSeq;\n        sendReadUpdate(nextLatestSeq);\n      }\n      return;\n    }\n\n    lastSeqRef.current = nextLatestSeq;\n\n    setMessages(prev => {\n      let next = prev;\n      if (replacements.size > 0) {\n        next = next.map(message => {\n          const replacement = replacements.get(message.id);\n          if (!replacement) {\n            return message;\n          }\n          return {\n            ...replacement,\n            files: replacement.files ?? message.files\n          } as ConversationMessageUI;\n        });\n      } else {\n        next = [...next];\n      }\n\n      if (additions.length > 0) {\n        next = [...next, ...additions];\n      }\n\n      return next.sort((a, b) => a.timestamp - b.timestamp);\n    });\n\n    sendReadUpdate(nextLatestSeq);\n  }, [sendReadUpdate, toUIMessage]);\n\n  const fetchGapMessages = useCallback(async (\n    fromSeq: number,\n    latestSeq: number,\n    signal?: AbortSignal\n  ) => {\n    if (!conversationId || !practiceId) {\n      return;\n    }\n\n    let nextSeq: number | null = fromSeq;\n    let targetLatest = latestSeq;\n    let attempts = 0;\n\n    while (nextSeq !== null && nextSeq <= targetLatest && !signal?.aborted) {\n      try {\n        const params = new URLSearchParams({\n          practiceId,\n          from_seq: String(nextSeq),\n          limit: String(GAP_FETCH_LIMIT)\n        });\n\n        const response = await fetch(`${getConversationMessagesEndpoint(conversationId)}?${params.toString()}`, {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          credentials: 'include',\n          signal\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json().catch(() => ({})) as { error?: string };\n          throw new Error(errorData.error || `HTTP ${response.status}`);\n        }\n\n        const data = await response.json() as {\n          success: boolean;\n          error?: string;\n          data?: {\n            messages: ConversationMessage[];\n            latest_seq?: number;\n            next_from_seq?: number | null;\n          };\n        };\n        if (!data.success || !data.data) {\n          throw new Error(data.error || 'Failed to fetch message gap');\n        }\n\n        applyServerMessages(data.data.messages ?? []);\n        if (typeof data.data.latest_seq === 'number') {\n          targetLatest = data.data.latest_seq;\n        }\n        nextSeq = data.data.next_from_seq ?? null;\n        attempts = 0;\n      } catch (error) {\n        if (signal?.aborted || (error instanceof Error && error.name === 'AbortError')) {\n          return;\n        }\n        attempts += 1;\n        if (attempts < MAX_GAP_FETCH_ATTEMPTS) {\n          await new Promise(resolve => setTimeout(resolve, GAP_FETCH_RETRY_DELAY_MS * attempts));\n          continue;\n        }\n        const message = error instanceof Error ? error.message : 'Failed to recover message gap';\n        setError(message);\n        onError?.(message);\n        return;\n      }\n    }\n  }, [applyServerMessages, conversationId, practiceId, onError]);\n\n  const clearReconnectTimer = useCallback(() => {\n    if (reconnectTimerRef.current) {\n      clearTimeout(reconnectTimerRef.current);\n      reconnectTimerRef.current = null;\n    }\n  }, []);\n\n  const scheduleReconnect = useCallback(() => {\n    if (isDisposedRef.current || isClosingSocketRef.current) {\n      return;\n    }\n    if (!sessionReady || !conversationId) {\n      return;\n    }\n    if (reconnectTimerRef.current) {\n      return;\n    }\n    const nextAttempt = reconnectAttemptRef.current + 1;\n    if (nextAttempt > RECONNECT_MAX_ATTEMPTS) {\n      return;\n    }\n    reconnectAttemptRef.current = nextAttempt;\n    const backoff = Math.min(RECONNECT_BASE_DELAY_MS * 2 ** (nextAttempt - 1), RECONNECT_MAX_DELAY_MS);\n    const jitter = Math.floor(Math.random() * 250);\n    reconnectTimerRef.current = globalThis.setTimeout(() => {\n      reconnectTimerRef.current = null;\n      if (isDisposedRef.current || isClosingSocketRef.current) {\n        return;\n      }\n      if (!sessionReady || !conversationId) {\n        return;\n      }\n      connectChatRoomRef.current();\n    }, backoff + jitter);\n  }, [conversationId, sessionReady]);\n\n  const handleMessageAck = useCallback((data: Record<string, unknown>) => {\n    const clientId = typeof data.client_id === 'string' ? data.client_id : null;\n    const messageId = typeof data.message_id === 'string' ? data.message_id : null;\n    const seqValue = typeof data.seq === 'number' ? data.seq : Number(data.seq);\n    const serverTs = typeof data.server_ts === 'string' ? data.server_ts : null;\n    if (!clientId || !messageId || !serverTs || !Number.isFinite(seqValue)) {\n      return;\n    }\n\n    const pending = pendingAckRef.current.get(clientId);\n    if (pending) {\n      clearTimeout(pending.timeoutId);\n      pending.resolve({ messageId, seq: seqValue, serverTs, clientId });\n      pendingAckRef.current.delete(clientId);\n    }\n\n    lastSeqRef.current = Math.max(lastSeqRef.current, seqValue);\n\n    const pendingId = pendingClientMessageRef.current.get(clientId);\n    if (!pendingId) {\n      sendReadUpdate(lastSeqRef.current);\n      void fetchGapMessages(seqValue, seqValue, abortControllerRef.current?.signal);\n      return;\n    }\n\n    pendingClientMessageRef.current.delete(clientId);\n    messageIdSetRef.current.add(messageId);\n    setMessages(prev => prev.map(message => {\n      if (message.id !== pendingId) {\n        return message;\n      }\n      const nextTimestamp = new Date(serverTs).getTime();\n      if (!Number.isFinite(nextTimestamp)) {\n        return message;\n      }\n      return {\n        ...message,\n        id: messageId,\n        seq: seqValue,\n        server_ts: serverTs,\n        created_at: serverTs,\n        timestamp: nextTimestamp\n      };\n    }));\n    sendReadUpdate(lastSeqRef.current);\n  }, [fetchGapMessages, sendReadUpdate]);\n\n  const handleMessageNew = useCallback((data: Record<string, unknown>) => {\n    const conversationIdValue = typeof data.conversation_id === 'string' ? data.conversation_id : null;\n    if (!conversationIdValue || conversationIdValue !== conversationId) {\n      return;\n    }\n\n    const messageId = typeof data.message_id === 'string' ? data.message_id : null;\n    const clientId = typeof data.client_id === 'string' ? data.client_id : null;\n    const content = typeof data.content === 'string' ? data.content : null;\n    const role = typeof data.role === 'string' ? data.role : null;\n    const serverTs = typeof data.server_ts === 'string' ? data.server_ts : null;\n    const seqValue = typeof data.seq === 'number' ? data.seq : Number(data.seq);\n    if (!messageId || !clientId || !content || !serverTs || !Number.isFinite(seqValue)) {\n      return;\n    }\n\n    const replyToMessageId = typeof data.reply_to_message_id === 'string'\n      ? data.reply_to_message_id\n      : null;\n    const metadata = typeof data.metadata === 'object' && data.metadata !== null && !Array.isArray(data.metadata)\n      ? data.metadata as Record<string, unknown>\n      : null;\n    const attachments = Array.isArray(data.attachments)\n      ? (data.attachments as string[]).filter((item) => typeof item === 'string')\n      : [];\n\n    const message: ConversationMessage = {\n      id: messageId,\n      conversation_id: conversationIdValue,\n      practice_id: practiceId || '',\n      user_id: typeof data.user_id === 'string' ? data.user_id : '',\n      role: role === 'assistant' ? 'assistant' : role === 'system' ? 'system' : 'user',\n      content,\n      reply_to_message_id: replyToMessageId,\n      metadata: metadata ?? (attachments.length > 0 ? { attachments } : null),\n      client_id: clientId,\n      seq: seqValue,\n      server_ts: serverTs,\n      token_count: null,\n      created_at: serverTs\n    };\n\n    applyServerMessages([message]);\n  }, [applyServerMessages, conversationId, practiceId]);\n\n  const connectChatRoom = useCallback(() => {\n    if (!conversationId) {\n      return;\n    }\n    if (typeof WebSocket === 'undefined') {\n      const message = 'WebSocket is not available in this environment.';\n      setError(message);\n      onError?.(message);\n      return;\n    }\n    clearReconnectTimer();\n    isClosingSocketRef.current = false;\n    if (\n      wsRef.current &&\n      wsRef.current.readyState === WebSocket.OPEN &&\n      isSocketReadyRef.current\n    ) {\n      return;\n    }\n\n    socketSessionRef.current += 1;\n    const sessionId = socketSessionRef.current;\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    initSocketReadyPromise();\n\n    const ws = new WebSocket(getConversationWsEndpoint(conversationId));\n    wsRef.current = ws;\n\n    ws.addEventListener('open', () => {\n      reconnectAttemptRef.current = 0;\n      clearReconnectTimer();\n      ws.send(JSON.stringify({\n        type: 'auth',\n        data: {\n          protocol_version: CHAT_PROTOCOL_VERSION,\n          client_info: { platform: 'web' }\n        }\n      }));\n    });\n\n    ws.addEventListener('message', (event) => {\n      if (socketSessionRef.current !== sessionId || typeof event.data !== 'string') {\n        return;\n      }\n      let frame: { type?: string; data?: Record<string, unknown>; request_id?: string };\n      try {\n        frame = JSON.parse(event.data) as { type?: string; data?: Record<string, unknown>; request_id?: string };\n      } catch {\n        return;\n      }\n      if (!frame.type || !frame.data || typeof frame.data !== 'object') {\n        return;\n      }\n\n      switch (frame.type) {\n        case 'auth.ok': {\n          resolveSocketReady();\n          try {\n            sendFrame({\n              type: 'resume',\n              data: {\n                conversation_id: conversationId,\n                last_seq: lastSeqRef.current\n              }\n            });\n          } catch (error) {\n            if (import.meta.env.DEV) {\n              console.warn('[ChatRoom] Failed to send resume', error);\n            }\n          }\n          return;\n        }\n        case 'auth.error': {\n          const message = typeof frame.data.message === 'string' ? frame.data.message : 'Chat protocol error';\n          setError(message);\n          onError?.(message);\n          rejectSocketReady(new Error(message));\n          ws.close();\n          return;\n        }\n        case 'resume.ok': {\n          const latestSeq = Number(frame.data.latest_seq);\n          if (Number.isFinite(latestSeq)) {\n            lastSeqRef.current = Math.max(lastSeqRef.current, latestSeq);\n            sendReadUpdate(lastSeqRef.current);\n          }\n          return;\n        }\n        case 'resume.gap': {\n          const fromSeq = Number(frame.data.from_seq);\n          const latestSeq = Number(frame.data.latest_seq);\n          if (Number.isFinite(fromSeq) && Number.isFinite(latestSeq)) {\n            fetchGapMessages(fromSeq, latestSeq, abortControllerRef.current?.signal).catch((error) => {\n              if (import.meta.env.DEV) {\n                console.warn('[ChatRoom] Gap fetch failed', error);\n              }\n            });\n          }\n          return;\n        }\n        case 'message.new':\n          handleMessageNew(frame.data);\n          return;\n        case 'message.ack':\n          handleMessageAck(frame.data);\n          return;\n        case 'error': {\n          const message = typeof frame.data.message === 'string' ? frame.data.message : 'Chat error';\n          const requestId = typeof frame.request_id === 'string' ? frame.request_id : null;\n          if (requestId) {\n            const pending = pendingAckRef.current.get(requestId);\n            if (pending) {\n              clearTimeout(pending.timeoutId);\n              pending.reject(new Error(message));\n              pendingAckRef.current.delete(requestId);\n            }\n          }\n          setError(message);\n          onError?.(message);\n          return;\n        }\n        default:\n          return;\n      }\n    });\n\n    ws.addEventListener('close', () => {\n      if (socketSessionRef.current !== sessionId) {\n        return;\n      }\n      isSocketReadyRef.current = false;\n      rejectSocketReady(new Error('Chat connection closed'));\n      flushPendingAcks(new Error('Chat connection closed'));\n      if (wsRef.current === ws) {\n        wsRef.current = null;\n      }\n      if (!conversationId) {\n        return;\n      }\n      if (import.meta.env.DEV) {\n        console.info('[ChatRoom] WebSocket closed; will reconnect on next action.');\n      }\n      scheduleReconnect();\n    });\n\n    ws.addEventListener('error', (error) => {\n      if (import.meta.env.DEV) {\n        console.warn('[ChatRoom] WebSocket error', error);\n      }\n    });\n  }, [\n    clearReconnectTimer,\n    conversationId,\n    fetchGapMessages,\n    flushPendingAcks,\n    handleMessageAck,\n    handleMessageNew,\n    initSocketReadyPromise,\n    onError,\n    rejectSocketReady,\n    resolveSocketReady,\n    scheduleReconnect,\n    sendFrame,\n    sendReadUpdate\n  ]);\n\n  connectChatRoomRef.current = connectChatRoom;\n\n  const closeChatSocket = useCallback(() => {\n    isClosingSocketRef.current = true;\n    isSocketReadyRef.current = false;\n    rejectSocketReady(new Error('Chat connection closed'));\n    flushPendingAcks(new Error('Chat connection closed'));\n    clearReconnectTimer();\n    reconnectAttemptRef.current = 0;\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n  }, [clearReconnectTimer, flushPendingAcks, rejectSocketReady]);\n\n  const sendMessageOverWs = useCallback(async (\n    content: string,\n    attachments?: string[]\n  ) => {\n    const ACK_TIMEOUT_MS = 15000;\n    if (!conversationId || !practiceId) {\n      throw new Error('Conversation ID and practice ID are required');\n    }\n    if (!content.trim()) {\n      throw new Error('Message cannot be empty.');\n    }\n\n    const clientId = createClientId();\n    const tempId = `temp-${clientId}`;\n    const nowIso = new Date().toISOString();\n    const tempMessage: ConversationMessageUI = {\n      id: tempId,\n      conversation_id: conversationId,\n      practice_id: practiceId,\n      user_id: currentUserId ?? '',\n      role: 'user',\n      content,\n      metadata: attachments?.length ? { attachments } : null,\n      client_id: clientId,\n      seq: 0,\n      server_ts: nowIso,\n      token_count: null,\n      created_at: nowIso,\n      isUser: true,\n      timestamp: Date.now(),\n      files: attachments ? attachments.map((fileId) => ({\n        id: fileId,\n        name: 'File',\n        size: 0,\n        type: 'application/octet-stream',\n        url: ''\n      })) : undefined\n    };\n\n    setMessages(prev => [...prev, tempMessage]);\n    pendingClientMessageRef.current.set(clientId, tempId);\n\n    const ackPromise = new Promise<{ messageId: string; seq: number; serverTs: string; clientId: string }>((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        if (pendingAckRef.current.has(clientId)) {\n          pendingAckRef.current.delete(clientId);\n          reject(new Error('Message acknowledgment timed out'));\n        }\n      }, ACK_TIMEOUT_MS);\n      pendingAckRef.current.set(clientId, { resolve, reject, timeoutId });\n    });\n\n    try {\n      if (!wsReadyRef.current) {\n        initSocketReadyPromise();\n        connectChatRoom();\n      }\n      await waitForSocketReady();\n      sendFrame({\n        type: 'message.send',\n        data: {\n          conversation_id: conversationId,\n          client_id: clientId,\n          content,\n          ...(attachments && attachments.length > 0 ? { attachments } : {})\n        },\n        request_id: clientId\n      });\n    } catch (error) {\n      const pending = pendingAckRef.current.get(clientId);\n      if (pending) {\n        clearTimeout(pending.timeoutId);\n        pendingAckRef.current.delete(clientId);\n      }\n      pendingClientMessageRef.current.delete(clientId);\n      setMessages(prev => prev.filter(message => message.id !== tempId));\n      throw error;\n    }\n\n    return ackPromise.catch((error) => {\n      pendingClientMessageRef.current.delete(clientId);\n      setMessages(prev => prev.filter(message => message.id !== tempId));\n      throw error;\n    });\n  }, [connectChatRoom, conversationId, currentUserId, initSocketReadyPromise, practiceId, sendFrame, waitForSocketReady]);\n\n  // Fetch conversation details\n  const fetchConversation = useCallback(async () => {\n    if (!conversationId || !practiceId) {\n      return;\n    }\n\n    try {\n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json'\n      };\n\n      const params = new URLSearchParams({ practiceId });\n      const response = await fetch(`${getConversationEndpoint(conversationId)}?${params.toString()}`, {\n        method: 'GET',\n        headers,\n        credentials: 'include',\n        signal: abortControllerRef.current?.signal,\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({})) as { error?: string };\n        throw new Error(errorData.error || `HTTP ${response.status}`);\n      }\n\n      const data = await response.json() as { success: boolean; error?: string; data?: Conversation };\n      if (!data.success || !data.data) {\n        throw new Error(data.error || 'Failed to fetch conversation');\n      }\n\n      if (!isDisposedRef.current) {\n        setConversation(data.data);\n        setError(null);\n      }\n    } catch (err) {\n      if (isDisposedRef.current) return;\n      if (err instanceof Error && err.name === 'AbortError') return;\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch conversation';\n      setError(errorMessage);\n      onError?.(errorMessage);\n    }\n  }, [conversationId, practiceId, onError]);\n\n  // Fetch messages\n  const fetchMessages = useCallback(async (options?: { cursor?: string; isLoadMore?: boolean }) => {\n    if (!conversationId || !practiceId) {\n      return;\n    }\n\n    const loadingState = options?.isLoadMore ? setIsLoadingMore : setIsLoading;\n    loadingState(true);\n    setError(null);\n\n    try {\n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json'\n      };\n\n      const params = new URLSearchParams({\n        practiceId,\n        limit: '50',\n      });\n\n      if (options?.cursor) {\n        params.set('cursor', options.cursor);\n      }\n\n      const response = await fetch(`${getConversationMessagesEndpoint(conversationId)}?${params.toString()}`, {\n        method: 'GET',\n        headers,\n        credentials: 'include',\n        signal: abortControllerRef.current?.signal,\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({})) as { error?: string };\n        throw new Error(errorData.error || `HTTP ${response.status}`);\n      }\n\n      const data = await response.json() as {\n        success: boolean;\n        error?: string;\n        data?: {\n          messages: ConversationMessage[];\n          hasMore?: boolean;\n          cursor?: string | null;\n        };\n      };\n      if (!data.success || !data.data) {\n        throw new Error(data.error || 'Failed to fetch messages');\n      }\n\n      if (!isDisposedRef.current) {\n        const uiMessages = data.data.messages.map(toUIMessage);\n\n        if (options?.isLoadMore) {\n          setMessages(prev => {\n            const merged = [...uiMessages, ...prev];\n            return merged.sort((a, b) => a.timestamp - b.timestamp);\n          });\n          data.data.messages.forEach((msg) => {\n            messageIdSetRef.current.add(msg.id);\n            const seqValue = typeof msg.seq === 'number' ? msg.seq : Number(msg.seq);\n            if (Number.isFinite(seqValue)) {\n              lastSeqRef.current = Math.max(lastSeqRef.current, seqValue);\n            }\n          });\n        } else {\n          const serverMessageIds = new Set(data.data.messages.map((msg) => msg.id));\n          const pendingIds = new Set(pendingClientMessageRef.current.values());\n          lastSeqRef.current = data.data.messages.reduce((max, msg) => {\n            const seqValue = typeof msg.seq === 'number' && Number.isFinite(msg.seq) ? msg.seq : null;\n            return seqValue !== null ? Math.max(max, seqValue) : max;\n          }, 0);\n\n          setMessages(prev => {\n            const optimistic = prev.filter((message) => {\n              return pendingIds.has(message.id) || message.id.startsWith('temp-');\n            });\n            const mergedIds = new Set(uiMessages.map((message) => message.id));\n            const merged = [\n              ...uiMessages,\n              ...optimistic.filter((message) => !mergedIds.has(message.id))\n            ].sort((a, b) => a.timestamp - b.timestamp);\n\n            const nextIds = new Set(serverMessageIds);\n            for (const message of optimistic) {\n              nextIds.add(message.id);\n            }\n            messageIdSetRef.current = nextIds;\n\n            return merged;\n          });\n          sendReadUpdate(lastSeqRef.current);\n        }\n\n        setHasMore(Boolean(data.data.hasMore));\n        setNextCursor(data.data.cursor ?? null);\n        setError(null);\n      }\n    } catch (err) {\n      if (isDisposedRef.current) return;\n      if (err instanceof Error && err.name === 'AbortError') return;\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch messages';\n      setError(errorMessage);\n      onError?.(errorMessage);\n    } finally {\n      if (!isDisposedRef.current) {\n        loadingState(false);\n      }\n    }\n  }, [conversationId, practiceId, toUIMessage, onError, sendReadUpdate]);\n\n  // Send message\n  const sendMessage = useCallback(async (content: string, attachments?: string[]) => {\n    try {\n      await sendMessageOverWs(content, attachments);\n      await fetchConversation();\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';\n      setError(errorMessage);\n      onError?.(errorMessage);\n      throw err;\n    }\n  }, [fetchConversation, onError, sendMessageOverWs]);\n\n  // Load more messages (pagination)\n  const loadMore = useCallback(async () => {\n    if (!nextCursor || isLoadingMore) {\n      return;\n    }\n    await fetchMessages({ cursor: nextCursor, isLoadMore: true });\n  }, [nextCursor, isLoadingMore, fetchMessages]);\n\n  // Refresh messages\n  const refresh = useCallback(async () => {\n    await Promise.all([fetchConversation(), fetchMessages()]);\n  }, [fetchConversation, fetchMessages]);\n\n  // Initial load\n  useEffect(() => {\n    if (!conversationId || !practiceId) {\n      setIsLoading(false);\n      closeChatSocket();\n      return;\n    }\n\n    messageIdSetRef.current.clear();\n    pendingClientMessageRef.current.clear();\n    lastSeqRef.current = 0;\n    lastReadSeqRef.current = 0;\n\n    abortControllerRef.current = new AbortController();\n    Promise.all([fetchConversation(), fetchMessages()]).finally(() => {\n      if (!isDisposedRef.current) {\n        setIsLoading(false);\n      }\n    });\n    connectChatRoom();\n\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      closeChatSocket();\n    };\n  }, [conversationId, practiceId, closeChatSocket, connectChatRoom, fetchConversation, fetchMessages]); // Only run on mount or when IDs change\n\n  return {\n    conversation,\n    messages,\n    isLoading,\n    isLoadingMore,\n    error,\n    sendMessage,\n    loadMore,\n    refresh,\n    hasMore,\n    nextCursor,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useConversations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useFileUpload.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":98,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":98,"endColumn":20,"suggestions":[{"fix":{"range":[3476,3497],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":209,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":209,"endColumn":19,"suggestions":[{"fix":{"range":[7017,7061],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":222,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":222,"endColumn":20,"suggestions":[{"fix":{"range":[7631,7652],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useCallback, useEffect } from 'preact/hooks';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { FileAttachment } from '../../../worker/types';\nimport { getWorkerRequestUrl, uploadWithProgress, validateFile } from '@/shared/services/upload/UploadTransport';\n\nexport type FileStatus = \n  | 'uploading'      // Browser  Workers\n  | 'uploaded'       // Stored in R2, queued for processing\n  | 'processing'     // Adobe extraction in progress\n  | 'analyzing'      // AI analysis in progress  \n  | 'completed'      // Ready to use\n  | 'failed';        // Error occurred\n\nexport interface UploadingFile {\n  id: string;\n  file: File;\n  status: FileStatus;\n  progress: number;\n  fileId?: string;\n  storageKey?: string;\n  error?: string;\n}\n\ninterface UploadResponse {\n  fileName: string;\n  fileSize?: number;\n  fileType: string;\n  url: string;\n}\n\ninterface UseFileUploadOptions {\n  practiceId?: string;\n  conversationId?: string;\n  onError?: (error: string) => void;\n}\n\n/**\n * Hook that uses blawby-ai practice for all file uploads\n * This is the preferred way to use file upload in components\n */\nexport const useFileUploadWithContext = ({ conversationId, onError }: Omit<UseFileUploadOptions, 'practiceId'>) => {\n  const { activePracticeId } = useSessionContext();\n  return useFileUpload({ practiceId: activePracticeId ?? undefined, conversationId, onError });\n};\n\n// Utility function to upload a file to backend\nasync function _uploadFileToBackend(file: File, practiceId: string, conversationId: string, signal?: AbortSignal): Promise<UploadResponse> {\n  try {\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('practiceId', practiceId);\n    formData.append('conversationId', conversationId);\n\n    const response = await fetch(getWorkerRequestUrl('/api/files/upload'), {\n      method: 'POST',\n      body: formData,\n      signal,\n      credentials: 'include'\n    });\n    \n    if (!response.ok) {\n      const error = await response.json().catch(() => ({})) as { error?: string };\n      throw new Error(error?.error || 'File upload failed');\n    }\n    \n    const result = await response.json() as { data: UploadResponse };\n    return result.data;\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new Error('Upload cancelled');\n    }\n    throw error;\n  }\n}\n\n/**\n * Legacy hook that requires practiceId parameter\n * @deprecated Use useFileUploadWithContext() instead\n */\nexport const useFileUpload = ({ practiceId, conversationId, onError }: UseFileUploadOptions) => {\n  const [previewFiles, setPreviewFiles] = useState<FileAttachment[]>([]);\n  const [uploadingFiles, setUploadingFiles] = useState<UploadingFile[]>([]);\n  const [isDragging, setIsDragging] = useState(false);\n  const dragCounter = useRef(0);\n  const abortControllers = useRef<Map<string, AbortController>>(new Map());\n\n  const resolvedPracticeId = (practiceId ?? '').trim();\n  const resolvedConversationId = (conversationId ?? '').trim();\n\n  // Check if we're ready to upload files\n  const isReadyToUpload = resolvedPracticeId !== '' && resolvedConversationId !== '';\n\n\n  // Upload files with progress tracking\n  const uploadFiles = useCallback(async (files: File[]) => {\n    if (!isReadyToUpload) {\n      const error = `Cannot upload files yet. Waiting for conversation to initialize. practiceId: \"${resolvedPracticeId}\", conversationId: \"${resolvedConversationId}\"`;\n      console.error(error);\n      onError?.(error);\n      return;\n    }\n\n    // Validate files first\n    const validFiles: File[] = [];\n    const invalidFiles: string[] = [];\n\n    files.forEach(file => {\n      const validation = validateFile(file);\n      if (validation.isValid) {\n        validFiles.push(file);\n      } else {\n        invalidFiles.push(`${file.name}: ${validation.error}`);\n      }\n    });\n\n    if (invalidFiles.length > 0) {\n      onError?.(`Invalid files: ${invalidFiles.join(', ')}`);\n    }\n\n    if (validFiles.length === 0) return;\n\n    // Create upload tracking entries\n    const newUploads: UploadingFile[] = validFiles.map(file => ({\n      id: crypto.randomUUID(),\n      file,\n      status: 'uploading',\n      progress: 0\n    }));\n\n    setUploadingFiles(prev => [...prev, ...newUploads]);\n\n    // Upload each file with progress tracking in parallel\n    const uploadPromises = newUploads.map(async (upload) => {\n      const abortController = new AbortController();\n      abortControllers.current.set(upload.id, abortController);\n\n      try {\n        const result = await uploadWithProgress(upload.file, {\n          practiceId: resolvedPracticeId,\n          conversationId: resolvedConversationId,\n          onProgress: (progress) => {\n            setUploadingFiles(prev => prev.map(f => \n              f.id === upload.id \n                ? { ...f, progress: progress.percentage }\n                : f\n            ));\n          },\n          onSuccess: (result) => {\n            \n            // Update file to uploaded status\n            setUploadingFiles(prev => prev.map(f => \n              f.id === upload.id \n                ? { \n                    ...f, \n                    status: 'uploaded',\n                    progress: 100,\n                    fileId: result.fileId,\n                    storageKey: result.storageKey\n                  }\n                : f\n            ));\n            \n            // After a brief delay, move to previewFiles for smooth UX\n            setTimeout(() => {\n              \n              setPreviewFiles(prev => [...prev, {\n                id: result.fileId,\n                name: upload.file.name,\n                size: upload.file.size,\n                type: upload.file.type,\n                url: result.url,\n                storageKey: result.storageKey\n              }]);\n              \n              // Remove from uploadingFiles\n              setUploadingFiles(prev => prev.filter(f => f.id !== upload.id));\n            }, 500);\n          },\n          onError: (error) => {\n            setUploadingFiles(prev => prev.map(f => \n              f.id === upload.id \n                ? { ...f, status: 'failed', error: error.message }\n                : f\n            ));\n            onError?.(`Failed to upload ${upload.file.name}: ${error.message}`);\n          },\n          signal: abortController.signal\n        });\n\n        return result;\n      } catch (error) {\n        setUploadingFiles(prev => prev.map(f => \n          f.id === upload.id \n            ? { ...f, status: 'failed', error: error instanceof Error ? error.message : 'Unknown error' }\n            : f\n        ));\n        throw error;\n      } finally {\n        abortControllers.current.delete(upload.id);\n      }\n    });\n\n    // Wait for all uploads to complete (or fail)\n    try {\n      await Promise.all(uploadPromises);\n    } catch (error) {\n      // Individual upload errors are already handled in the map function above\n      // This catch block ensures the function doesn't throw unhandled promise rejections\n      console.warn('Some uploads failed:', error);\n    }\n  }, [resolvedPracticeId, resolvedConversationId, isReadyToUpload, onError]);\n\n  // Handle camera capture\n  const handleCameraCapture = useCallback(async (file: File) => {\n    await uploadFiles([file]);\n  }, [uploadFiles]);\n\n  // Handle file selection (now uses the new upload progress system)\n  const handleFileSelect = useCallback(async (files: File[]) => {\n    if (!isReadyToUpload) {\n      const error = `Cannot upload files yet. Waiting for conversation to initialize. practiceId: \"${resolvedPracticeId}\", conversationId: \"${resolvedConversationId}\"`;\n      console.error(error);\n      onError?.(error);\n      return [];\n    }\n\n    // Use the new upload system with progress tracking\n    await uploadFiles(files);\n    \n    // Return empty array since files will be handled by the upload system\n    // and moved to previewFiles automatically when complete\n    return [];\n  }, [uploadFiles, isReadyToUpload, onError, resolvedPracticeId, resolvedConversationId]);\n\n  // Cancel upload\n  const cancelUpload = useCallback((uploadId: string) => {\n    const controller = abortControllers.current.get(uploadId);\n    if (controller) {\n      controller.abort();\n      abortControllers.current.delete(uploadId);\n    }\n    \n    setUploadingFiles(prev => prev.filter(f => f.id !== uploadId));\n  }, []);\n\n  // Remove preview file\n  const removePreviewFile = useCallback((index: number) => {\n    setPreviewFiles(prev => prev.filter((_, i) => i !== index));\n  }, []);\n\n  // Clear all preview files\n  const clearPreviewFiles = useCallback(() => {\n    setPreviewFiles([]);\n  }, []);\n\n  // Clear all uploading files\n  const clearUploadingFiles = useCallback(() => {\n    // Cancel all ongoing uploads\n    abortControllers.current.forEach(controller => controller.abort());\n    abortControllers.current.clear();\n    setUploadingFiles([]);\n  }, []);\n\n  // Handle media capture (audio/video)\n  const handleMediaCapture = useCallback((blob: Blob, _type: 'audio' | 'video') => {\n    const url = URL.createObjectURL(blob);\n    const file: FileAttachment = {\n      id: `recording_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`, // Generate unique ID\n      name: `Recording_${new Date().toISOString()}.webm`,\n      size: blob.size,\n      type: blob.type,\n      url,\n    };\n\n    return file;\n  }, []);\n\n  // Drag and drop handlers\n  const handleDragEnter = useCallback((e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    dragCounter.current += 1;\n    setIsDragging(true);\n  }, []);\n\n  const handleDragLeave = useCallback((e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    dragCounter.current -= 1;\n    \n    // Only reset dragging state when we've left all drag elements\n    if (dragCounter.current === 0) {\n      setIsDragging(false);\n    }\n  }, []);\n\n  const handleDragOver = useCallback((e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n  }, []);\n\n  const handleDrop = useCallback(async (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    dragCounter.current = 0;\n    setIsDragging(false);\n\n    // Get all files from the drop event\n    const droppedFiles = Array.from(e.dataTransfer?.files || []);\n    \n    if (droppedFiles.length === 0) return;\n\n    // Separate different types of files\n    const imageFiles = droppedFiles.filter(file => file.type.startsWith('image/'));\n    const videoFiles = droppedFiles.filter(file => file.type.startsWith('video/'));\n    const otherFiles = droppedFiles.filter(file => \n      !file.type.startsWith('image/') && \n      !file.type.startsWith('video/')\n    );\n\n    // Apply file type validation\n    const mediaFiles = [...imageFiles, ...videoFiles];\n    const safeOtherFiles = otherFiles.filter(file => {\n      const fileExtension = file.name.split('.').pop()?.toLowerCase();\n      const disallowedExtensions = ['zip', 'exe', 'bat', 'cmd', 'msi', 'app'];\n      return !disallowedExtensions.includes(fileExtension || '');\n    });\n\n    // Handle all valid files together\n    const allValidFiles = [...mediaFiles, ...safeOtherFiles];\n    if (allValidFiles.length > 0) {\n      await handleFileSelect(allValidFiles);\n    }\n\n    // Show alert if any files were filtered out\n    if (safeOtherFiles.length < otherFiles.length) {\n      onError?.('Some files were not uploaded because they have disallowed file extensions (zip, exe, etc.)');\n    }\n  }, [handleFileSelect, onError]);\n\n  // Setup global drag handlers with automatic cleanup\n  useEffect(() => {\n    if (typeof document !== 'undefined') {\n      document.body.addEventListener('dragenter', handleDragEnter);\n      document.body.addEventListener('dragleave', handleDragLeave);\n      document.body.addEventListener('dragover', handleDragOver);\n      document.body.addEventListener('drop', handleDrop);\n\n      return () => {\n        document.body.removeEventListener('dragenter', handleDragEnter);\n        document.body.removeEventListener('dragleave', handleDragLeave);\n        document.body.removeEventListener('dragover', handleDragOver);\n        document.body.removeEventListener('drop', handleDrop);\n      };\n    }\n  }, [handleDragEnter, handleDragLeave, handleDragOver, handleDrop]);\n\n  return {\n    previewFiles,\n    uploadingFiles,\n    isDragging,\n    setIsDragging,\n    handleCameraCapture,\n    handleFileSelect,\n    handleMediaCapture,\n    removePreviewFile,\n    clearPreviewFiles,\n    clearUploadingFiles,\n    cancelUpload,\n    uploadFiles,\n    isReadyToUpload\n  };\n}; \n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useMatterState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useMessageHandling.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":207,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":207,"endColumn":19,"suggestions":[{"fix":{"range":[8310,8382],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":268,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":268,"endColumn":20,"suggestions":[{"fix":{"range":[11602,11711],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":286,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":286,"endColumn":18,"suggestions":[{"fix":{"range":[12128,12155],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":404,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":404,"endColumn":21,"suggestions":[{"fix":{"range":[15688,15749],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1017,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1017,"endColumn":27,"suggestions":[{"fix":{"range":[37708,37764],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1044,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1044,"endColumn":29,"suggestions":[{"fix":{"range":[38766,38817],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1090,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1090,"endColumn":23,"suggestions":[{"fix":{"range":[40275,40351],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1098,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1098,"endColumn":21,"suggestions":[{"fix":{"range":[40515,40565],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1144,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1144,"endColumn":21,"suggestions":[{"fix":{"range":[41852,41935],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1150,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1150,"endColumn":21,"suggestions":[{"fix":{"range":[42038,42125],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1187,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1187,"endColumn":21,"suggestions":[{"fix":{"range":[43151,43443],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1198,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1198,"endColumn":23,"suggestions":[{"fix":{"range":[43631,43877],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1208,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1208,"endColumn":21,"suggestions":[{"fix":{"range":[44029,44268],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1265,"column":12,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1265,"endColumn":25,"suggestions":[{"fix":{"range":[46274,46334],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1336,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1336,"endColumn":25,"suggestions":[{"fix":{"range":[48696,48786],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1339,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1339,"endColumn":23,"suggestions":[{"fix":{"range":[48846,48977],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1395,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1395,"endColumn":21,"suggestions":[{"fix":{"range":[50763,50844],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1399,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1399,"endColumn":20,"suggestions":[{"fix":{"range":[50941,51118],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1442,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1442,"endColumn":21,"suggestions":[{"fix":{"range":[52160,52226],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1523,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1523,"endColumn":20,"suggestions":[{"fix":{"range":[55123,55267],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1564,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1564,"endColumn":20,"suggestions":[{"fix":{"range":[56667,56744],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1650,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1650,"endColumn":23,"suggestions":[{"fix":{"range":[60834,60904],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1662,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1662,"endColumn":25,"suggestions":[{"fix":{"range":[61347,61408],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1666,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1666,"endColumn":25,"suggestions":[{"fix":{"range":[61538,61650],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1675,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1675,"endColumn":23,"suggestions":[{"fix":{"range":[61843,61959],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1725,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1725,"endColumn":20,"suggestions":[{"fix":{"range":[63628,63700],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1737,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1737,"endColumn":21,"suggestions":[{"fix":{"range":[64318,64684],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1753,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1753,"endColumn":25,"suggestions":[{"fix":{"range":[64860,65002],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1813,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1813,"endColumn":27,"suggestions":[{"fix":{"range":[67855,67921],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1827,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1827,"endColumn":25,"suggestions":[{"fix":{"range":[68417,68588],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1839,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1839,"endColumn":20,"suggestions":[{"fix":{"range":[68788,68843],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1930,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1930,"endColumn":21,"suggestions":[{"fix":{"range":[71578,71741],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1952,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1952,"endColumn":23,"suggestions":[{"fix":{"range":[72179,72347],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1987,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1987,"endColumn":21,"suggestions":[{"fix":{"range":[73221,73492],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2014,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2014,"endColumn":23,"suggestions":[{"fix":{"range":[74368,74552],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2024,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2024,"endColumn":21,"suggestions":[{"fix":{"range":[74747,74950],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2042,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2042,"endColumn":21,"suggestions":[{"fix":{"range":[75488,75716],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2052,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2052,"endColumn":19,"suggestions":[{"fix":{"range":[75787,75867],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2060,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2060,"endColumn":21,"suggestions":[{"fix":{"range":[76092,76159],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2093,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2093,"endColumn":21,"suggestions":[{"fix":{"range":[77127,77197],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2142,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2142,"endColumn":21,"suggestions":[{"fix":{"range":[78897,78967],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2169,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2169,"endColumn":19,"suggestions":[{"fix":{"range":[79928,80010],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2196,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2196,"endColumn":19,"suggestions":[{"fix":{"range":[80901,80983],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2248,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2248,"endColumn":21,"suggestions":[{"fix":{"range":[82300,82375],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2269,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2269,"endColumn":21,"suggestions":[{"fix":{"range":[82893,82962],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2420,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2420,"endColumn":21,"suggestions":[{"fix":{"range":[87910,87971],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2472,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2472,"endColumn":21,"suggestions":[{"fix":{"range":[89709,89788],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2495,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2495,"endColumn":23,"suggestions":[{"fix":{"range":[90601,90679],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":2510,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":2510,"endColumn":25,"suggestions":[{"fix":{"range":[91183,91270],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":49,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useRef, useEffect, useMemo } from 'preact/hooks';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { ChatMessageUI, FileAttachment, MessageReaction } from '../../../worker/types';\nimport type { ContactData } from '@/features/intake/components/ContactForm';\nimport { getConversationMessagesEndpoint, getConversationWsEndpoint } from '@/config/api';\nimport { getWorkerApiUrl } from '@/config/urls';\nimport { submitContactForm } from '@/shared/utils/forms';\nimport { triggerIntakeInvitation } from '@/shared/lib/apiClient';\nimport { buildIntakePaymentUrl, type IntakePaymentRequest } from '@/shared/utils/intakePayments';\nimport { asMinor } from '@/shared/utils/money';\nimport type { Conversation, ConversationMessage, ConversationMetadata, ConversationMode, FirstMessageIntent } from '@/shared/types/conversation';\nimport {\n  initialIntakeState,\n  type IntakeConversationState,\n  type SlimContactDraft,\n  type IntakeStep\n} from '@/shared/types/intake';\nimport {\n  updateConversationMetadata as patchConversationMetadata,\n  fetchMessageReactions,\n  addMessageReaction,\n  removeMessageReaction,\n  postSystemMessage\n} from '@/shared/lib/conversationApi';\n\nconst DEBUG_MESSAGE_PAGINATION = import.meta.env.DEV;\n\nconst sanitizeMarkdown = (text: string): string => {\n  if (typeof text !== 'string') return '';\n  // First replace HTML metacharacters with entities to prevent stored-XSS\n  const sanitizedHtml = text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n  // Then backslash-escape Markdown metacharacters\n  return sanitizedHtml.replace(/([\\\\`*_{}[\\]()#+\\-.!])/g, '\\\\$1');\n};\n\nconst sanitizeDescriptionForCodeBlock = (text: string): string => {\n  if (typeof text !== 'string') return '';\n  // Avoid breaking the code fence (```) by escaping or breaking up backtick sequences\n  return text.replace(/```/g, '` ` `');\n};\n\nconst ABSOLUTE_URL_PATTERN = /^(https?:)?\\/\\//i;\n\nconst buildFileUrl = (value: string): string => {\n  const trimmed = value.trim();\n  if (!trimmed) return '';\n  if (ABSOLUTE_URL_PATTERN.test(trimmed) || trimmed.startsWith('data:') || trimmed.startsWith('blob:')) {\n    return trimmed;\n  }\n  if (trimmed.startsWith('/')) {\n    return trimmed;\n  }\n  return `${getWorkerApiUrl()}/api/files/${encodeURIComponent(trimmed)}`;\n};\n\n// Global interface for window API base override and debug properties\ndeclare global {\n  interface Window {\n    __API_BASE__?: string;\n    __DEBUG_AI_MESSAGES__?: (messages: ChatMessageUI[]) => void;\n    __DEBUG_SEND_MESSAGE__?: (message: string, attachments: FileAttachment[]) => void;\n    __DEBUG_CONTACT_FORM__?: (contactData: ContactData | Record<string, boolean>, message: string) => void;\n  }\n}\n\ninterface UseMessageHandlingOptions {\n  practiceId?: string;\n  practiceSlug?: string;\n  conversationId?: string; // Required for user-to-user chat\n  mode?: ConversationMode | null;\n  onConversationMetadataUpdated?: (metadata: ConversationMetadata | null) => void;\n  onError?: (error: string) => void;\n}\n\nconst CHAT_PROTOCOL_VERSION = 1;\nconst SOCKET_READY_TIMEOUT_MS = 8000;\nconst SESSION_READY_TIMEOUT_MS = 8000;\nconst GAP_FETCH_LIMIT = 50;\nconst MAX_GAP_FETCH_ATTEMPTS = 3;\nconst GAP_FETCH_RETRY_DELAY_MS = 1000;\nconst MESSAGE_CACHE_LIMIT = 200;\nconst RECONNECT_BASE_DELAY_MS = 800;\nconst RECONNECT_MAX_DELAY_MS = 12000;\nconst RECONNECT_MAX_ATTEMPTS = 5;\n\ntype IntakeFieldsPayload = {\n  practiceArea?: string;\n  practiceAreaName?: string;\n  description?: string;\n  urgency?: 'routine' | 'time_sensitive' | 'emergency';\n  opposingParty?: string;\n  city?: string;\n  state?: string;\n  postalCode?: string;\n  country?: string;\n  addressLine1?: string;\n  addressLine2?: string;\n  desiredOutcome?: string;\n  courtDate?: string;\n  income?: string;\n  householdSize?: number;\n  hasDocuments?: boolean;\n  eligibilitySignals?: string[];\n  caseStrength?: 'needs_more_info' | 'developing' | 'strong';\n  missingSummary?: string | null;\n};\n\nconst normalizeSlimContactDraft = (value: unknown): SlimContactDraft | null => {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) return null;\n  const draft = value as Record<string, unknown>;\n  const name = typeof draft.name === 'string' ? draft.name.trim() : '';\n  const email = typeof draft.email === 'string' ? draft.email.trim() : '';\n  const phone = typeof draft.phone === 'string' ? draft.phone.trim() : '';\n  const city = typeof draft.city === 'string' ? draft.city.trim() : '';\n  const state = typeof draft.state === 'string' ? draft.state.trim() : '';\n  if (!name || !email || !phone || !city || !state) return null;\n  const opposingParty = typeof draft.opposingParty === 'string' ? draft.opposingParty.trim() : '';\n  const description = typeof draft.description === 'string' ? draft.description.trim() : '';\n  return {\n    name,\n    email,\n    phone,\n    city,\n    state,\n    ...(opposingParty ? { opposingParty } : {}),\n    ...(description ? { description } : {})\n  };\n};\n\nconst createClientId = (): string => {\n  if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {\n    return crypto.randomUUID();\n  }\n  return `client-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n};\n\nconst isTempMessageId = (messageId: string): boolean => messageId.startsWith('temp-') || messageId.startsWith('system-');\n\nconst getMessageCacheKey = (practiceId: string, conversationId: string): string => (\n  `chat:messages:${practiceId}:${conversationId}`\n);\n\nconst parsePaymentRequestMetadata = (metadata: unknown): IntakePaymentRequest | undefined => {\n  if (!metadata || typeof metadata !== 'object' || Array.isArray(metadata)) {\n    return undefined;\n  }\n  const record = metadata as Record<string, unknown>;\n  const candidate = record.paymentRequest;\n  if (!candidate || typeof candidate !== 'object' || Array.isArray(candidate)) {\n    return undefined;\n  }\n  const data = candidate as Record<string, unknown>;\n  const request: IntakePaymentRequest = {};\n  if (typeof data.intakeUuid === 'string') request.intakeUuid = data.intakeUuid;\n  if (typeof data.clientSecret === 'string') request.clientSecret = data.clientSecret;\n  if (typeof data.paymentLinkUrl === 'string') request.paymentLinkUrl = data.paymentLinkUrl;\n  if (typeof data.checkoutSessionUrl === 'string') request.checkoutSessionUrl = data.checkoutSessionUrl;\n  if (typeof data.checkoutSessionId === 'string') request.checkoutSessionId = data.checkoutSessionId;\n  if (typeof data.amount === 'number') request.amount = asMinor(data.amount);\n  if (typeof data.currency === 'string') request.currency = data.currency;\n  if (typeof data.practiceName === 'string') request.practiceName = data.practiceName;\n  if (typeof data.practiceLogo === 'string') request.practiceLogo = data.practiceLogo;\n  if (typeof data.practiceSlug === 'string') request.practiceSlug = data.practiceSlug;\n  if (typeof data.practiceId === 'string') request.practiceId = data.practiceId;\n  if (typeof data.conversationId === 'string') request.conversationId = data.conversationId;\n  if (typeof data.returnTo === 'string') request.returnTo = data.returnTo;\n\n  const hasPayload =\n    typeof request.intakeUuid === 'string' ||\n    typeof request.clientSecret === 'string' ||\n    typeof request.paymentLinkUrl === 'string' ||\n    typeof request.checkoutSessionUrl === 'string';\n  return hasPayload ? request : undefined;\n};\n\n/**\n * Hook that uses blawby-ai practice for all message handling\n * This is the preferred way to use message handling in components\n */\nexport const useMessageHandlingWithContext = ({ conversationId, onError }: Omit<UseMessageHandlingOptions, 'practiceId'>) => {\n  const { activePracticeId } = useSessionContext();\n  return useMessageHandling({ practiceId: activePracticeId ?? undefined, conversationId, onError });\n};\n\n/**\n * Legacy hook that requires practiceId parameter\n * @deprecated Use useMessageHandlingWithContext() instead\n * \n * Note: For user-to-user chat, conversationId is required.\n * This hook will fetch messages on mount if conversationId is provided.\n */\nexport const useMessageHandling = ({\n  practiceId,\n  practiceSlug,\n  conversationId,\n  mode,\n  onConversationMetadataUpdated,\n  onError\n}: UseMessageHandlingOptions) => {\n  useEffect(() => {\n    if (DEBUG_MESSAGE_PAGINATION) {\n      console.info('[useMessageHandling][pagination] instrumentation active');\n    }\n  }, []);\n\n  const { session, isPending: sessionIsPending, isAnonymous } = useSessionContext();\n  const sessionReady = Boolean(session?.user) && !sessionIsPending;\n  const currentUserId = session?.user?.id ?? null;\n  const [messages, setMessages] = useState<ChatMessageUI[]>([]);\n  const [conversationMetadata, setConversationMetadata] = useState<ConversationMetadata | null>(null);\n  const [hasMoreMessages, setHasMoreMessages] = useState(false);\n  const [nextCursor, setNextCursor] = useState<string | null>(null);\n  const [isLoadingMoreMessages, setIsLoadingMoreMessages] = useState(false);\n  const [messagesReady, setMessagesReady] = useState(false);\n  const isLoadingMoreRef = useRef(false);\n  const abortControllerRef = useRef<globalThis.AbortController | null>(null);\n  const consultFlowAbortRef = useRef<globalThis.AbortController | null>(null);\n  const intentAbortRef = useRef<globalThis.AbortController | null>(null);\n  const metadataUpdateQueueRef = useRef<Promise<Conversation | null>>(Promise.resolve(null));\n  const isDisposedRef = useRef(false);\n  const lastConversationIdRef = useRef<string | undefined>();\n  const conversationIdRef = useRef<string | undefined>();\n  const practiceIdRef = useRef<string | undefined>();\n  const conversationMetadataRef = useRef<ConversationMetadata | null>(null);\n  const hasLoggedIntentRef = useRef(false);\n  const [isConsultFlowActive, setIsConsultFlowActive] = useState(false);\n  const wsRef = useRef<WebSocket | null>(null);\n  const wsReadyRef = useRef<Promise<void> | null>(null);\n  const wsReadyResolveRef = useRef<(() => void) | null>(null);\n  const wsReadyRejectRef = useRef<((error: Error) => void) | null>(null);\n  const socketSessionRef = useRef(0);\n  const isSocketReadyRef = useRef(false);\n  const lastSeqRef = useRef(0);\n  const lastReadSeqRef = useRef(0);\n  const messageIdSetRef = useRef(new Set<string>());\n  const reactionFetchRef = useRef(new Map<string, Promise<MessageReaction[]>>());\n  const reactionLoadedRef = useRef(new Set<string>());\n  const pendingAckRef = useRef(new Map<string, {\n    resolve: (ack: { messageId: string; seq: number; serverTs: string; clientId: string }) => void;\n    reject: (error: Error) => void;\n  }>());\n  const pendingClientMessageRef = useRef(new Map<string, string>());\n  const socketConversationIdRef = useRef<string | null>(null);\n  const connectChatRoomRef = useRef<(conversationId: string) => void>(() => {});\n  const isClosingSocketRef = useRef(false);\n  const reconnectAttemptRef = useRef(0);\n  const reconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const [isSocketReady, setIsSocketReady] = useState(false);\n  const [paymentRetryNotice, setPaymentRetryNotice] = useState<{\n    message: string;\n    paymentUrl: string;\n  } | null>(null);\n  practiceIdRef.current = practiceId;\n  const messagesRef = useRef(messages);\n  messagesRef.current = messages;\n  const sessionReadyRef = useRef(sessionReady);\n  sessionReadyRef.current = sessionReady;\n  \n  // Debug hooks for test environment (development only)\n  useEffect(() => {\n    if (import.meta.env.MODE !== 'production' && typeof window !== 'undefined') {\n      window.__DEBUG_AI_MESSAGES__ = (messages: ChatMessageUI[]) => {\n        console.log('[TEST] Current messages:', messages.map((m) => ({ role: m.role, isUser: m.isUser, id: m.id })));\n      };\n      window.__DEBUG_AI_MESSAGES__?.(messages);\n    }\n  }, [messages]);\n\n  useEffect(() => {\n    if (mode === 'REQUEST_CONSULTATION') {\n      setIsConsultFlowActive(true);\n      return;\n    }\n    if (mode === 'ASK_QUESTION' || mode === null) {\n      setIsConsultFlowActive(false);\n    }\n  }, [mode]);\n\n  const logDev = useCallback((message: string, data?: unknown) => {\n    if (import.meta.env.DEV) {\n      console.log(message, data);\n    }\n  }, []);\n\n  const updateSocketReady = useCallback((ready: boolean) => {\n    if (isDisposedRef.current) {\n      return;\n    }\n    setIsSocketReady(ready);\n  }, []);\n\n  const initSocketReadyPromise = useCallback(() => {\n    wsReadyRef.current = new Promise((resolve, reject) => {\n      wsReadyResolveRef.current = resolve;\n      wsReadyRejectRef.current = reject;\n    });\n    isSocketReadyRef.current = false;\n    updateSocketReady(false);\n  }, [updateSocketReady]);\n\n  const resolveSocketReady = useCallback(() => {\n    isSocketReadyRef.current = true;\n    updateSocketReady(true);\n    wsReadyResolveRef.current?.();\n    wsReadyResolveRef.current = null;\n    wsReadyRejectRef.current = null;\n  }, [updateSocketReady]);\n\n  const rejectSocketReady = useCallback((error: Error) => {\n    isSocketReadyRef.current = false;\n    updateSocketReady(false);\n    wsReadyRejectRef.current?.(error);\n    wsReadyResolveRef.current = null;\n    wsReadyRejectRef.current = null;\n  }, [updateSocketReady]);\n\n  const flushPendingAcks = useCallback((error: Error) => {\n    for (const pending of pendingAckRef.current.values()) {\n      pending.reject(error);\n    }\n    pendingAckRef.current.clear();\n  }, []);\n\n  const resetRealtimeState = useCallback(() => {\n    messageIdSetRef.current.clear();\n    pendingClientMessageRef.current.clear();\n    lastSeqRef.current = 0;\n    lastReadSeqRef.current = 0;\n    reactionLoadedRef.current.clear();\n    reactionFetchRef.current.clear();\n  }, []);\n\n  const waitForSocketReady = useCallback(async () => {\n    if (!wsReadyRef.current) {\n      throw new Error('Chat connection not initialized');\n    }\n    let timeoutId: ReturnType<typeof setTimeout> | null = null;\n    const timeoutPromise = new Promise<void>((_resolve, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(new Error('Chat connection timed out'));\n      }, SOCKET_READY_TIMEOUT_MS);\n    });\n\n    try {\n      await Promise.race([wsReadyRef.current, timeoutPromise]);\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }, []);\n\n  const waitForSessionReady = useCallback(async () => {\n    if (sessionReadyRef.current) {\n      return;\n    }\n    if (typeof window === 'undefined') {\n      throw new Error('Chat session is not available in this environment.');\n    }\n    const start = Date.now();\n    while (!sessionReadyRef.current) {\n      if (isDisposedRef.current) {\n        throw new Error('Chat session was disposed.');\n      }\n      if (Date.now() - start > SESSION_READY_TIMEOUT_MS) {\n        throw new Error('Secure session is not ready yet. Please try again in a moment.');\n      }\n      await new Promise(resolve => setTimeout(resolve, 200));\n    }\n  }, []);\n\n  const sendFrame = useCallback((frame: { type: string; data: Record<string, unknown>; request_id?: string }) => {\n    const ws = wsRef.current;\n    if (!ws || ws.readyState !== WebSocket.OPEN) {\n      throw new Error('Chat connection not open');\n    }\n    ws.send(JSON.stringify(frame));\n  }, []);\n\n  const sendReadUpdate = useCallback((seq: number) => {\n    const activeConversationId = conversationIdRef.current;\n    if (!activeConversationId || !isSocketReadyRef.current) {\n      return;\n    }\n    if (seq <= lastReadSeqRef.current) {\n      return;\n    }\n    lastReadSeqRef.current = seq;\n    try {\n      sendFrame({\n        type: 'read.update',\n        data: {\n          conversation_id: activeConversationId,\n          last_read_seq: seq\n        }\n      });\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.warn('[ChatRoom] Failed to send read.update', error);\n      }\n    }\n  }, [sendFrame]);\n\n  const applyConversationMetadata = useCallback((metadata: ConversationMetadata | null) => {\n    conversationMetadataRef.current = metadata;\n    hasLoggedIntentRef.current = Boolean(metadata?.first_message_intent);\n    setConversationMetadata(metadata);\n    onConversationMetadataUpdated?.(metadata);\n  }, [onConversationMetadataUpdated]);\n\n  const updateConversationMetadata = useCallback(async (\n    patch: ConversationMetadata,\n    targetConversationId?: string\n  ) => {\n    if (!sessionReady) {\n      return null;\n    }\n    const activeConversationId = targetConversationId ?? conversationId;\n    const practiceKey = practiceId;\n    if (!activeConversationId || !practiceKey) {\n      return null;\n    }\n    const runUpdate = async () => {\n      const current = conversationMetadataRef.current ?? {};\n      const nextMetadata = { ...current, ...patch };\n      applyConversationMetadata(nextMetadata);\n      const updated = await patchConversationMetadata(activeConversationId, practiceKey, nextMetadata);\n      applyConversationMetadata(updated?.user_info ?? nextMetadata);\n      return updated;\n    };\n\n    const queued = metadataUpdateQueueRef.current.then(runUpdate, runUpdate);\n    metadataUpdateQueueRef.current = queued.catch(() => null);\n    return queued;\n  }, [applyConversationMetadata, conversationId, practiceId, sessionReady]);\n\n  const intakeConversationState = useMemo(\n    () => conversationMetadata?.intakeConversationState ?? null,\n    [conversationMetadata]\n  );\n  const slimContactDraft = useMemo(\n    () => normalizeSlimContactDraft(conversationMetadata?.intakeSlimContactDraft),\n    [conversationMetadata?.intakeSlimContactDraft]\n  );\n  const isAiBriefActive = conversationMetadata?.intakeAiBriefActive === true;\n\n  const applyIntakeFields = useCallback(async (fields: IntakeFieldsPayload) => {\n    const current = conversationMetadataRef.current?.intakeConversationState ?? initialIntakeState;\n    const next: IntakeConversationState = { ...current };\n    if (typeof fields.practiceArea === 'string') next.practiceArea = fields.practiceArea;\n    if (typeof fields.practiceAreaName === 'string') next.practiceAreaName = fields.practiceAreaName;\n    if (typeof fields.description === 'string') next.description = fields.description;\n    if (typeof fields.urgency === 'string') next.urgency = fields.urgency;\n    if (typeof fields.opposingParty === 'string') next.opposingParty = fields.opposingParty;\n    if (typeof fields.city === 'string') next.city = fields.city;\n    if (typeof fields.state === 'string') next.state = fields.state;\n    if (typeof fields.postalCode === 'string') next.postalCode = fields.postalCode;\n    if (typeof fields.country === 'string') next.country = fields.country;\n    if (typeof fields.addressLine1 === 'string') next.addressLine1 = fields.addressLine1;\n    if (typeof fields.addressLine2 === 'string') next.addressLine2 = fields.addressLine2;\n    if (typeof fields.desiredOutcome === 'string') next.desiredOutcome = fields.desiredOutcome;\n    if (typeof fields.courtDate === 'string') next.courtDate = fields.courtDate;\n    if (typeof fields.income === 'string') next.income = fields.income;\n    if (typeof fields.householdSize === 'number') next.householdSize = fields.householdSize;\n    if (typeof fields.hasDocuments === 'boolean') next.hasDocuments = fields.hasDocuments;\n    if (Array.isArray(fields.eligibilitySignals)) {\n      next.eligibilitySignals = fields.eligibilitySignals.filter((value): value is string => typeof value === 'string');\n    }\n    if (fields.caseStrength === 'needs_more_info' || fields.caseStrength === 'developing' || fields.caseStrength === 'strong') {\n      next.caseStrength = fields.caseStrength;\n    }\n    if (fields.missingSummary !== undefined) {\n      next.missingSummary = fields.missingSummary ?? null;\n    }\n    next.turnCount = (current.turnCount ?? 0) + 1;\n    if (next.caseStrength === 'developing' || next.caseStrength === 'strong') {\n      next.ctaShown = true;\n    }\n    if (current.ctaResponse === 'not_yet') {\n      next.ctaResponse = null;\n    }\n\n    await updateConversationMetadata({\n      intakeConversationState: next\n    });\n  }, [updateConversationMetadata]);\n\n  const fetchConversationMetadata = useCallback(async (\n    signal?: AbortSignal,\n    targetConversationId?: string\n  ) => {\n    if (!sessionReady) return;\n    const activeConversationId = targetConversationId ?? conversationId;\n    const practiceKey = practiceId;\n    if (!activeConversationId || !practiceKey) return;\n    const headers: Record<string, string> = { 'Content-Type': 'application/json' };\n    const response = await fetch(\n      `/api/conversations/${encodeURIComponent(activeConversationId)}?practiceId=${encodeURIComponent(practiceKey)}`,\n      {\n        method: 'GET',\n        headers,\n        credentials: 'include',\n        signal\n      }\n    );\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({})) as { error?: string };\n      throw new Error(errorData.error || `HTTP ${response.status}`);\n    }\n    const data = await response.json() as { success: boolean; data?: { user_info?: ConversationMetadata | null } };\n    if (signal?.aborted || isDisposedRef.current) return;\n    if (activeConversationId !== conversationIdRef.current) return;\n    applyConversationMetadata(data.data?.user_info ?? null);\n  }, [applyConversationMetadata, conversationId, practiceId, sessionReady]);\n\n  // Convert API message to UI message\n  const toUIMessage = useCallback((msg: ConversationMessage): ChatMessageUI => {\n    const senderId = typeof msg.user_id === 'string' && msg.user_id.trim().length > 0\n      ? msg.user_id\n      : null;\n    const normalizedRole = msg.role === 'assistant'\n      ? 'assistant'\n      : msg.role === 'system'\n        ? 'system'\n        : 'user';\n    const isUser = normalizedRole === 'user'\n      && Boolean(senderId && currentUserId && senderId === currentUserId);\n    const paymentRequest = parsePaymentRequestMetadata(msg.metadata);\n\n    return {\n      id: msg.id,\n      role: normalizedRole,\n      content: msg.content,\n      reply_to_message_id: msg.reply_to_message_id ?? null,\n      timestamp: new Date(msg.created_at).getTime(),\n      metadata: {\n        ...(msg.metadata || {}),\n        __client_id: msg.client_id\n      },\n      userId: senderId,\n      files: msg.metadata?.attachments ? (msg.metadata.attachments as string[]).map((fileId: string) => ({\n        id: fileId,\n        name: 'File',\n        size: 0,\n        type: 'application/octet-stream',\n        url: buildFileUrl(fileId),\n      })) : undefined,\n      paymentRequest,\n      isUser\n    };\n  }, [currentUserId]);\n\n  const applyServerMessages = useCallback((incoming: ConversationMessage[]) => {\n    if (incoming.length === 0 || isDisposedRef.current) {\n      return;\n    }\n\n    let nextLatestSeq = lastSeqRef.current;\n    const replacements = new Map<string, ChatMessageUI>();\n    const additions: ChatMessageUI[] = [];\n\n    for (const message of incoming) {\n      if (!message?.id) {\n        continue;\n      }\n      const seqValue = typeof message.seq === 'number' && Number.isFinite(message.seq)\n        ? message.seq\n        : null;\n      if (seqValue !== null) {\n        nextLatestSeq = Math.max(nextLatestSeq, seqValue);\n      }\n      if (messageIdSetRef.current.has(message.id)) {\n        continue;\n      }\n      messageIdSetRef.current.add(message.id);\n      const uiMessage = toUIMessage(message);\n      const pendingId = pendingClientMessageRef.current.get(message.client_id);\n      if (pendingId) {\n        replacements.set(pendingId, uiMessage);\n        pendingClientMessageRef.current.delete(message.client_id);\n      } else {\n        additions.push(uiMessage);\n      }\n    }\n\n    if (replacements.size === 0 && additions.length === 0) {\n      if (nextLatestSeq > lastSeqRef.current) {\n        lastSeqRef.current = nextLatestSeq;\n        sendReadUpdate(nextLatestSeq);\n      }\n      return;\n    }\n\n    lastSeqRef.current = nextLatestSeq;\n\n    setMessages(prev => {\n      let next = prev;\n      if (replacements.size > 0) {\n        next = next.map(message => {\n          const replacement = replacements.get(message.id);\n          if (!replacement) {\n            return message;\n          }\n          return {\n            ...replacement,\n            // Keep optimistic timestamp to avoid reorder flicker when server ts arrives.\n            timestamp: message.timestamp,\n            files: replacement.files ?? message.files,\n            reactions: replacement.reactions ?? message.reactions\n          } as ChatMessageUI;\n        });\n      } else {\n        next = [...next];\n      }\n\n      if (additions.length > 0) {\n        next = [...next, ...additions];\n      }\n\n      return next.sort((a, b) => a.timestamp - b.timestamp);\n    });\n\n    sendReadUpdate(nextLatestSeq);\n  }, [sendReadUpdate, toUIMessage]);\n\n  const ingestServerMessages = useCallback((incoming: ConversationMessage[]) => {\n    applyServerMessages(incoming);\n  }, [applyServerMessages]);\n\n  const handleMessageAck = useCallback((data: Record<string, unknown>) => {\n    const clientId = typeof data.client_id === 'string' ? data.client_id : null;\n    const messageId = typeof data.message_id === 'string' ? data.message_id : null;\n    const seqValue = typeof data.seq === 'number' ? data.seq : Number(data.seq);\n    const serverTs = typeof data.server_ts === 'string' ? data.server_ts : null;\n    if (!clientId || !messageId || !serverTs || !Number.isFinite(seqValue)) {\n      return;\n    }\n\n    const pending = pendingAckRef.current.get(clientId);\n    if (pending) {\n      pending.resolve({ messageId, seq: seqValue, serverTs, clientId });\n      pendingAckRef.current.delete(clientId);\n    }\n\n    messageIdSetRef.current.add(messageId);\n    lastSeqRef.current = Math.max(lastSeqRef.current, seqValue);\n\n    const pendingId = pendingClientMessageRef.current.get(clientId);\n    if (!pendingId) {\n      sendReadUpdate(lastSeqRef.current);\n      return;\n    }\n\n    pendingClientMessageRef.current.delete(clientId);\n    setMessages(prev => prev.map(message => {\n      if (message.id !== pendingId) {\n        return message;\n      }\n      return {\n        ...message,\n        id: messageId\n      } as ChatMessageUI;\n    }));\n    sendReadUpdate(lastSeqRef.current);\n  }, [sendReadUpdate]);\n\n  const handleMessageNew = useCallback((data: Record<string, unknown>) => {\n    const conversationIdValue = typeof data.conversation_id === 'string' ? data.conversation_id : null;\n    const activeConversationId = conversationIdRef.current;\n    if (!conversationIdValue || conversationIdValue !== activeConversationId) {\n      return;\n    }\n\n    const messageId = typeof data.message_id === 'string' ? data.message_id : null;\n    const clientId = typeof data.client_id === 'string' ? data.client_id : null;\n    const content = typeof data.content === 'string' ? data.content : null;\n    const role = typeof data.role === 'string' ? data.role : null;\n    const serverTs = typeof data.server_ts === 'string' ? data.server_ts : null;\n    const seqValue = typeof data.seq === 'number' ? data.seq : Number(data.seq);\n    if (!messageId || !clientId || !content || !serverTs || !Number.isFinite(seqValue)) {\n      return;\n    }\n\n    const replyToMessageId = typeof data.reply_to_message_id === 'string'\n      ? data.reply_to_message_id\n      : null;\n    const practiceIdValue = practiceIdRef.current ?? '';\n    const metadata = typeof data.metadata === 'object' && data.metadata !== null && !Array.isArray(data.metadata)\n      ? data.metadata as Record<string, unknown>\n      : null;\n    const attachments = Array.isArray(data.attachments)\n      ? (data.attachments as string[]).filter((item) => typeof item === 'string')\n      : [];\n\n    const message: ConversationMessage = {\n      id: messageId,\n      conversation_id: conversationIdValue,\n      practice_id: practiceIdValue,\n      user_id: typeof data.user_id === 'string' ? data.user_id : '',\n      role: role === 'assistant' ? 'assistant' : role === 'system' ? 'system' : 'user',\n      content,\n      reply_to_message_id: replyToMessageId,\n      metadata: metadata ?? (attachments.length > 0 ? { attachments } : null),\n      client_id: clientId,\n      seq: seqValue,\n      server_ts: serverTs,\n      token_count: null,\n      created_at: serverTs\n    };\n\n    applyServerMessages([message]);\n  }, [applyServerMessages]);\n\n  const updateMessageReactions = useCallback((messageId: string, reactions: MessageReaction[]) => {\n    setMessages(prev => prev.map(message => (\n      message.id === messageId\n        ? { ...message, reactions } as ChatMessageUI\n        : message\n    )));\n  }, []);\n\n  const getOptimisticReactions = useCallback((\n    reactions: MessageReaction[],\n    emoji: string,\n    shouldAdd: boolean\n  ): MessageReaction[] => {\n    const next = [...reactions];\n    const index = next.findIndex((reaction) => reaction.emoji === emoji);\n    if (index === -1 && shouldAdd) {\n      next.push({ emoji, count: 1, reactedByMe: true });\n      return next;\n    }\n    if (index === -1) {\n      return next;\n    }\n    const current = next[index];\n    const nextCount = Math.max(0, (current.count ?? 0) + (shouldAdd ? 1 : -1));\n    if (!shouldAdd && nextCount === 0) {\n      next.splice(index, 1);\n      return next;\n    }\n    next[index] = {\n      ...current,\n      count: nextCount,\n      reactedByMe: shouldAdd\n    };\n    return next;\n  }, []);\n\n  const handleReactionUpdate = useCallback((data: Record<string, unknown>) => {\n    const conversationIdValue = typeof data.conversation_id === 'string' ? data.conversation_id : null;\n    const activeConversationId = conversationIdRef.current;\n    if (!conversationIdValue || conversationIdValue !== activeConversationId) {\n      return;\n    }\n\n    const messageId = typeof data.message_id === 'string' ? data.message_id : null;\n    const emoji = typeof data.emoji === 'string' ? data.emoji : null;\n    const action = typeof data.action === 'string' ? data.action : null;\n    const actorId = typeof data.user_id === 'string' ? data.user_id : null;\n    const countValue = typeof data.count === 'number' ? data.count : Number(data.count);\n    const count = Number.isFinite(countValue) ? countValue : null;\n\n    if (!messageId || !emoji || (action !== 'add' && action !== 'remove')) {\n      return;\n    }\n\n    reactionLoadedRef.current.add(messageId);\n\n    setMessages(prev => {\n      let changed = false;\n      const next = prev.map(message => {\n        if (message.id !== messageId) {\n          return message;\n        }\n        const existing = message.reactions ?? [];\n        const index = existing.findIndex(reaction => reaction.emoji === emoji);\n        const current = index >= 0 ? existing[index] : null;\n        const shouldReact = action === 'add';\n        const reactedByMe = actorId && currentUserId\n          ? actorId === currentUserId\n            ? shouldReact\n            : current?.reactedByMe ?? false\n          : current?.reactedByMe ?? false;\n\n        const nextCount = count !== null\n          ? Math.max(0, count)\n          : Math.max(0, (current?.count ?? 0) + (shouldReact ? 1 : -1));\n\n        if (!current && !shouldReact) {\n          return message;\n        }\n\n        let updated = existing;\n        if (nextCount <= 0) {\n          if (index === -1) {\n            return message;\n          }\n          updated = existing.filter((reaction) => reaction.emoji !== emoji);\n        } else if (index === -1) {\n          updated = [...existing, { emoji, count: nextCount, reactedByMe }];\n        } else {\n          updated = existing.map((reaction, reactionIndex) => (\n            reactionIndex === index\n              ? { ...reaction, count: nextCount, reactedByMe }\n              : reaction\n          ));\n        }\n\n        if (updated === existing) {\n          return message;\n        }\n\n        changed = true;\n        return { ...message, reactions: updated } as ChatMessageUI;\n      });\n\n      return changed ? next : prev;\n    });\n  }, [currentUserId]);\n\n  const fetchGapMessages = useCallback(async (fromSeq: number, latestSeq: number) => {\n    const activeConversationId = conversationIdRef.current;\n    const activePracticeId = practiceIdRef.current;\n    if (!activeConversationId || !activePracticeId) {\n      return;\n    }\n\n    let nextSeq: number | null = fromSeq;\n    let targetLatest = latestSeq;\n    let attempts = 0;\n\n    while (nextSeq !== null && nextSeq <= targetLatest) {\n      if (\n        isDisposedRef.current ||\n        conversationIdRef.current !== activeConversationId ||\n        practiceIdRef.current !== activePracticeId\n      ) {\n        return;\n      }\n      try {\n        const params = new URLSearchParams({\n          practiceId: activePracticeId,\n          from_seq: String(nextSeq),\n          limit: String(GAP_FETCH_LIMIT)\n        });\n\n        const response = await fetch(`${getConversationMessagesEndpoint(activeConversationId)}?${params.toString()}`, {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          credentials: 'include'\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json().catch(() => ({})) as { error?: string };\n          throw new Error(errorData.error || `HTTP ${response.status}`);\n        }\n\n        const data = await response.json() as {\n          success: boolean;\n          error?: string;\n          data?: {\n            messages: ConversationMessage[];\n            latest_seq?: number;\n            next_from_seq?: number | null;\n          };\n        };\n        if (!data.success || !data.data) {\n          throw new Error(data.error || 'Failed to fetch message gap');\n        }\n\n        if (\n          isDisposedRef.current ||\n          conversationIdRef.current !== activeConversationId ||\n          practiceIdRef.current !== activePracticeId\n        ) {\n          return;\n        }\n\n        applyServerMessages(data.data.messages ?? []);\n        if (typeof data.data.latest_seq === 'number') {\n          targetLatest = data.data.latest_seq;\n        }\n        nextSeq = data.data.next_from_seq ?? null;\n        attempts = 0;\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'Failed to recover message gap';\n        attempts += 1;\n        if (attempts < MAX_GAP_FETCH_ATTEMPTS) {\n          await new Promise(resolve => setTimeout(resolve, GAP_FETCH_RETRY_DELAY_MS * attempts));\n          continue;\n        }\n        onError?.(message);\n        return;\n      }\n    }\n  }, [applyServerMessages, onError]);\n\n  const clearReconnectTimer = useCallback(() => {\n    if (reconnectTimerRef.current) {\n      clearTimeout(reconnectTimerRef.current);\n      reconnectTimerRef.current = null;\n    }\n  }, []);\n\n  const scheduleReconnect = useCallback((targetConversationId: string) => {\n    if (isDisposedRef.current || isClosingSocketRef.current) {\n      return;\n    }\n    if (!sessionReadyRef.current || !targetConversationId) {\n      return;\n    }\n    if (conversationIdRef.current !== targetConversationId) {\n      return;\n    }\n    if (reconnectTimerRef.current) {\n      return;\n    }\n    const nextAttempt = reconnectAttemptRef.current + 1;\n    if (nextAttempt > RECONNECT_MAX_ATTEMPTS) {\n      return;\n    }\n    reconnectAttemptRef.current = nextAttempt;\n    const backoff = Math.min(RECONNECT_BASE_DELAY_MS * 2 ** (nextAttempt - 1), RECONNECT_MAX_DELAY_MS);\n    const jitter = Math.floor(Math.random() * 250);\n    reconnectTimerRef.current = globalThis.setTimeout(() => {\n      reconnectTimerRef.current = null;\n      if (isDisposedRef.current || isClosingSocketRef.current) {\n        return;\n      }\n      if (!sessionReadyRef.current || conversationIdRef.current !== targetConversationId) {\n        return;\n      }\n      connectChatRoomRef.current(targetConversationId);\n    }, backoff + jitter);\n  }, []);\n\n\n  const connectChatRoom = useCallback((targetConversationId: string) => {\n    if (!sessionReady) {\n      return;\n    }\n    if (!targetConversationId) {\n      return;\n    }\n    clearReconnectTimer();\n    if (typeof WebSocket === 'undefined') {\n      onError?.('WebSocket is not available in this environment.');\n      return;\n    }\n    if (\n      wsRef.current &&\n      socketConversationIdRef.current === targetConversationId &&\n      wsRef.current.readyState === WebSocket.OPEN &&\n      isSocketReadyRef.current\n    ) {\n      return;\n    }\n\n    isClosingSocketRef.current = false;\n    socketSessionRef.current += 1;\n    const sessionId = socketSessionRef.current;\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    socketConversationIdRef.current = targetConversationId;\n    initSocketReadyPromise();\n\n    const ws = new WebSocket(getConversationWsEndpoint(targetConversationId));\n    wsRef.current = ws;\n\n    ws.addEventListener('open', () => {\n      reconnectAttemptRef.current = 0;\n      clearReconnectTimer();\n      ws.send(JSON.stringify({\n        type: 'auth',\n        data: {\n          protocol_version: CHAT_PROTOCOL_VERSION,\n          client_info: { platform: 'web' }\n        }\n      }));\n    });\n\n    ws.addEventListener('message', (event) => {\n      if (socketSessionRef.current !== sessionId || typeof event.data !== 'string') {\n        return;\n      }\n      let frame: { type?: string; data?: Record<string, unknown>; request_id?: string };\n      try {\n        frame = JSON.parse(event.data) as { type?: string; data?: Record<string, unknown>; request_id?: string };\n      } catch {\n        return;\n      }\n      if (!frame.type || !frame.data || typeof frame.data !== 'object') {\n        return;\n      }\n\n      switch (frame.type) {\n        case 'auth.ok': {\n          resolveSocketReady();\n          try {\n            sendFrame({\n              type: 'resume',\n              data: {\n                conversation_id: targetConversationId,\n                last_seq: lastSeqRef.current\n              }\n            });\n          } catch (error) {\n            if (import.meta.env.DEV) {\n              console.warn('[ChatRoom] Failed to send resume', error);\n            }\n          }\n          return;\n        }\n        case 'auth.error': {\n          const message = typeof frame.data.message === 'string' ? frame.data.message : 'Chat protocol error';\n          onError?.(message);\n          rejectSocketReady(new Error(message));\n          isClosingSocketRef.current = true;\n          ws.close();\n          return;\n        }\n        case 'resume.ok': {\n          const latestSeq = Number(frame.data.latest_seq);\n          if (Number.isFinite(latestSeq)) {\n            lastSeqRef.current = Math.max(lastSeqRef.current, latestSeq);\n            sendReadUpdate(lastSeqRef.current);\n          }\n          return;\n        }\n        case 'resume.gap': {\n          const fromSeq = Number(frame.data.from_seq);\n          const latestSeq = Number(frame.data.latest_seq);\n          if (Number.isFinite(fromSeq) && Number.isFinite(latestSeq)) {\n            fetchGapMessages(fromSeq, latestSeq).catch((error) => {\n              if (import.meta.env.DEV) {\n                console.warn('[ChatRoom] Gap fetch failed', error);\n              }\n            });\n          }\n          return;\n        }\n        case 'message.new':\n          handleMessageNew(frame.data);\n          return;\n        case 'message.ack':\n          handleMessageAck(frame.data);\n          return;\n        case 'reaction.update':\n          handleReactionUpdate(frame.data);\n          return;\n        case 'error': {\n          const message = typeof frame.data.message === 'string' ? frame.data.message : 'Chat error';\n          const requestId = typeof frame.request_id === 'string' ? frame.request_id : null;\n          if (requestId) {\n            const pending = pendingAckRef.current.get(requestId);\n            if (pending) {\n              pending.reject(new Error(message));\n              pendingAckRef.current.delete(requestId);\n            }\n          }\n          onError?.(message);\n          return;\n        }\n        default:\n          return;\n      }\n    });\n\n    ws.addEventListener('close', () => {\n      if (socketSessionRef.current !== sessionId) {\n        return;\n      }\n      isSocketReadyRef.current = false;\n      rejectSocketReady(new Error('Chat connection closed'));\n      flushPendingAcks(new Error('Chat connection closed'));\n      if (wsRef.current === ws) {\n        wsRef.current = null;\n        socketConversationIdRef.current = null;\n      }\n      if (!isClosingSocketRef.current && conversationIdRef.current === targetConversationId) {\n        if (import.meta.env.DEV) {\n          console.info('[ChatRoom] WebSocket closed; will reconnect on next action.');\n        }\n        scheduleReconnect(targetConversationId);\n      }\n    });\n\n    ws.addEventListener('error', (error) => {\n      if (import.meta.env.DEV) {\n        console.warn('[ChatRoom] WebSocket error', error);\n      }\n    });\n  }, [\n    clearReconnectTimer,\n    fetchGapMessages,\n    flushPendingAcks,\n    handleMessageAck,\n    handleMessageNew,\n    handleReactionUpdate,\n    initSocketReadyPromise,\n    onError,\n    rejectSocketReady,\n    resolveSocketReady,\n    scheduleReconnect,\n    sendFrame,\n    sendReadUpdate,\n    sessionReady\n  ]);\n\n  connectChatRoomRef.current = connectChatRoom;\n\n  const closeChatSocket = useCallback(() => {\n    isClosingSocketRef.current = true;\n    isSocketReadyRef.current = false;\n    rejectSocketReady(new Error('Chat connection closed'));\n    flushPendingAcks(new Error('Chat connection closed'));\n    clearReconnectTimer();\n    reconnectAttemptRef.current = 0;\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    socketConversationIdRef.current = null;\n  }, [clearReconnectTimer, flushPendingAcks, rejectSocketReady]);\n\n  const sendMessageOverWs = useCallback(async (\n    content: string,\n    attachments: FileAttachment[],\n    metadata?: Record<string, unknown> | null,\n    replyToMessageId?: string | null\n  ) => {\n    const effectivePracticeId = (practiceIdRef.current ?? '').trim();\n    const activeConversationId = conversationIdRef.current;\n    if (!effectivePracticeId) {\n      if (import.meta.env.DEV) {\n        console.warn('[useMessageHandling] sendMessageOverWs aborted: missing practiceId');\n      }\n      return;\n    }\n    if (!activeConversationId) {\n      if (import.meta.env.DEV) {\n        console.warn('[useMessageHandling] sendMessageOverWs aborted: missing conversationId');\n      }\n      return;\n    }\n    if (!content.trim()) {\n      throw new Error('Message cannot be empty.');\n    }\n\n    const clientId = createClientId();\n    const tempId = `temp-${clientId}`;\n    const tempMessage: ChatMessageUI = {\n      id: tempId,\n      content,\n      isUser: true,\n      role: 'user',\n      timestamp: Date.now(),\n      userId: currentUserId,\n      reply_to_message_id: replyToMessageId ?? null,\n      metadata: {\n        ...(metadata || {}),\n        __client_id: clientId\n      },\n      files: attachments\n    };\n\n    setMessages(prev => [...prev, tempMessage]);\n    setMessagesReady(true);\n    pendingClientMessageRef.current.set(clientId, tempId);\n\n    const ackPromise = new Promise<{ messageId: string; seq: number; serverTs: string; clientId: string }>((resolve, reject) => {\n      pendingAckRef.current.set(clientId, { resolve, reject });\n    });\n\n    const attachmentIds = attachments.map(att => att.id || att.storageKey || '').filter(Boolean);\n\n    try {\n      if (import.meta.env.DEV) {\n        console.info('[useMessageHandling] sendMessageOverWs start', {\n          conversationId: activeConversationId,\n          practiceId: effectivePracticeId,\n          contentLength: content.length,\n          attachments: attachmentIds.length,\n          hasMetadata: Boolean(metadata)\n        });\n      }\n      await waitForSessionReady();\n      if (!isSocketReadyRef.current || socketConversationIdRef.current !== activeConversationId) {\n        if (import.meta.env.DEV) {\n          console.info('[useMessageHandling] connecting chat room', {\n            socketReady: isSocketReadyRef.current,\n            socketConversationId: socketConversationIdRef.current,\n            targetConversationId: activeConversationId\n          });\n        }\n        connectChatRoomRef.current(activeConversationId);\n      }\n      await waitForSocketReady();\n      if (import.meta.env.DEV) {\n        console.info('[useMessageHandling] sending WS frame message.send', {\n          conversationId: activeConversationId,\n          clientId,\n          hasReply: Boolean(replyToMessageId),\n          attachments: attachmentIds.length\n        });\n      }\n      sendFrame({\n        type: 'message.send',\n        data: {\n          conversation_id: activeConversationId,\n          client_id: clientId,\n          content,\n          ...(replyToMessageId ? { reply_to_message_id: replyToMessageId } : {}),\n          ...(attachmentIds.length > 0 ? { attachments: attachmentIds } : {}),\n          ...(metadata ? { metadata } : {})\n        },\n        request_id: clientId\n      });\n    } catch (error) {\n      pendingAckRef.current.delete(clientId);\n      pendingClientMessageRef.current.delete(clientId);\n      setMessages(prev => prev.filter(message => message.id !== tempId));\n      throw error;\n    }\n\n    return ackPromise.catch((error) => {\n      pendingClientMessageRef.current.delete(clientId);\n      setMessages(prev => prev.filter(message => message.id !== tempId));\n      throw error;\n    });\n  }, [currentUserId, sendFrame, waitForSessionReady, waitForSocketReady]);\n\n  const pendingIntakeInitRef = useRef<Promise<void> | null>(null);\n\n  // Main message sending function\n  const sendMessage = useCallback(async (\n    message: string,\n    attachments: FileAttachment[] = [],\n    replyToMessageId?: string | null\n  ) => {\n    // Debug hook for test environment (development only)\n    if (import.meta.env.MODE !== 'production' && typeof window !== 'undefined' && window.__DEBUG_SEND_MESSAGE__) {\n      window.__DEBUG_SEND_MESSAGE__(message, attachments);\n    }\n\n    const activeMode = conversationMetadataRef.current?.mode ?? mode;\n    const shouldUseAi = activeMode === 'ASK_QUESTION' || activeMode === 'REQUEST_CONSULTATION';\n    const shouldClassifyIntent = activeMode === 'ASK_QUESTION';\n    const hasUserMessages = messages.some((msg) => msg.isUser);\n    const trimmedMessage = message.trim();\n\n    if (activeMode === 'REQUEST_CONSULTATION' && !conversationMetadataRef.current?.intakeConversationState) {\n      if (pendingIntakeInitRef.current) {\n         try {\n           await pendingIntakeInitRef.current;\n         } catch (error) {\n           console.error('Failed to await pending intake init', error);\n         }\n      } else {\n        const initPromise = updateConversationMetadata({ intakeConversationState: initialIntakeState });\n        pendingIntakeInitRef.current = initPromise as unknown as Promise<void>;\n        try {\n          await initPromise;\n        } finally {\n          pendingIntakeInitRef.current = null;\n        }\n      }\n    }\n\n    try {\n      await sendMessageOverWs(message, attachments, undefined, replyToMessageId ?? null);\n\n      if (!shouldUseAi || trimmedMessage.length === 0) {\n        return;\n      }\n\n      const resolvedPracticeId = (practiceId ?? '').trim();\n      if (!resolvedPracticeId) {\n        return;\n      }\n\n      if (shouldClassifyIntent && !hasLoggedIntentRef.current && !hasUserMessages) {\n        intentAbortRef.current?.abort();\n        const intentController = new AbortController();\n        intentAbortRef.current = intentController;\n        const intentConversationId = conversationId;\n        const intentPracticeId = resolvedPracticeId;\n        let intentResponse: Response | null = null;\n        try {\n          intentResponse = await fetch('/api/ai/intent', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            credentials: 'include',\n            signal: intentController.signal,\n            body: JSON.stringify({\n              conversationId,\n              practiceId: resolvedPracticeId,\n              message: trimmedMessage\n            })\n          });\n        } catch (intentError) {\n          if (intentError instanceof Error && intentError.name === 'AbortError') {\n            intentResponse = null;\n          } else {\n            throw intentError;\n          }\n        }\n\n        if (intentResponse?.ok) {\n          const intentData = await intentResponse.json() as FirstMessageIntent;\n          if (intentController.signal.aborted) {\n            return;\n          }\n          if (conversationIdRef.current !== intentConversationId || resolvedPracticeId !== intentPracticeId) {\n            return;\n          }\n          if (hasLoggedIntentRef.current) {\n            return;\n          }\n          hasLoggedIntentRef.current = true;\n          try {\n            await updateConversationMetadata({\n              first_message_intent: intentData\n            }, intentConversationId);\n          } catch (intentError) {\n            console.warn('[useMessageHandling] Failed to persist intent classification', intentError);\n          }\n        } else if (intentResponse) {\n          console.warn('[useMessageHandling] Intent classification request failed', {\n            status: intentResponse.status\n          });\n        }\n      }\n\n      const aiMessages = [\n        ...messages\n          .filter((msg) =>\n            msg.role === 'user' ||\n            msg.role === 'assistant' ||\n            (msg.role === 'system' && msg.metadata?.source === 'ai')\n          )\n          .map((msg) => ({\n            role: msg.role === 'system' ? 'assistant' : msg.role,\n            content: msg.content\n          })),\n        { role: 'user' as const, content: trimmedMessage }\n      ];\n\n      const resolvedPracticeSlug = (practiceSlug ?? '').trim() || undefined;\n      const intakeSubmitted = messages.some((msg) => msg.isUser && msg.metadata?.isContactFormSubmission);\n      const aiResponse = await fetch('/api/ai/chat', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        credentials: 'include',\n        body: JSON.stringify({\n          conversationId,\n          practiceId: resolvedPracticeId,\n          practiceSlug: resolvedPracticeSlug,\n          mode: activeMode,\n          intakeSubmitted,\n          messages: aiMessages\n        })\n      });\n\n      if (!aiResponse.ok) {\n        const errorData = await aiResponse.json().catch(() => ({})) as { error?: string };\n        throw new Error(errorData.error || `HTTP ${aiResponse.status}`);\n      }\n\n      const aiData = await aiResponse.json() as { reply?: string; message?: ConversationMessage; intakeFields?: IntakeFieldsPayload | null };\n      if (aiData.intakeFields) {\n        await applyIntakeFields(aiData.intakeFields);\n      }\n      if (aiData.message) {\n        applyServerMessages([aiData.message]);\n        return;\n      }\n      const reply = (aiData.reply ?? '').trim();\n      if (!reply) {\n        throw new Error('AI response missing');\n      }\n      if (import.meta.env.DEV) {\n        console.warn('[useMessageHandling] AI returned reply without persisted message');\n      }\n      onError?.('Something went wrong. Please try again.');\n    } catch (error) {\n      console.error('Error sending message:', {\n        error,\n        errorType: typeof error,\n        errorMessage: error instanceof Error ? error.message : String(error),\n      });\n\n      const errorMessage = error instanceof Error && error.message\n        ? error.message\n        : \"Failed to send message. Please try again.\";\n\n      onError?.(errorMessage);\n    }\n  }, [\n    applyServerMessages,\n    applyIntakeFields,\n    conversationId,\n    messages,\n    mode,\n    practiceId,\n    practiceSlug,\n    onError,\n    sendMessageOverWs,\n    updateConversationMetadata\n  ]);\n\n  const handleIntakeCtaResponse = useCallback(async (response: 'ready' | 'not_yet') => {\n    const current = conversationMetadataRef.current?.intakeConversationState ?? initialIntakeState;\n    const next: IntakeConversationState = {\n      ...current,\n      ctaResponse: response,\n      ctaShown: true,\n      notYetCount: response === 'not_yet' ? (current.notYetCount ?? 0) + 1 : (current.notYetCount ?? 0)\n    };\n\n    await updateConversationMetadata({\n      intakeConversationState: next\n    });\n\n    if (response === 'ready') return;\n    try {\n      await sendMessage('Not yet', []);\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.warn('[Intake] Failed to send \"Not yet\" response', error);\n      }\n    }\n  }, [sendMessage, updateConversationMetadata]);\n\n  const resetIntakeCta = useCallback(async () => {\n    const current = conversationMetadataRef.current?.intakeConversationState ?? initialIntakeState;\n    const next: IntakeConversationState = {\n      ...current,\n      ctaResponse: null\n    };\n    await updateConversationMetadata({\n      intakeConversationState: next\n    });\n  }, [updateConversationMetadata]);\n\n  const handleSlimFormContinue = useCallback(async (draft: ContactData) => {\n    const nextDraft: SlimContactDraft = {\n      name: (draft.name ?? '').trim(),\n      email: (draft.email ?? '').trim(),\n      phone: (draft.phone ?? '').trim(),\n      city: (draft.city ?? '').trim(),\n      state: (draft.state ?? '').trim(),\n      ...(draft.opposingParty?.trim() ? { opposingParty: draft.opposingParty.trim() } : {}),\n      ...(draft.description?.trim() ? { description: draft.description.trim() } : {})\n    };\n    await updateConversationMetadata({\n      intakeSlimContactDraft: nextDraft,\n      intakeAiBriefActive: false\n    });\n\n    const practiceContextId = (practiceId ?? '').trim();\n    if (!conversationId || !practiceContextId) {\n      return;\n    }\n    const alreadyPosted = messagesRef.current.some((message) => message.metadata?.intakeDecisionPrompt === true);\n    if (alreadyPosted) {\n      return;\n    }\n\n    const rawDescription = nextDraft.description?.trim() || '_Not provided_';\n    const sanitizedName = sanitizeMarkdown(nextDraft.name);\n    const sanitizedLocation = sanitizeMarkdown(`${nextDraft.city}, ${nextDraft.state}`);\n    const sanitizedOpposingParty = nextDraft.opposingParty?.trim() \n      ? sanitizeMarkdown(nextDraft.opposingParty.trim())\n      : '_Not provided_';\n    const descriptionSummary = sanitizeDescriptionForCodeBlock(rawDescription);\n    \n    // PII Redaction: rely on intakeSlimContactDraft for canonical data, redact in system message\n    const lines = [\n      '### Contact info received',\n      '',\n      '**Contact details**',\n      `- **Name:** ${sanitizedName}`,\n      '- **Email:** ***REDACTED***',\n      '- **Phone:** ***REDACTED***',\n      `- **Location:** ${sanitizedLocation}`,\n      '',\n      '**Case summary**',\n      `- **Opposing party:** ${sanitizedOpposingParty}`,\n      '- **Description:**',\n      '```',\n      descriptionSummary,\n      '```',\n      '',\n      'Would you like to **submit now**, or build a **stronger brief** first so we can match you with the right attorney?'\n    ];\n\n    try {\n      const persistedMessage = await postSystemMessage(conversationId, practiceContextId, {\n        clientId: 'system-intake-decision',\n        content: lines.join('\\n'),\n        metadata: {\n          systemMessageKey: 'intake_decision_prompt',\n          intakeDecisionPrompt: true\n        }\n      });\n      if (persistedMessage) {\n        applyServerMessages([persistedMessage]);\n      }\n    } catch (error) {\n      console.error('[Intake] Failed to persist decision prompt message', {\n        conversationId,\n        practiceContextId,\n        error\n      });\n    }\n  }, [applyServerMessages, conversationId, practiceId, updateConversationMetadata]);\n\n  const handleBuildBrief = useCallback(async () => {\n    const patch: ConversationMetadata = {\n      intakeAiBriefActive: true\n    };\n    if (conversationMetadataRef.current?.mode !== 'REQUEST_CONSULTATION') {\n      patch.mode = 'REQUEST_CONSULTATION';\n    }\n    const current = conversationMetadataRef.current?.intakeConversationState ?? initialIntakeState;\n    if (current.ctaResponse !== null) {\n      patch.intakeConversationState = {\n        ...current,\n        ctaResponse: null\n      };\n    }\n    await updateConversationMetadata(patch);\n    const locationParts = [slimContactDraft?.city, slimContactDraft?.state]\n      .map((value) => (typeof value === 'string' ? value.trim() : ''))\n      .filter((value) => value.length > 0);\n    const kickoffParts = [\n      'I want to build a stronger brief.'\n    ];\n    if (locationParts.length > 0) {\n      kickoffParts.push(`My location is ${locationParts.join(', ')}.`);\n    }\n    if (slimContactDraft?.opposingParty?.trim()) {\n      kickoffParts.push(`Opposing party: ${slimContactDraft.opposingParty.trim()}.`);\n    }\n    if (slimContactDraft?.description?.trim()) {\n      kickoffParts.push(`My current description: ${slimContactDraft.description.trim()}.`);\n    }\n    try {\n      await sendMessage(kickoffParts.join(' '), []);\n    } catch (error) {\n      console.error('[Intake] Failed to start brief-building conversation', error);\n    }\n  }, [sendMessage, slimContactDraft, updateConversationMetadata]);\n\n  // Handle contact form submission\n  const handleContactFormSubmit = useCallback(async (contactData: ContactData) => {\n    logDev('[useMessageHandling] handleContactFormSubmit called with:', {\n      name: !!contactData.name,\n      email: !!contactData.email,\n      phone: !!contactData.phone,\n      address: !!contactData.address,\n      opposingParty: !!contactData.opposingParty,\n      description: !!contactData.description\n    });\n    try {\n      // Format contact data as a structured message\n      const addressText = contactData.address \n        ? (() => {\n            const parts = [];\n            if (contactData.address.address) parts.push(contactData.address.address);\n            if (contactData.address.apartment) parts.push(contactData.address.apartment);\n            if (contactData.address.city && contactData.address.state && contactData.address.postalCode) {\n              parts.push(`${contactData.address.city}, ${contactData.address.state} ${contactData.address.postalCode}`);\n            } else {\n              if (contactData.address.city) parts.push(contactData.address.city);\n              if (contactData.address.state) parts.push(contactData.address.state);\n              if (contactData.address.postalCode) parts.push(contactData.address.postalCode);\n            }\n            return parts.length > 0 ? `Address: ${parts.join(', ')}` : '';\n          })()\n        : '';\n      const contactMessage = `Contact Information:\nName: ${contactData.name}\nEmail: ${contactData.email}\nPhone: ${contactData.phone}${addressText ? `\\n${addressText}` : ''}${contactData.opposingParty ? `\\nOpposing Party: ${contactData.opposingParty}` : ''}${contactData.description ? `\\nDescription: ${contactData.description}` : ''}`;\n\n      // Debug hook for test environment (development only, PII-safe)\n      if (import.meta.env.MODE === 'development' && typeof window !== 'undefined' && window.__DEBUG_CONTACT_FORM__) {\n        // Create sanitized payload with presence flags instead of raw PII\n        const sanitizedContactData = {\n          nameProvided: !!contactData.name,\n          emailProvided: !!contactData.email,\n          phoneProvided: !!contactData.phone,\n          addressProvided: !!contactData.address,\n          opposingPartyProvided: !!contactData.opposingParty,\n          descriptionProvided: !!contactData.description\n        };\n        \n        // Create redacted contact message indicating sections without actual values\n        const redactedContactMessage = `Contact Information:\nName: ${contactData.name ? '[PROVIDED]' : '[NOT PROVIDED]'}\nEmail: ${contactData.email ? '[PROVIDED]' : '[NOT PROVIDED]'}\nPhone: ${contactData.phone ? '[PROVIDED]' : '[NOT PROVIDED]'}\nAddress: ${contactData.address ? '[PROVIDED]' : '[NOT PROVIDED]'}${contactData.opposingParty ? '\\nOpposing Party: [PROVIDED]' : ''}${contactData.description ? '\\nDescription: [PROVIDED]' : ''}`;\n        \n        window.__DEBUG_CONTACT_FORM__(sanitizedContactData, redactedContactMessage);\n      }\n\n      // Send the contact information as a user message with metadata flag\n      // This metadata helps us detect that the contact form was submitted\n      if (!conversationId) {\n        throw new Error('Conversation ID is required');\n      }\n\n      const resolvedPracticeSlug = (practiceSlug ?? practiceId ?? '').trim();\n      if (!resolvedPracticeSlug) {\n        throw new Error('Practice slug is required to submit intake');\n      }\n\n      const intakeResult = await submitContactForm(\n        {\n          ...contactData,\n          sessionId: conversationId,\n          userId: currentUserId\n        },\n        resolvedPracticeSlug\n      );\n\n      const existingTitle = typeof conversationMetadataRef.current?.title === 'string'\n        ? conversationMetadataRef.current.title.trim()\n        : '';\n      if (!existingTitle) {\n        const nextTitle = contactData.name?.trim() || 'New Lead';\n        try {\n          await updateConversationMetadata({ title: nextTitle }, conversationId);\n        } catch (error) {\n          console.warn('[ContactForm] Failed to set conversation title', error);\n        }\n      }\n\n      const paymentDetails = intakeResult.intake;\n      const paymentRequired = paymentDetails?.paymentLinkEnabled === true;\n      const intakeUuid = typeof paymentDetails?.uuid === 'string' ? paymentDetails.uuid : undefined;\n\n      if (intakeUuid && isAnonymous) {\n        try {\n          const payload = { intakeUuid, practiceSlug: resolvedPracticeSlug, conversationId };\n          if (import.meta.env.DEV) {\n            console.info('[Intake] Triggering invite pre-auth', payload);\n          }\n          const result = await triggerIntakeInvitation(intakeUuid);\n          if (import.meta.env.DEV) {\n            console.info('[Intake] Invite triggered pre-auth', {\n              payload,\n              result\n            });\n          }\n          if (typeof window !== 'undefined') {\n            window.sessionStorage.setItem(`intakeInviteSent:${intakeUuid}`, 'true');\n          }\n        } catch (error) {\n          console.warn('[Intake] Failed to trigger invite pre-auth', {\n            intakeUuid,\n            error\n          });\n        }\n      }\n\n      const nextStepLine = paymentRequired\n        ? 'Next step: sign up to save your details and continue to payment.'\n        : 'Next step: sign up to save your details and finish your intake.';\n      const enrichedContactMessage = `${contactMessage}\\n\\nThanks! ${nextStepLine}`;\n\n      await sendMessageOverWs(enrichedContactMessage, [], {\n        // Mark this as a contact form submission without storing PII in metadata\n        isContactFormSubmission: true,\n        ...(intakeUuid ? { intakeUuid } : {}),\n        ...(paymentRequired ? { intakePaymentRequired: true } : {}),\n        authCta: {\n          label: 'Continue to finish intake'\n        }\n      }, null);\n\n      setMessages((prev) => {\n        const alreadyPresent = prev.some((message) =>\n          message.metadata?.isContactFormSubmission\n          && (intakeUuid ? message.metadata?.intakeUuid === intakeUuid : true)\n        );\n        if (alreadyPresent) {\n          return prev;\n        }\n        const fallbackMessage: ChatMessageUI = {\n          id: `fallback-contact-${Date.now()}`,\n          content: enrichedContactMessage,\n          isUser: true,\n          role: 'user',\n          timestamp: Date.now(),\n          userId: currentUserId,\n          reply_to_message_id: null,\n          metadata: {\n            isContactFormSubmission: true,\n            ...(intakeUuid ? { intakeUuid } : {}),\n            ...(paymentRequired ? { intakePaymentRequired: true } : {}),\n            authCta: { label: 'Continue to finish intake' }\n          }\n        };\n        return [...prev, fallbackMessage];\n      });\n\n      // Show success feedback\n      if (import.meta.env.DEV) {\n        console.log('[ContactForm] Successfully submitted contact information');\n      }\n\n      const clientSecret = paymentDetails?.clientSecret;\n      const paymentLinkUrl = paymentDetails?.paymentLinkUrl;\n      const checkoutSessionUrl = paymentDetails?.checkoutSessionUrl;\n      const checkoutSessionId = paymentDetails?.checkoutSessionId;\n      const hasClientSecret = typeof clientSecret === 'string' && clientSecret.trim().length > 0;\n      const hasPaymentLink = typeof paymentLinkUrl === 'string' && paymentLinkUrl.trim().length > 0;\n      const hasCheckoutSession = typeof checkoutSessionUrl === 'string' && checkoutSessionUrl.trim().length > 0;\n\n      if (import.meta.env.DEV) {\n        console.info('[Intake] Payment message decision', {\n          paymentRequired,\n          hasClientSecret,\n          hasPaymentLink,\n          hasCheckoutSession,\n          intakeUuid: paymentDetails?.uuid,\n          paymentLinkUrl,\n          checkoutSessionUrl,\n          clientSecretPresent: hasClientSecret,\n          paymentLinkPresent: hasPaymentLink\n        });\n      }\n\n      if (paymentRequired && (hasClientSecret || hasCheckoutSession || hasPaymentLink)) {\n        if (isAnonymous) {\n          if (import.meta.env.DEV) {\n            console.info('[Intake] Skipping payment message until user is authenticated', {\n              intakeUuid: paymentDetails?.uuid\n            });\n          }\n          return;\n        }\n        const paymentMessageId = `system-payment-${paymentDetails.uuid ?? Date.now()}`;\n        const paymentMessageExists = messages.some((msg) => msg.id === paymentMessageId);\n        if (!paymentMessageExists) {\n          const returnTo = typeof window !== 'undefined'\n            ? `${window.location.pathname}${window.location.search}`\n            : undefined;\n          const practiceContextId = practiceId || resolvedPracticeSlug;\n          const paymentUrl = buildIntakePaymentUrl({\n            intakeUuid: paymentDetails.uuid,\n            clientSecret: hasClientSecret ? clientSecret : undefined,\n            paymentLinkUrl: hasPaymentLink ? paymentLinkUrl : undefined,\n            checkoutSessionUrl: hasCheckoutSession ? checkoutSessionUrl : undefined,\n            checkoutSessionId: checkoutSessionId ?? undefined,\n            amount: typeof paymentDetails.amount === 'number' ? asMinor(paymentDetails.amount) : undefined,\n            currency: paymentDetails.currency,\n            practiceName: paymentDetails.organizationName,\n            practiceLogo: paymentDetails.organizationLogo,\n            practiceSlug: resolvedPracticeSlug,\n            practiceId: practiceContextId,\n            conversationId,\n            returnTo\n          });\n          const paymentRequestPayload = {\n            intakeUuid: paymentDetails.uuid,\n            clientSecret: hasClientSecret ? clientSecret : undefined,\n            paymentLinkUrl: hasPaymentLink ? paymentLinkUrl : undefined,\n            checkoutSessionUrl: hasCheckoutSession ? checkoutSessionUrl : undefined,\n            checkoutSessionId: checkoutSessionId ?? undefined,\n            amount: typeof paymentDetails.amount === 'number' ? asMinor(paymentDetails.amount) : undefined,\n            currency: paymentDetails.currency,\n            practiceName: paymentDetails.organizationName,\n            practiceLogo: paymentDetails.organizationLogo,\n            practiceSlug: resolvedPracticeSlug,\n            practiceId: practiceContextId,\n            conversationId,\n            returnTo\n          };\n\n          let persistenceStatus: 'idle' | 'success' | 'retry_queued' | 'failed' = 'idle';\n          if (conversationId && practiceContextId) {\n            try {\n              const persistedMessage = await postSystemMessage(conversationId, practiceContextId, {\n                clientId: paymentMessageId,\n                content: 'One more step: submit the consultation fee to complete your intake.',\n                metadata: {\n                  paymentRequest: paymentRequestPayload,\n                  paymentUrl\n                }\n              });\n              if (persistedMessage) {\n                applyServerMessages([persistedMessage]);\n                persistenceStatus = 'success';\n              }\n            } catch (error) {\n              console.warn('[Intake] Failed to persist payment message', error);\n              setPaymentRetryNotice({\n                message: 'Payment message delivery will be retried. You can also pay using the link below.',\n                paymentUrl\n              });\n              persistenceStatus = 'retry_queued';\n            }\n          }\n\n          if (persistenceStatus === 'idle') {\n            const message = 'Payment message could not be saved. Please retry.';\n            throw new Error(message);\n          }\n          if (import.meta.env.DEV) {\n            console.info('[Intake] Payment message enqueued', {\n              paymentMessageId,\n              intakeUuid: paymentDetails.uuid,\n              paymentUrl\n            });\n          }\n        }\n      } else if (!paymentRequired && paymentDetails?.uuid) {\n        // confirmIntakeLead removed - Worker handles conversion after payment\n\n      }\n    } catch (error) {\n      console.error('Error submitting contact form:', error);\n      onError?.(error instanceof Error ? error.message : 'Failed to submit contact information');\n      throw error; // Re-throw so form can handle the error state\n    }\n  }, [\n    conversationId,\n    practiceId,\n    practiceSlug,\n    onError,\n    logDev,\n    messages,\n    applyServerMessages,\n    sendMessageOverWs,\n    updateConversationMetadata,\n    currentUserId,\n    isAnonymous\n  ]);\n\n  const buildContactData = useCallback((draft: SlimContactDraft, intake: IntakeConversationState | null): ContactData => {\n    const mergedDescription = intake?.description?.trim() || draft.description?.trim() || '';\n    const mergedOpposingParty = intake?.opposingParty?.trim() || draft.opposingParty?.trim() || '';\n    return {\n      name: draft.name,\n      email: draft.email,\n      phone: draft.phone,\n      city: draft.city,\n      state: draft.state,\n      opposingParty: mergedOpposingParty || undefined,\n      description: mergedDescription || undefined,\n      address: {\n        city: draft.city,\n        state: draft.state\n      }\n    };\n  }, []);\n\n  const handleSubmitNow = useCallback(async () => {\n    if (!slimContactDraft) return;\n    const merged = buildContactData(\n      slimContactDraft,\n      conversationMetadataRef.current?.intakeConversationState ?? null\n    );\n    await handleContactFormSubmit(merged);\n  }, [buildContactData, handleContactFormSubmit, slimContactDraft]);\n\n  // Add message to the list\n  const addMessage = useCallback((message: ChatMessageUI) => {\n    setMessages(prev => [...prev, message]);\n  }, []);\n\n  // Update a specific message\n  const updateMessage = useCallback((messageId: string, updates: Partial<ChatMessageUI>) => {\n    setMessages(prev => prev.map(msg => \n      msg.id === messageId ? { ...msg, ...updates } as ChatMessageUI : msg\n    ));\n  }, []);\n\n  // Clear all messages\n  const clearMessages = useCallback(() => {\n    resetRealtimeState();\n    reactionFetchRef.current.clear();\n    reactionLoadedRef.current.clear();\n    setMessages([]);\n    setHasMoreMessages(false);\n    setNextCursor(null);\n    setIsLoadingMoreMessages(false);\n    setMessagesReady(false);\n    isLoadingMoreRef.current = false;\n  }, [resetRealtimeState]);\n\n  // Fetch messages from conversation\n  const fetchMessages = useCallback(async (\n    options?: {\n      signal?: AbortSignal;\n      targetConversationId?: string;\n      cursor?: string | null;\n      isLoadMore?: boolean;\n    }\n  ) => {\n    if (!sessionReady) {\n      return;\n    }\n    const {\n      signal,\n      targetConversationId,\n      cursor,\n      isLoadMore\n    } = options ?? {};\n    const activeConversationId = targetConversationId ?? conversationId;\n    if (!activeConversationId || !practiceId) {\n      if (DEBUG_MESSAGE_PAGINATION) {\n        console.info('[useMessageHandling][pagination] fetch skipped: missing conversation or practice', {\n          activeConversationId,\n          practiceId\n        });\n      }\n      return;\n    }\n\n    try {\n      const headers: Record<string, string> = { 'Content-Type': 'application/json' };\n\n      const params = new URLSearchParams({\n        practiceId,\n        limit: '50',\n      });\n      params.set('source', isLoadMore ? 'chat_load_more' : 'chat_initial');\n      if (cursor) {\n        params.set('cursor', cursor);\n      }\n\n      if (isLoadMore) {\n        if (DEBUG_MESSAGE_PAGINATION) {\n          console.info('[useMessageHandling][pagination] fetch start', {\n            activeConversationId,\n            cursor,\n            params: params.toString()\n          });\n        }\n        setIsLoadingMoreMessages(true);\n      }\n\n      const response = await fetch(`${getConversationMessagesEndpoint(activeConversationId)}?${params.toString()}`, {\n        method: 'GET',\n        headers,\n        credentials: 'include',\n        signal,\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({})) as { error?: string };\n        throw new Error(errorData.error || `HTTP ${response.status}`);\n      }\n\n      const data = await response.json() as {\n        success: boolean;\n        error?: string;\n        data?: {\n          messages: ConversationMessage[];\n          hasMore?: boolean;\n          cursor?: string | null;\n        };\n      };\n      if (!data.success || !data.data) {\n        throw new Error(data.error || 'Failed to fetch messages');\n      }\n\n      if (DEBUG_MESSAGE_PAGINATION) {\n        console.info('[useMessageHandling][pagination] fetch response', {\n          isLoadMore: Boolean(isLoadMore),\n          messageCount: data.data.messages?.length ?? 0,\n          hasMore: Boolean(data.data.hasMore),\n          nextCursor: data.data.cursor ?? null\n        });\n      }\n\n      if (!isDisposedRef.current && activeConversationId === conversationIdRef.current) {\n        if (isLoadMore) {\n          applyServerMessages(data.data.messages ?? []);\n        } else {\n          const uiMessages = data.data.messages.map(toUIMessage);\n          messageIdSetRef.current = new Set(data.data.messages.map((msg) => msg.id));\n          lastSeqRef.current = data.data.messages.reduce((max, msg) => Math.max(max, msg.seq), 0);\n          setMessages(prev => {\n            if (uiMessages.length === 0 && prev.length > 0) {\n              return prev;\n            }\n            return uiMessages;\n          });\n          setMessagesReady(true);\n          sendReadUpdate(lastSeqRef.current);\n        }\n        setHasMoreMessages(Boolean(data.data.hasMore));\n        setNextCursor(data.data.cursor ?? null);\n        if (DEBUG_MESSAGE_PAGINATION) {\n          console.info('[useMessageHandling][pagination] state updated', {\n            hasMoreMessages: Boolean(data.data.hasMore),\n            nextCursor: data.data.cursor ?? null\n          });\n        }\n      }\n    } catch (err) {\n      if (isDisposedRef.current) return;\n      if (err instanceof Error && err.name === 'AbortError') return;\n      if (DEBUG_MESSAGE_PAGINATION) {\n        console.info('[useMessageHandling][pagination] fetch error', {\n          message: err instanceof Error ? err.message : String(err),\n          cursor,\n          isLoadMore: Boolean(isLoadMore)\n        });\n      }\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch messages';\n      onError?.(errorMessage);\n    } finally {\n      if (!isDisposedRef.current && isLoadMore) {\n        setIsLoadingMoreMessages(false);\n      }\n    }\n  }, [conversationId, practiceId, toUIMessage, onError, sendReadUpdate, sessionReady, applyServerMessages]);\n\n  const loadMoreMessages = useCallback(async () => {\n    if (!nextCursor || isLoadingMoreMessages || isLoadingMoreRef.current) {\n      if (DEBUG_MESSAGE_PAGINATION) {\n        console.info('[useMessageHandling][pagination] loadMore skipped', {\n          hasCursor: Boolean(nextCursor),\n          nextCursor,\n          isLoadingMoreMessages,\n          internalLoading: isLoadingMoreRef.current\n        });\n      }\n      return;\n    }\n    if (DEBUG_MESSAGE_PAGINATION) {\n      console.info('[useMessageHandling][pagination] loadMore start', { nextCursor });\n    }\n    isLoadingMoreRef.current = true;\n    try {\n      await fetchMessages({ cursor: nextCursor, isLoadMore: true });\n    } finally {\n      isLoadingMoreRef.current = false;\n      if (DEBUG_MESSAGE_PAGINATION) {\n        console.info('[useMessageHandling][pagination] loadMore finished');\n      }\n    }\n  }, [fetchMessages, isLoadingMoreMessages, nextCursor]);\n\n  const requestMessageReactions = useCallback(async (messageId: string) => {\n    const conversationIdValue = conversationIdRef.current;\n    const practiceContextId = (practiceIdRef.current ?? '').trim();\n    if (!conversationIdValue || !practiceContextId) {\n      return null;\n    }\n    if (isTempMessageId(messageId)) {\n      return null;\n    }\n    if (reactionLoadedRef.current.has(messageId)) {\n      return null;\n    }\n\n    const existingRequest = reactionFetchRef.current.get(messageId);\n    if (existingRequest) {\n      return existingRequest;\n    }\n\n    const requestPromise = fetchMessageReactions(\n      conversationIdValue,\n      messageId,\n      practiceContextId\n    ).then((reactions) => {\n      updateMessageReactions(messageId, reactions);\n      reactionLoadedRef.current.add(messageId);\n      return reactions;\n    }).catch((error) => {\n      if (import.meta.env.DEV) {\n        console.warn('[useMessageHandling] Failed to fetch reactions', error);\n      }\n      reactionLoadedRef.current.delete(messageId);\n      return null;\n    }).finally(() => {\n      reactionFetchRef.current.delete(messageId);\n    });\n\n    reactionFetchRef.current.set(messageId, requestPromise);\n    return requestPromise;\n  }, [updateMessageReactions]);\n\n  const toggleMessageReaction = useCallback(async (messageId: string, emoji: string) => {\n    const conversationIdValue = conversationIdRef.current;\n    const practiceContextId = (practiceIdRef.current ?? '').trim();\n    if (!conversationIdValue || !practiceContextId) {\n      return;\n    }\n    if (isTempMessageId(messageId)) {\n      return;\n    }\n\n    const currentMessage = messages.find((message) => message.id === messageId);\n    const existingReactions = currentMessage?.reactions ?? [];\n    const existingReaction = existingReactions.find((reaction) => reaction.emoji === emoji);\n    const hasReacted = existingReaction?.reactedByMe ?? false;\n    const optimisticReactions = getOptimisticReactions(existingReactions, emoji, !hasReacted);\n    updateMessageReactions(messageId, optimisticReactions);\n    reactionLoadedRef.current.add(messageId);\n\n    try {\n      const nextReactions = hasReacted\n        ? await removeMessageReaction(\n          conversationIdValue,\n          messageId,\n          practiceContextId,\n          emoji\n        )\n        : await addMessageReaction(\n          conversationIdValue,\n          messageId,\n          practiceContextId,\n          emoji\n        );\n      updateMessageReactions(messageId, nextReactions);\n      reactionLoadedRef.current.add(messageId);\n    } catch (error) {\n      updateMessageReactions(messageId, existingReactions);\n      if (import.meta.env.DEV) {\n        console.warn('[useMessageHandling] Failed to update reaction', error);\n      }\n      onError?.('Failed to update reaction.');\n    }\n  }, [getOptimisticReactions, messages, onError, updateMessageReactions]);\n\n  const startConsultFlow = useCallback((targetConversationId?: string) => {\n    if (!sessionReady) {\n      return;\n    }\n    if (!targetConversationId || !practiceId) {\n      return;\n    }\n    void updateConversationMetadata({\n      intakeConversationState: initialIntakeState,\n      intakeSlimContactDraft: null,\n      intakeAiBriefActive: false\n    }, targetConversationId);\n    consultFlowAbortRef.current?.abort();\n    const controller = new AbortController();\n    consultFlowAbortRef.current = controller;\n    conversationIdRef.current = targetConversationId;\n    setIsConsultFlowActive(true);\n    setHasMoreMessages(false);\n    setNextCursor(null);\n    fetchMessages({ signal: controller.signal, targetConversationId });\n    fetchConversationMetadata(controller.signal, targetConversationId).catch((error) => {\n      console.warn('[useMessageHandling] Failed to fetch conversation metadata', error);\n    });\n    connectChatRoom(targetConversationId);\n  }, [connectChatRoom, fetchConversationMetadata, fetchMessages, practiceId, sessionReady, updateConversationMetadata]);\n\n  // Fetch messages and connect realtime socket when conversation is ready\n  useEffect(() => {\n    if (!sessionReady) {\n      closeChatSocket();\n      return;\n    }\n    if (!conversationId || !practiceId) {\n      conversationIdRef.current = undefined;\n      closeChatSocket();\n      return;\n    }\n\n    conversationIdRef.current = conversationId;\n    resetRealtimeState();\n    setPaymentRetryNotice(null);\n    abortControllerRef.current?.abort();\n    const controller = new AbortController();\n    abortControllerRef.current = controller;\n    setHasMoreMessages(false);\n    setNextCursor(null);\n    fetchMessages({ signal: controller.signal });\n    fetchConversationMetadata(controller.signal).catch((error) => {\n      console.warn('[useMessageHandling] Failed to fetch conversation metadata', error);\n    });\n    connectChatRoom(conversationId);\n\n    return () => {\n      controller.abort();\n      closeChatSocket();\n    };\n  }, [\n    closeChatSocket,\n    connectChatRoom,\n    conversationId,\n    fetchConversationMetadata,\n    fetchMessages,\n    practiceId,\n    resetRealtimeState,\n    sessionReady\n  ]);\n\n  useEffect(() => {\n    intentAbortRef.current?.abort();\n  }, [conversationId, practiceId]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n    if (!conversationId || !practiceId) {\n      return;\n    }\n    const cacheKey = getMessageCacheKey(practiceId, conversationId);\n    try {\n      const raw = window.localStorage.getItem(cacheKey);\n      if (!raw) {\n        return;\n      }\n      const parsed = JSON.parse(raw) as ChatMessageUI[];\n      if (!Array.isArray(parsed) || parsed.length === 0) {\n        return;\n      }\n      const isValid = parsed.every(\n        (msg) => typeof msg.id === 'string' && typeof msg.content === 'string' && typeof msg.timestamp === 'number'\n      );\n      if (!isValid) {\n        window.localStorage.removeItem(cacheKey);\n        return;\n      }\n      messageIdSetRef.current = new Set(parsed.map((message) => message.id));\n      setMessages(parsed);\n      setMessagesReady(true);\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.warn('[useMessageHandling] Failed to load cached messages', error);\n      }\n    }\n  }, [conversationId, practiceId]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n    if (!conversationId || !practiceId) {\n      return;\n    }\n    if (messages.length === 0) {\n      return;\n    }\n    const cacheKey = getMessageCacheKey(practiceId, conversationId);\n    const trimmed = messages.slice(-MESSAGE_CACHE_LIMIT);\n    try {\n      window.localStorage.setItem(cacheKey, JSON.stringify(trimmed));\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.warn('[useMessageHandling] Failed to cache messages', error);\n      }\n    }\n  }, [conversationId, messages, practiceId]);\n\n  // Clear UI state when switching to a different conversation to avoid showing stale messages\n  useEffect(() => {\n    if (\n      lastConversationIdRef.current &&\n      conversationId &&\n      lastConversationIdRef.current !== conversationId\n    ) {\n      clearMessages();\n      setIsConsultFlowActive(false);\n      applyConversationMetadata(null);\n    }\n\n    lastConversationIdRef.current = conversationId;\n  }, [conversationId, applyConversationMetadata, clearMessages]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      isDisposedRef.current = true;\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      if (intentAbortRef.current) {\n        intentAbortRef.current.abort();\n      }\n      if (consultFlowAbortRef.current) {\n        consultFlowAbortRef.current.abort();\n      }\n      closeChatSocket();\n    };\n  }, [closeChatSocket]);\n\n  // Determine intake status based on user message count (for anonymous users)\n  // 0 messages -> Welcome prompt\n  // 1 message -> Show Contact Form\n  // After contact form -> Pending review until practice decision\n  const userMessages = messages.filter(m => m.isUser);\n  \n  // Check if contact form has been submitted by looking for the submission flag\n  const hasSubmittedContactForm = messages.some(m => \n    m.isUser && m.metadata?.isContactFormSubmission\n  );\n\n  const latestIntakeSubmission = useMemo(() => {\n    let intakeUuid: string | null = null;\n    let paymentRequired = false;\n\n    for (let i = messages.length - 1; i >= 0; i -= 1) {\n      const message = messages[i];\n      if (!message?.isUser || !message.metadata?.isContactFormSubmission) {\n        continue;\n      }\n      const candidateUuid = message.metadata?.intakeUuid;\n      if (typeof candidateUuid === 'string' && candidateUuid.trim().length > 0) {\n        intakeUuid = candidateUuid.trim();\n      }\n      paymentRequired = message.metadata?.intakePaymentRequired === true;\n      break;\n    }\n\n    return {\n      intakeUuid,\n      paymentRequired\n    };\n  }, [messages]);\n\n  const intakePaymentReceived = useMemo(() => {\n    if (!latestIntakeSubmission.intakeUuid) return false;\n    return messages.some((message) =>\n      message.metadata?.intakePaymentUuid === latestIntakeSubmission.intakeUuid\n      && message.metadata?.paymentStatus === 'succeeded'\n    );\n  }, [latestIntakeSubmission.intakeUuid, messages]);\n  \n  const intakeDecision = messages.find(m => {\n    const decision = m.metadata?.intakeDecision;\n    return decision === 'accepted' || decision === 'rejected';\n  })?.metadata?.intakeDecision as 'accepted' | 'rejected' | undefined;\n\n  const currentStep = useMemo((): IntakeStep => {\n    if (!isAnonymous) return 'completed';\n\n    if (intakeDecision === 'accepted') return 'accepted';\n    if (intakeDecision === 'rejected') return 'rejected';\n\n    if (!isConsultFlowActive) return 'ready';\n    if (hasSubmittedContactForm) return 'pending_review';\n    if (!slimContactDraft) {\n      return 'contact_form_slim';\n    }\n    if (isAiBriefActive) {\n      return 'ai_brief';\n    }\n    return 'contact_form_decision';\n  }, [hasSubmittedContactForm, intakeDecision, isAiBriefActive, isAnonymous, isConsultFlowActive, slimContactDraft]);\n  \n  // Memoize logging to prevent excessive console output\n  useEffect(() => {\n    if (messages.length > 0) {\n      logDev('[IntakeFlow] Message analysis', {\n        totalMessages: messages.length,\n        userMessagesCount: userMessages.length,\n        hasSubmittedContactForm,\n        messagesWithIsUser: messages.map(m => ({ \n          id: m.id, \n          isUser: m.isUser, \n          role: m.role, \n          content: m.content.substring(0, 50),\n          hasIsUserProperty: 'isUser' in m,\n          isUserType: typeof m.isUser,\n          isUserValue: m.isUser,\n          hasMetadata: !!m.metadata,\n          hasContactFormFlag: !!m.metadata?.isContactFormSubmission,\n          metadataKeys: m.metadata ? Object.keys(m.metadata) : []\n        }))\n      });\n    }\n  }, [messages, userMessages.length, hasSubmittedContactForm, logDev]);\n  \n  useEffect(() => {\n    logDev('[IntakeFlow] Step calculation', {\n      isAnonymous,\n      userMessagesCount: userMessages.length,\n      hasSubmittedContactForm,\n      currentStep,\n      messagesCount: messages.length\n    });\n  }, [isAnonymous, userMessages.length, hasSubmittedContactForm, currentStep, messages.length, logDev]);\n\n  // Inject system messages based on step\n  const processedPaymentUuidsRef = useRef<Set<string>>(new Set());\n  useEffect(() => {\n    if (!isAnonymous) return;\n\n    let cancelled = false;\n\n    const parseStoredFlag = (raw: string | null) => {\n      if (!raw) return null;\n      try {\n        const parsed = JSON.parse(raw) as {\n          practiceName?: string;\n          practiceId?: string;\n          conversationId?: string;\n        };\n        return parsed;\n      } catch (error) {\n        console.warn('[Intake] Failed to parse payment flag', error);\n        return null;\n      }\n    };\n\n    const postPaymentConfirmation = async (uuid: string, practiceName: string) => {\n      if (cancelled || !conversationId || !practiceId) {\n        return;\n      }\n      const messageId = `system-payment-confirm-${uuid}`;\n      if (processedPaymentUuidsRef.current.has(uuid) || messagesRef.current.some((m) => m.id === messageId || m.metadata?.intakePaymentUuid === uuid)) {\n        return;\n      }\n\n      if (cancelled) {\n        return;\n      }\n\n      try {\n        if (cancelled) return;\n        if (processedPaymentUuidsRef.current.has(uuid)) {\n          return;\n        }\n        processedPaymentUuidsRef.current.add(uuid);\n\n        const persistedMessage = await postSystemMessage(conversationId, practiceId, {\n          clientId: messageId,\n          content: `Payment received. ${practiceName} will review your intake and follow up here shortly.`,\n          metadata: {\n            intakePaymentUuid: uuid,\n            paymentStatus: 'succeeded'\n          }\n        });\n        \n        if (cancelled) {\n          return;\n        }\n\n        if (persistedMessage) {\n          applyServerMessages([persistedMessage]);\n          setPaymentRetryNotice(null);\n          // confirmIntakeLead removed - Worker handles conversion after payment\n\n        } else {\n          throw new Error('Payment confirmation message could not be saved.');\n        }\n      } catch (error) {\n        // Only remove if it failed to save (so it can be retried)\n        // If it was cancelled but saved, we rely on the dedupe check above on next run\n        processedPaymentUuidsRef.current.delete(uuid);\n        \n        const message = error instanceof Error ? error.message : 'Payment confirmation failed.';\n        console.warn('[Intake] Failed to persist payment confirmation message', error);\n        onError?.(message);\n        throw error; // Re-throw to allow caller to handle retry logic\n      }\n    };\n\n    if (typeof window !== 'undefined') {\n      const paymentKeys: string[] = [];\n      const pendingKeys: string[] = [];\n      for (let i = 0; i < window.sessionStorage.length; i += 1) {\n        const key = window.sessionStorage.key(i);\n        if (key && key.startsWith('intakePaymentSuccess:')) {\n          paymentKeys.push(key);\n        }\n        if (key && key.startsWith('intakePaymentPending:')) {\n          pendingKeys.push(key);\n        }\n      }\n\n      paymentKeys.forEach((key) => {\n        const uuid = key.split(':')[1];\n        const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        if (!uuid || !uuidPattern.test(uuid)) {\n          console.warn('[Intake] Skipping malformed payment confirmation key', { key });\n          return;\n        }\n        let practiceName = 'the practice';\n        const raw = window.sessionStorage.getItem(key);\n        const parsed = parseStoredFlag(raw);\n        if (parsed?.practiceName && parsed.practiceName.trim().length > 0) {\n          practiceName = parsed.practiceName.trim();\n        }\n        \n        postPaymentConfirmation(uuid, practiceName)\n          .then(() => {\n            window.sessionStorage.removeItem(key);\n          })\n          .catch((error) => {\n            console.warn('[Intake] Payment confirmation retry failed, keeping session key', error);\n          });\n      });\n\n      pendingKeys.forEach((key) => {\n        window.sessionStorage.removeItem(key);\n      });\n    }\n\n    return () => {\n      cancelled = true;\n    };\n  }, [\n    isAnonymous,\n    conversationId,\n    onError,\n    practiceId,\n    applyServerMessages\n  ]);\n\n  // The intake flow is now conversational and non-blocking\n  return {\n    messages,\n    conversationMetadata,\n    sendMessage,\n    handleContactFormSubmit,\n    startConsultFlow,\n    addMessage,\n    updateMessage,\n    ingestServerMessages,\n    clearMessages,\n    updateConversationMetadata,\n    isSocketReady,\n    isConsultFlowActive,\n    paymentRetryNotice,\n    messagesReady,\n    hasMoreMessages,\n    isLoadingMoreMessages,\n    loadMoreMessages,\n    requestMessageReactions,\n    toggleMessageReaction,\n    intakeConversationState,\n    handleIntakeCtaResponse,\n    resetIntakeCta,\n    slimContactDraft,\n    handleSlimFormContinue,\n    handleBuildBrief,\n    handleSubmitNow,\n    intakeStatus: {\n      step: currentStep,\n      decision: intakeDecision,\n      intakeUuid: latestIntakeSubmission.intakeUuid,\n      paymentRequired: latestIntakeSubmission.paymentRequired,\n      paymentReceived: intakePaymentReceived\n    }\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useMobileDetection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/usePaymentUpgrade.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":242,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":242,"endColumn":24,"suggestions":[{"fix":{"range":[9192,9282],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":384,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":384,"endColumn":24,"suggestions":[{"fix":{"range":[15062,15112],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":385,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":385,"endColumn":24,"suggestions":[{"fix":{"range":[15125,15194],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":425,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":425,"endColumn":24,"suggestions":[{"fix":{"range":[16460,16506],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":445,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":445,"endColumn":26,"suggestions":[{"fix":{"range":[17385,17463],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":450,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":450,"endColumn":26,"suggestions":[{"fix":{"range":[17568,17867],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":465,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":465,"endColumn":26,"suggestions":[{"fix":{"range":[18207,18270],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback } from 'preact/hooks';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { getClient } from '@/shared/lib/authClient';\nimport { requestBillingPortalSession, requestSubscriptionCancellation } from '@/shared/lib/apiClient';\nimport { getTrustedHosts } from '@/config/urls';\n\n// Trusted hosts for return URL validation\n// Uses centralized URL configuration from src/config/urls.ts\nconst TRUSTED_RETURN_URL_HOSTS: string[] = getTrustedHosts();\n\n// Helper function to ensure a safe, validated return URL\n// Prevents open-redirect vulnerabilities by validating URLs before returning them\n// Throws errors instead of silently falling back\nfunction ensureValidReturnUrl(url: string | undefined | null, _practiceId?: string): string {\n  // Treat undefined/null/invalid inputs as errors\n  if (!url || typeof url !== 'string') {\n    throw new Error(`Invalid return URL: ${url === null ? 'null' : url === undefined ? 'undefined' : 'not a string'}`);\n  }\n\n  const trimmed = url.trim();\n  if (trimmed.length === 0) {\n    throw new Error('Invalid return URL: empty string');\n  }\n\n  // Guard against SSR - need window.location.origin for validation\n  if (typeof window === 'undefined') {\n    throw new Error('Cannot validate return URL in SSR context');\n  }\n\n  // Parse and validate the URL\n  let parsed: URL;\n  try {\n    // Parse the URL - this will throw for invalid URLs\n    // Use window.location.origin as base to handle relative URLs\n    parsed = new URL(trimmed, window.location.origin);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(`Invalid return URL format: ${trimmed}. ${errorMessage}`);\n  }\n\n  // Guard against dangerous schemes (javascript:, data:, vbscript:, etc.)\n  const allowedProtocols = ['http:', 'https:'];\n  if (!allowedProtocols.includes(parsed.protocol)) {\n    throw new Error(`Invalid return URL protocol: ${parsed.protocol}. Only http: and https: are allowed.`);\n  }\n\n  // Ensure it's an absolute URL (not relative)\n  if (!parsed.protocol || !parsed.host) {\n    throw new Error(`Invalid return URL: missing protocol or host: ${trimmed}`);\n  }\n\n  // Primary validation: allow same-origin URLs\n  if (parsed.origin === window.location.origin) {\n    return parsed.toString();\n  }\n\n  // Secondary validation: check against allowlist of trusted hosts\n  if (TRUSTED_RETURN_URL_HOSTS.length > 0 && parsed.host) {\n    const hostname = parsed.hostname.toLowerCase();\n    const isTrusted = TRUSTED_RETURN_URL_HOSTS.some(\n      trustedHost => hostname === trustedHost.toLowerCase() || hostname.endsWith(`.${trustedHost.toLowerCase()}`)\n    );\n    if (isTrusted) {\n      return parsed.toString();\n    }\n  }\n\n  // URL is not same-origin and not in allowlist - reject it\n  throw new Error(`Invalid return URL: origin ${parsed.origin} is not allowed. Allowed origins: ${window.location.origin}, ${TRUSTED_RETURN_URL_HOSTS.join(', ')}`);\n}\n\n// Callback URLs may be relative (path-only) or absolute.\n// Helper functions for safe type extraction from API responses\nfunction extractUrl(result: unknown): string | undefined {\n  if (result && typeof result === 'object' && result !== null) {\n    // Check for direct url property\n    if ('url' in result && typeof result.url === 'string') {\n      return result.url;\n    }\n\n    // Check for url in data property\n    if ('data' in result && result.data && typeof result.data === 'object' && result.data !== null) {\n      if ('url' in result.data && typeof result.data.url === 'string') {\n        return result.data.url;\n      }\n    }\n\n    // Better Auth Stripe plugin might return it directly in the response body\n    if ('billingPortalUrl' in result && typeof result.billingPortalUrl === 'string') {\n      return result.billingPortalUrl;\n    }\n\n    // Check nested in data.billingPortalUrl\n    if ('data' in result && result.data && typeof result.data === 'object' && result.data !== null) {\n      if ('billingPortalUrl' in result.data && typeof result.data.billingPortalUrl === 'string') {\n        return result.data.billingPortalUrl;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction extractErrorMessage(result: unknown, fallback: string): string {\n  if (result && typeof result === 'object' && result !== null) {\n    // Check for direct error property\n    if ('error' in result && typeof result.error === 'string') {\n      return result.error;\n    }\n\n    // Check for error in data property\n    if ('data' in result && result.data && typeof result.data === 'object' && result.data !== null) {\n      if ('error' in result.data && typeof result.data.error === 'string') {\n        return result.data.error;\n      }\n    }\n  }\n  return fallback;\n}\n\nfunction extractProperty<T>(result: unknown, property: string): T | undefined {\n  if (result && typeof result === 'object' && result !== null) {\n    const obj = result as Record<string, unknown>;\n    if (property in obj) {\n      return obj[property] as T;\n    }\n  }\n  return undefined;\n}\n\nfunction headersToObject(headers: Headers | null): Record<string, string> | null {\n  if (!headers) {\n    return null;\n  }\n  const result: Record<string, string> = {};\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\n\n// Error codes for subscription operations (matching backend)\nenum SubscriptionErrorCode {\n  SUBSCRIPTION_ALREADY_ACTIVE = 'SUBSCRIPTION_ALREADY_ACTIVE',\n  EMAIL_VERIFICATION_REQUIRED = 'EMAIL_VERIFICATION_REQUIRED',\n  PRACTICE_NOT_FOUND = 'PRACTICE_NOT_FOUND',\n  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',\n  STRIPE_CHECKOUT_FAILED = 'STRIPE_CHECKOUT_FAILED',\n  STRIPE_BILLING_PORTAL_FAILED = 'STRIPE_BILLING_PORTAL_FAILED',\n  STRIPE_CUSTOMER_NOT_FOUND = 'STRIPE_CUSTOMER_NOT_FOUND',\n  STRIPE_SUBSCRIPTION_NOT_FOUND = 'STRIPE_SUBSCRIPTION_NOT_FOUND',\n  INVALID_PRACTICE_ID = 'INVALID_PRACTICE_ID',\n  INVALID_SEAT_COUNT = 'INVALID_SEAT_COUNT',\n  INVALID_PLAN_TYPE = 'INVALID_PLAN_TYPE',\n  SUBSCRIPTION_SYNC_FAILED = 'SUBSCRIPTION_SYNC_FAILED',\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\n}\n\n// Error titles for UI display\nconst ERROR_TITLES: Record<SubscriptionErrorCode, string> = {\n  [SubscriptionErrorCode.SUBSCRIPTION_ALREADY_ACTIVE]: 'Subscription Active',\n  [SubscriptionErrorCode.EMAIL_VERIFICATION_REQUIRED]: 'Verify Email',\n  [SubscriptionErrorCode.PRACTICE_NOT_FOUND]: 'Practice Not Found',\n  [SubscriptionErrorCode.INSUFFICIENT_PERMISSIONS]: 'Access Denied',\n  [SubscriptionErrorCode.STRIPE_CHECKOUT_FAILED]: 'Upgrade Failed',\n  [SubscriptionErrorCode.STRIPE_BILLING_PORTAL_FAILED]: 'Billing Portal Error',\n  [SubscriptionErrorCode.STRIPE_CUSTOMER_NOT_FOUND]: 'Customer Not Found',\n  [SubscriptionErrorCode.STRIPE_SUBSCRIPTION_NOT_FOUND]: 'Subscription Not Found',\n  [SubscriptionErrorCode.INVALID_PRACTICE_ID]: 'Invalid Request',\n  [SubscriptionErrorCode.INVALID_SEAT_COUNT]: 'Invalid Request',\n  [SubscriptionErrorCode.INVALID_PLAN_TYPE]: 'Invalid Request',\n  [SubscriptionErrorCode.SUBSCRIPTION_SYNC_FAILED]: 'Subscription Sync Error',\n  [SubscriptionErrorCode.INTERNAL_ERROR]: 'System Error',\n};\n\n// Helper function to get error title\nfunction getErrorTitle(errorCode: SubscriptionErrorCode): string {\n  return ERROR_TITLES[errorCode] || 'Error';\n}\n\nexport interface SubscriptionUpgradeRequest {\n  practiceId?: string;\n  planId?: string; // UUID of the subscription plan (optional)\n  plan?: string; // Subscription plan name (required for /api/auth/subscription/upgrade)\n  seats?: number | null;\n  annual?: boolean;\n  successUrl?: string;\n  cancelUrl?: string;\n  returnUrl?: string;\n}\n\nexport interface BillingPortalRequest {\n  practiceId: string;\n  returnUrl?: string;\n  customerType?: 'user' | 'organization';\n}\n\nexport const usePaymentUpgrade = () => {\n  const [submitting, setSubmitting] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const { showError, showSuccess } = useToastContext();\n\n  const buildSuccessUrl = useCallback((practiceId?: string) => {\n    const params = new URLSearchParams();\n    params.set('subscription', 'success');\n    if (practiceId) {\n      params.set('practiceId', practiceId);\n    }\n    const query = params.toString();\n    return `/${query ? `?${query}` : ''}`;\n  }, []);\n\n  const buildCancelUrl = useCallback((_practiceId?: string) => {\n    return '/?subscription=cancelled';\n  }, []);\n\n  const resolveReturnUrl = useCallback(\n    (returnUrl: string | undefined, practiceId?: string) => {\n      if (returnUrl) {\n        return returnUrl;\n      }\n      if (typeof window !== 'undefined') {\n        return window.location.href;\n      }\n      return buildSuccessUrl(practiceId);\n    },\n    [buildSuccessUrl]\n  );\n\n  const openBillingPortal = useCallback(\n    async ({ practiceId, returnUrl, customerType }: BillingPortalRequest) => {\n      try {\n        const rawReturnUrl = resolveReturnUrl(returnUrl, practiceId);\n        const safeReturnUrl = ensureValidReturnUrl(rawReturnUrl, practiceId);\n        const result = await requestBillingPortalSession({\n          practiceId,\n          customerType: customerType ?? 'organization',\n          returnUrl: safeReturnUrl\n        });\n\n        const url = extractUrl(result.data);\n        if (!url) {\n          console.error('Invalid response structure: missing or invalid url property', result.data);\n        }\n        if (!result.ok || !url) {\n          const errorCode =\n            extractProperty<string>(result.data, 'code') ||\n            extractProperty<string>(result.data, 'errorCode');\n\n          let mappedErrorCode: SubscriptionErrorCode | null = null;\n          if (errorCode === 'NO_STRIPE_CUSTOMER_FOUND_FOR_THIS_USER') {\n            mappedErrorCode = SubscriptionErrorCode.STRIPE_CUSTOMER_NOT_FOUND;\n          } else if (typeof errorCode === 'string') {\n            const upperCode = errorCode.toUpperCase();\n            if (Object.values(SubscriptionErrorCode).includes(upperCode as SubscriptionErrorCode)) {\n              mappedErrorCode = upperCode as SubscriptionErrorCode;\n            }\n          }\n\n          if (mappedErrorCode || errorCode) {\n            throw new Error(JSON.stringify({\n              errorCode: mappedErrorCode || errorCode,\n              message: extractErrorMessage(result.data, 'Unable to open billing portal'),\n              details: extractProperty<unknown>(result.data, 'details')\n            }));\n          }\n\n          const message = extractErrorMessage(result.data, 'Unable to open billing portal');\n          throw new Error(message);\n        }\n\n        window.location.href = url;\n      } catch (err) {\n        const message = err instanceof Error ? err.message : 'Unable to open billing portal';\n\n        let errorCode: SubscriptionErrorCode | null = null;\n        let errorMessage = message;\n\n        try {\n          const parsedError = JSON.parse(message);\n          if (parsedError.errorCode && Object.values(SubscriptionErrorCode).includes(parsedError.errorCode)) {\n            errorCode = parsedError.errorCode as SubscriptionErrorCode;\n            errorMessage = parsedError.message || message;\n          }\n        } catch {\n          // Not a structured error, use original message\n        }\n\n        const title = errorCode ? getErrorTitle(errorCode) : 'Billing Portal Error';\n        showError(title, errorMessage);\n      }\n    },\n    [resolveReturnUrl, showError]\n  );\n\n\n  const handleAlreadySubscribed = useCallback(\n    async (practiceId: string, returnUrl: string) => {\n      setError(null);\n      // Redirect directly to billing portal to manage current subscription\n      try {\n        await openBillingPortal({ practiceId, returnUrl });\n      } finally {\n        // Ensure submitting state is cleared even on early redirect\n        setSubmitting(false);\n      }\n    },\n    [openBillingPortal]\n  );\n\n  const submitUpgrade = useCallback(\n    async ({ practiceId, planId, plan, successUrl, cancelUrl, returnUrl, annual }: SubscriptionUpgradeRequest): Promise<void> => {\n      setSubmitting(true);\n      setError(null);\n\n      // Plan name is required for Better Auth Stripe subscription.upgrade endpoint\n      if (!plan) {\n        setError('Subscription plan name is required');\n        showError('Invalid Request', 'Subscription plan name is required to create a subscription.');\n        setSubmitting(false);\n        return;\n      }\n\n      const resolvedPracticeId = practiceId || undefined;\n\n      try {\n        // Step 1: Set active practice if we have one using the Better Auth organization plugin\n        // The remote API will auto-create and set the active practice if one doesn't exist\n        if (resolvedPracticeId) {\n          // Set active practice using the Better Auth organization plugin\n          const client = getClient();\n          await client.organization.setActive({ organizationId: resolvedPracticeId });\n        }\n\n        // Step 2: Build URLs for success and cancel callbacks\n        // Note: resolvedPracticeId may be undefined - the remote API will handle practice creation\n        const rawSuccessUrl = successUrl ?? buildSuccessUrl(resolvedPracticeId);\n        const rawCancelUrl = cancelUrl ?? buildCancelUrl(resolvedPracticeId);\n\n        // Ensure URLs are valid\n        const currentOrigin = window.location.origin;\n\n        // Validate URLs against trusted hosts to prevent open redirects\n        const validatedSuccessUrl = ensureValidReturnUrl(\n          new URL(rawSuccessUrl, currentOrigin).toString(),\n          resolvedPracticeId\n        );\n        const validatedCancelUrl = ensureValidReturnUrl(\n          new URL(rawCancelUrl, currentOrigin).toString(),\n          resolvedPracticeId\n        );\n\n\n        // Step 3: Create subscription using Better Auth Stripe subscription.upgrade endpoint\n        try {\n          const createPayload = {\n            planId: planId || undefined, // UUID of the subscription plan (optional)\n            plan, // Plan name (required by Better Auth Stripe plugin)\n            referenceId: resolvedPracticeId,\n            annual: typeof annual === 'boolean' ? annual : undefined,\n            successUrl: validatedSuccessUrl,\n            cancelUrl: validatedCancelUrl,\n            disableRedirect: false // Auto-redirect to Stripe Checkout\n          };\n\n          // Use Better Auth session cookies (not axios)\n          const response = await getClient().subscription.upgrade(createPayload);\n          const isResponseObject = typeof response === 'object' && response !== null;\n          const hasHeaders = isResponseObject &&\n            'headers' in response &&\n            (response as { headers?: Headers }).headers instanceof Headers;\n          const headers = hasHeaders ? (response as { headers: Headers }).headers : null;\n\n          const isBetterFetchResponse =\n            isResponseObject &&\n            'data' in response &&\n            'error' in response &&\n            !hasHeaders;\n\n          // Log response for debugging\n          if (import.meta.env.DEV) {\n            const status = isResponseObject && 'status' in response\n              ? (response as { status?: number }).status\n              : undefined;\n            console.log('[UPGRADE] Response status:', status);\n            console.log('[UPGRADE] Response headers:', headersToObject(headers));\n          }\n\n          // Check for Location header (in case of redirect)\n          const locationHeader = headers\n            ? headers.get('location') || headers.get('Location')\n            : null;\n\n          // Parse response body\n          let data: unknown;\n          if (isBetterFetchResponse) {\n            const { data: responseData, error: responseError } = response as {\n              data: unknown;\n              error: unknown;\n            };\n            if (responseError) {\n              throw new Error(JSON.stringify(responseError));\n            }\n            data = responseData;\n          } else if (headers) {\n            const contentType = headers.get('content-type');\n            if (contentType?.includes('application/json')) {\n              data = await (response as Response).json();\n            } else {\n              const text = await (response as Response).text();\n              if (text) {\n                try {\n                  data = JSON.parse(text);\n                } catch {\n                  data = { rawText: text };\n                }\n              } else {\n                data = null;\n              }\n            }\n          } else {\n            data = response;\n          }\n\n          if (import.meta.env.DEV) {\n            console.log('[UPGRADE] Response data:', data);\n          }\n\n          // Handle different response structures\n          let checkoutUrl: string | undefined;\n\n          if (data && typeof data === 'object') {\n            // Try different possible response formats\n            checkoutUrl = (data as { checkoutUrl?: string }).checkoutUrl ||\n              (data as { checkout_url?: string }).checkout_url ||\n              (data as { url?: string }).url ||\n              ((data as { data?: { checkoutUrl?: string } }).data?.checkoutUrl) ||\n              ((data as { data?: { checkout_url?: string } }).data?.checkout_url) ||\n              ((data as { data?: { url?: string } }).data?.url);\n          }\n\n          // Also check Location header if checkoutUrl not in body (for redirects)\n          if (!checkoutUrl && locationHeader) {\n            checkoutUrl = locationHeader;\n            if (import.meta.env.DEV) {\n              console.log('[UPGRADE] Using checkoutUrl from Location header:', checkoutUrl);\n            }\n          }\n\n          if (!checkoutUrl || typeof checkoutUrl !== 'string') {\n            console.error('[UPGRADE] Missing checkoutUrl. Full response:', {\n              status: isResponseObject && 'status' in response\n                ? (response as { status?: number }).status\n                : undefined,\n              headers: headersToObject(headers),\n              data\n            });\n            throw new Error(`Invalid response from subscription creation. Expected checkoutUrl, got: ${JSON.stringify(data)}`);\n          }\n\n          // Redirect to Stripe Checkout\n          window.location.href = checkoutUrl;\n        } catch (error) {\n          // Handle fetch errors\n          if (error instanceof Error) {\n            console.error('[UPGRADE] Subscription creation error:', error);\n            throw error;\n          }\n          throw new Error('Failed to create subscription');\n        }\n      } catch (err) {\n        const message = err instanceof Error ? err.message : 'Subscription creation failed';\n\n        // Try to parse structured error response\n        let errorCode: SubscriptionErrorCode | null = null;\n        let errorMessage = message;\n\n        try {\n          const parsedError = JSON.parse(message);\n          if (parsedError && typeof parsedError === 'object' && 'errorCode' in parsedError) {\n            const code = (parsedError as { errorCode?: string }).errorCode;\n            if (code && Object.values(SubscriptionErrorCode).includes(code as SubscriptionErrorCode)) {\n              errorCode = code as SubscriptionErrorCode;\n              errorMessage = (parsedError as { message?: string }).message || message;\n            }\n          }\n        } catch {\n          // Not a structured error - use the original message\n        }\n\n        // Handle specific error codes\n        if (errorCode === SubscriptionErrorCode.SUBSCRIPTION_ALREADY_ACTIVE && resolvedPracticeId) {\n          const safeReturnUrl = ensureValidReturnUrl(resolveReturnUrl(returnUrl, resolvedPracticeId), resolvedPracticeId);\n          await handleAlreadySubscribed(resolvedPracticeId, safeReturnUrl);\n          return;\n        }\n\n        if (errorCode === SubscriptionErrorCode.EMAIL_VERIFICATION_REQUIRED) {\n          setError(errorMessage);\n          showError(\n            'Verify Email',\n            'Please verify your email address before upgrading. Check your inbox for the verification link.'\n          );\n          return;\n        }\n\n        const title = errorCode ? getErrorTitle(errorCode) : 'Upgrade Failed';\n        setError(errorMessage);\n        showError(title, errorMessage);\n      } finally {\n        setSubmitting(false);\n      }\n    },\n    [buildCancelUrl, buildSuccessUrl, handleAlreadySubscribed, resolveReturnUrl, showError]\n  );\n\n  const cancelSubscription = useCallback(\n    async (practiceId: string) => {\n      try {\n        const result = await requestSubscriptionCancellation(practiceId);\n\n        if (!result.ok) {\n          const errorCode = extractProperty<string>(result.data, 'errorCode');\n          if (errorCode) {\n            throw new Error(JSON.stringify({\n              errorCode,\n              message: extractErrorMessage(result.data, 'Failed to cancel subscription'),\n              details: extractProperty<unknown>(result.data, 'details')\n            }));\n          }\n\n          const message = extractErrorMessage(result.data, 'Failed to cancel subscription');\n          throw new Error(message);\n        }\n\n        showSuccess('Subscription cancelled', 'Your subscription has been cancelled successfully.');\n        return true;\n      } catch (err) {\n        const message = err instanceof Error ? err.message : 'Failed to cancel subscription';\n\n        let errorCode: SubscriptionErrorCode | null = null;\n        let errorMessage = message;\n\n        try {\n          const parsedError = JSON.parse(message);\n          if (parsedError.errorCode && Object.values(SubscriptionErrorCode).includes(parsedError.errorCode)) {\n            errorCode = parsedError.errorCode as SubscriptionErrorCode;\n            errorMessage = parsedError.message || message;\n          }\n        } catch {\n          // Not a structured error, use original message\n        }\n\n        const title = errorCode ? getErrorTitle(errorCode) : 'Cancellation Error';\n        showError(title, errorMessage);\n        return false;\n      }\n    },\n    [showError, showSuccess]\n  );\n\n\n  return {\n    submitting,\n    error,\n    submitUpgrade,\n    openBillingPortal,\n    cancelSubscription,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/usePracticeConfig.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":205,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":205,"endColumn":22,"suggestions":[{"fix":{"range":[8006,8097],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":257,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":257,"endColumn":19,"suggestions":[{"fix":{"range":[10114,10170],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'preact/hooks';\nimport { z } from 'zod';\nimport type { PracticeConfig } from '../../../worker/types';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { getPractice, getPublicPracticeDetails } from '@/shared/lib/apiClient';\nimport { setPracticeDetailsEntry } from '@/shared/stores/practiceDetailsStore';\n\n// Zod schema for API response validation\n// Note: createdAt/updatedAt can be either number (timestamp) or string (ISO date) depending on the API\nconst PracticeSchema = z.object({\n  slug: z.string().optional(),\n  id: z.string().optional(),\n  name: z.string().optional(),\n  config: z.record(z.string(), z.unknown()).optional(),\n  domain: z.string().nullable().optional(), // API can return null\n  createdAt: z.union([z.number(), z.string()]).optional(),\n  updatedAt: z.union([z.number(), z.string()]).nullable().optional(), // API can return null or string\n  stripeCustomerId: z.string().nullable().optional(), // API can return null\n  seats: z.number().optional(),\n  kind: z.enum(['personal', 'business']).optional(),\n  subscriptionStatus: z.enum(['none', 'trialing', 'active', 'past_due', 'canceled', 'incomplete', 'incomplete_expired', 'unpaid', 'paused']).optional()\n});\n\n// Extended config with name for UI convenience (name comes from Practice, not config)\nexport interface UIPracticeConfig extends PracticeConfig {\n  id?: string; // Optional - comes from Practice object\n  slug?: string; // Optional - comes from Practice object\n  name?: string; // Optional - comes from Practice object\n}\n\nconst buildDefaultPracticeConfig = (overrides: Partial<UIPracticeConfig> = {}): UIPracticeConfig => ({\n  id: '',\n  slug: '',\n  name: '',\n  profileImage: null,\n  introMessage: '',\n  description: '',\n  availableServices: [],\n  serviceQuestions: {},\n  domain: '',\n  brandColor: '#000000',\n  accentColor: 'gold',\n  voice: {\n    enabled: false,\n    provider: 'cloudflare',\n    voiceId: null,\n    displayName: null,\n    previewUrl: null\n  },\n  ...overrides\n});\n\n\ninterface UsePracticeConfigOptions {\n  onError?: (error: string) => void;\n  practiceId?: string; // Optional explicit override\n  allowUnauthenticated?: boolean;\n  refreshKey?: string | number | null;\n}\n\nexport const usePracticeConfig = ({\n  onError,\n  practiceId: explicitPracticeId,\n  allowUnauthenticated = false,\n  refreshKey\n}: UsePracticeConfigOptions = {}) => {\n  const { activeOrganizationId, session } = useSessionContext();\n  const isAuthenticated = Boolean(session?.user);\n  const [practiceId, setPracticeId] = useState<string>('');\n  const [practiceNotFound, setPracticeNotFound] = useState<boolean>(false);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [practiceConfig, setPracticeConfig] = useState<UIPracticeConfig>(() => buildDefaultPracticeConfig());\n  const refreshKeyRef = useRef<string | number | null | undefined>(refreshKey);\n\n  // Store onError in a ref so it never appears in useCallback deps.\n  // This prevents fetchPracticeConfig from being recreated every render when\n  // callers pass inline arrow functions (which is the common pattern in route components).\n  const onErrorRef = useRef(onError);\n  onErrorRef.current = onError;\n\n  // Use ref to track if we've already fetched for this practiceId\n  const fetchedPracticeIds = useRef<Set<string>>(new Set());\n  \n  // Track current request to prevent stale responses from clobbering state\n  const currentRequestRef = useRef<{\n    practiceId: string;\n    abortController: AbortController;\n  } | null>(null);\n\n  // Parse URL parameters for configuration\n  const parseUrlParams = useCallback(() => {\n    if (typeof window !== 'undefined') {\n      const urlParams = new URLSearchParams(window.location.search);\n      const rawPracticeIdParam = urlParams.get('practiceId');\n      const practiceIdParam = rawPracticeIdParam && rawPracticeIdParam.trim().length > 0\n        ? rawPracticeIdParam\n        : null;\n      const shouldUseQueryParam = allowUnauthenticated || !session?.user;\n\n      // Priority: explicit param (slug from path) > URL param (only for unauth/public) > active org\n      const normalizedExplicitPracticeId = typeof explicitPracticeId === 'string'\n        ? explicitPracticeId.trim()\n        : null;\n      const resolved = (\n        (normalizedExplicitPracticeId && normalizedExplicitPracticeId.length > 0 ? normalizedExplicitPracticeId : null) ??\n        (shouldUseQueryParam ? practiceIdParam : null) ??\n        activeOrganizationId ??\n        ''\n      );\n      setPracticeId(resolved);\n    }\n  }, [explicitPracticeId, activeOrganizationId, allowUnauthenticated, session?.user]);\n\n  // Fetch practice configuration\n  const fetchPracticeConfig = useCallback(async (currentPracticeId: string) => {\n    const requestedPracticeId = currentPracticeId;\n    if (fetchedPracticeIds.current.has(currentPracticeId)) {\n      return; // Don't fetch if we've already fetched for this practiceId\n    }\n\n    // Mark as fetching immediately to prevent duplicate calls\n    fetchedPracticeIds.current.add(currentPracticeId);\n\n    // Abort any existing request\n    if (currentRequestRef.current) {\n      currentRequestRef.current.abortController.abort();\n    }\n\n    // Create new request tracking\n    const controller = new AbortController();\n    currentRequestRef.current = {\n      practiceId: currentPracticeId,\n      abortController: controller\n    };\n\n    setIsLoading(true);\n\n    const isStaleRequest = (): boolean => {\n      const isStale =\n        !currentRequestRef.current ||\n        currentRequestRef.current.practiceId !== requestedPracticeId ||\n        controller.signal.aborted;\n      if (isStale) {\n        fetchedPracticeIds.current.delete(currentPracticeId);\n      }\n      return isStale;\n    };\n\n    try {\n      if (allowUnauthenticated) {\n        const publicDetails = await getPublicPracticeDetails(currentPracticeId, { signal: controller.signal });\n        if (isStaleRequest()) {\n          return;\n        }\n\n        if (publicDetails) {\n          const details = publicDetails.details;\n          const resolvedDetailsId = publicDetails.practiceId ?? currentPracticeId;\n          if (details) {\n            setPracticeDetailsEntry(currentPracticeId, details);\n          }\n          if (details && resolvedDetailsId && resolvedDetailsId !== currentPracticeId) {\n            setPracticeDetailsEntry(resolvedDetailsId, details);\n          }\n          const config = buildDefaultPracticeConfig({\n            id: publicDetails.practiceId,\n            slug: publicDetails.slug ?? currentPracticeId,\n            name: publicDetails.name ?? '',\n            profileImage: publicDetails.logo ?? null,\n            introMessage: details?.introMessage ?? '',\n            description: details?.description ?? '',\n            accentColor: details?.accentColor ?? 'gold',\n            isPublic: details?.isPublic\n          });\n\n          setPracticeConfig(config);\n          if (publicDetails.practiceId && publicDetails.practiceId !== currentPracticeId) {\n            fetchedPracticeIds.current.add(publicDetails.practiceId);\n            setPracticeId(publicDetails.practiceId);\n          }\n          setPracticeNotFound(false);\n          setIsLoading(false);\n          return;\n        }\n\n        // No public details available - mark as not found for unauthenticated access.\n        fetchedPracticeIds.current.delete(currentPracticeId);\n        setPracticeNotFound(true);\n        setIsLoading(false);\n        return;\n      }\n\n      // Try to get specific practice by ID or slug only\n      let practice: z.infer<typeof PracticeSchema> | undefined;\n      try {\n        const practiceData = await getPractice(currentPracticeId, { signal: controller.signal });\n        if (isStaleRequest()) {\n          return;\n        }\n        if (practiceData) {\n          practice = PracticeSchema.parse(practiceData as unknown as Record<string, unknown>);\n        }\n      } catch (e) {\n        // If direct fetch fails, fall through to list approach when authenticated\n        console.debug('[usePracticeConfig] Direct practice fetch failed, falling back to list', e);\n      }\n\n      // Check again before processing practice data\n      if (isStaleRequest()) {\n        return; // Request is stale or aborted, don't update state\n      }\n\n      if (practice) {\n        // Practice exists, use its config or defaults\n        // Parse config safely - config is Record<string, unknown> from API\n        const cfg = practice.config as Partial<PracticeConfig> || {};\n\n          const config: UIPracticeConfig = {\n          id: practice.id,\n          slug: practice.slug,\n          name: practice.name || '',\n          profileImage: cfg.profileImage ?? null,\n          introMessage: cfg.introMessage ?? '',\n          description: cfg.description ?? '',\n          availableServices: cfg.availableServices ?? [],\n          serviceQuestions: cfg.serviceQuestions ?? {},\n          domain: cfg.domain ?? '',\n          brandColor: cfg.brandColor ?? '#000000',\n          accentColor: cfg.accentColor ?? 'gold',\n          voice: {\n            enabled: typeof cfg.voice?.enabled === 'boolean' ? cfg.voice.enabled : false,\n            provider: cfg.voice?.provider ?? 'cloudflare',\n            voiceId: cfg.voice?.voiceId ?? null,\n            displayName: cfg.voice?.displayName ?? null,\n            previewUrl: cfg.voice?.previewUrl ?? null\n          }\n        };\n\n        setPracticeConfig(config);\n        if (practice.id && practice.id !== currentPracticeId) {\n          fetchedPracticeIds.current.add(practice.id);\n          setPracticeId(practice.id);\n        }\n        setPracticeNotFound(false);\n      } else {\n        // Practice not found in the list - this indicates a 404-like scenario\n        // Remove from fetched set so it can be retried\n        fetchedPracticeIds.current.delete(currentPracticeId);\n        setPracticeNotFound(true);\n      }\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        // Request was aborted; allow a new attempt to proceed\n        fetchedPracticeIds.current.delete(currentPracticeId);\n        return;\n      }\n      console.warn('Failed to fetch practice config:', error);\n      setPracticeNotFound(true);\n      onErrorRef.current?.('Failed to load practice configuration');\n    } finally {\n      // Clear the current request ref and reset loading state\n      if (currentRequestRef.current?.practiceId === currentPracticeId) {\n        currentRequestRef.current = null;\n        // Only clear loading state if no newer request replaced this one\n        setIsLoading(false);\n      }\n    }\n  }, [allowUnauthenticated]);\n\n  // Retry function for practice config\n  const handleRetryPracticeConfig = useCallback(() => {\n    setPracticeNotFound(false);\n    // Remove from fetched set so we can retry\n    fetchedPracticeIds.current.delete(practiceId);\n    // Clear any current request to allow retry\n    if (currentRequestRef.current) {\n      currentRequestRef.current.abortController.abort();\n      currentRequestRef.current = null;\n    }\n    fetchPracticeConfig(practiceId);\n  }, [practiceId, fetchPracticeConfig]);\n\n  // Initialize URL parameters on mount\n  useEffect(() => {\n    parseUrlParams();\n  }, [parseUrlParams]);\n\n  // Fetch practice config when practiceId changes\n  // Only fetch if authenticated (or guest access enabled) and practiceId is not empty\n  useEffect(() => {\n    if ((isAuthenticated || allowUnauthenticated) && practiceId) {\n      fetchPracticeConfig(practiceId);\n    }\n  }, [practiceId, isAuthenticated, allowUnauthenticated, fetchPracticeConfig]);\n\n  useEffect(() => {\n    if (!practiceId) return;\n    if (refreshKey === undefined) return;\n    if (refreshKeyRef.current === refreshKey) return;\n    refreshKeyRef.current = refreshKey;\n    fetchedPracticeIds.current.delete(practiceId);\n    fetchPracticeConfig(practiceId);\n  }, [fetchPracticeConfig, practiceId, refreshKey]);\n\n  return {\n    practiceId,\n    practiceConfig,\n    practiceNotFound,\n    isLoading,\n    handleRetryPracticeConfig,\n    setPracticeId\n  };\n}; \n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/usePracticeDetails.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/usePracticeManagement.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":547,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":547,"endColumn":23,"suggestions":[{"fix":{"range":[21426,21515],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":751,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":751,"endColumn":23,"suggestions":[{"fix":{"range":[28660,28724],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":801,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":801,"endColumn":23,"suggestions":[{"fix":{"range":[30328,30403],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":841,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":841,"endColumn":27,"suggestions":[{"fix":{"range":[32015,32079],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":855,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":855,"endColumn":29,"suggestions":[{"fix":{"range":[32663,32727],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":906,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":906,"endColumn":20,"suggestions":[{"fix":{"range":[34483,34530],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":924,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":924,"endColumn":20,"suggestions":[{"fix":{"range":[35129,35221],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":955,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":955,"endColumn":28,"suggestions":[{"fix":{"range":[36458,36569],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":960,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":960,"endColumn":28,"suggestions":[{"fix":{"range":[36779,36897],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":975,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":975,"endColumn":24,"suggestions":[{"fix":{"range":[37437,37491],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":986,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":986,"endColumn":22,"suggestions":[{"fix":{"range":[38003,38103],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":988,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":988,"endColumn":22,"suggestions":[{"fix":{"range":[38127,38200],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1023,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1023,"endColumn":21,"suggestions":[{"fix":{"range":[39252,39343],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1251,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1251,"endColumn":26,"suggestions":[{"fix":{"range":[47080,47139],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1256,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1256,"endColumn":26,"suggestions":[{"fix":{"range":[47263,47365],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1261,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1261,"endColumn":26,"suggestions":[{"fix":{"range":[47476,47559],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios, { type AxiosRequestConfig } from 'axios';\nimport { atom } from 'nanostores';\nimport { useStore } from '@nanostores/preact';\nimport { useState, useCallback, useEffect, useRef } from 'preact/hooks';\nimport { getPracticeWorkspaceEndpoint } from '@/config/api';\nimport { getBackendApiUrl } from '@/config/urls';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport {\n  listPractices,\n  createPractice as apiCreatePractice,\n  updatePractice as apiUpdatePractice,\n  type PracticeDetailsUpdate,\n  type PracticeDetails,\n  getPracticeDetails,\n  getPracticeDetailsBySlug,\n  getOnboardingStatusPayload,\n  updatePracticeDetails as apiUpdatePracticeDetails,\n  deletePractice as apiDeletePractice,\n  listPracticeInvitations,\n  createPracticeInvitation,\n  respondToPracticeInvitation,\n  listPracticeMembers,\n  updatePracticeMemberRole as apiUpdatePracticeMemberRole,\n  deletePracticeMember as apiDeletePracticeMember,\n  clearPublicPracticeDetailsCache\n} from '@/shared/lib/apiClient';\nimport { normalizeSubscriptionStatus as normalizePracticeStatus } from '@/shared/utils/subscription';\nimport { resetPracticeDetailsStore, setPracticeDetailsEntry } from '@/shared/stores/practiceDetailsStore';\nimport { asMajor, type MajorAmount } from '@/shared/utils/money';\nimport { normalizePracticeRole, type PracticeRole } from '@/shared/utils/practiceRoles';\n\nconst ENABLE_PAYOUT_STATUS = import.meta.env.VITE_ENABLE_PAYOUTS === 'true';\n\nconst isPlainObject = (value: unknown): value is Record<string, unknown> =>\n  typeof value === 'object' && value !== null && !Array.isArray(value);\n\ntype SharedPracticeSnapshot = {\n  practices: Practice[];\n  currentPractice: Practice | null;\n};\n\nlet sharedPracticeSnapshot: SharedPracticeSnapshot | null = null;\nlet sharedPracticePromise: Promise<SharedPracticeSnapshot> | null = null;\nlet sharedPracticeUserId: string | null = null;\nlet sharedPracticeIncludesDetails = false;\n\nconst resetSharedPracticeCache = () => {\n  sharedPracticeSnapshot = null;\n  sharedPracticePromise = null;\n  sharedPracticeUserId = null;\n  sharedPracticeIncludesDetails = false;\n};\n\nconst membersStore = atom<Record<string, Member[]>>({});\nconst membersLoaded = new Set<string>();\nconst membersInFlight = new Map<string, Promise<Member[]>>();\nlet membersCacheUserId: string | null = null;\n\nconst resetMembersCache = () => {\n  membersStore.set({});\n  membersLoaded.clear();\n  membersInFlight.clear();\n  membersCacheUserId = null;\n};\n\nconst setMembersForPractice = (practiceId: string, nextMembers: Member[]) => {\n  if (!practiceId) return;\n  const snapshot = membersStore.get();\n  membersStore.set({ ...snapshot, [practiceId]: nextMembers });\n};\n\n// Types\nexport type Role = PracticeRole;\nexport type BusinessOnboardingStatus = 'not_required' | 'pending' | 'completed' | 'skipped';\nexport type MatterWorkflowStatus = 'lead' | 'open' | 'in_progress' | 'completed' | 'archived';\n\nexport interface MatterTransitionResult {\n  matterId: string;\n  status: MatterWorkflowStatus;\n  previousStatus: MatterWorkflowStatus;\n  updatedAt: string;\n  acceptedBy?: {\n    userId: string;\n    acceptedAt: string | null;\n  } | null;\n  success?: boolean;\n  error?: string;\n}\n\n// Practice interface - matches apiClient.ts but kept here for backward compatibility\n// and to include additional properties specific to practice management\nexport interface Practice {\n  id: string;\n  slug: string;\n  name: string;\n  description?: string;\n  betterAuthOrgId?: string;\n  stripeCustomerId?: string | null;\n  currency?: string | null;\n  consultationFee: MajorAmount | null;\n  paymentUrl: string | null;\n  seats?: number | null;\n  subscriptionStatus?: 'none' | 'trialing' | 'active' | 'past_due' | 'canceled' | 'incomplete' | 'incomplete_expired' | 'unpaid' | 'paused';\n  subscriptionPeriodEnd?: number | null;\n  config?: {\n    ownerEmail?: string;\n    metadata?: Record<string, unknown>;\n    description?: string;\n    [key: string]: unknown; // Allow additional config properties\n  };\n  kind?: 'personal' | 'business' | 'practice';\n  isPersonal?: boolean | null;\n  businessOnboardingStatus?: BusinessOnboardingStatus;\n  businessOnboardingCompletedAt?: number | null;\n  businessOnboardingSkipped?: boolean;\n  businessOnboardingHasDraft?: boolean;\n  // Additional fields from apiClient\n  logo?: string | null;\n  metadata?: Record<string, unknown> | null;\n  businessPhone: string | null;\n  businessEmail: string | null;\n  calendlyUrl: string | null;\n  createdAt?: string | null;\n  updatedAt?: string | null;\n  billingIncrementMinutes?: number | null;\n  website?: string | null;\n  address?: string | null;\n  apartment?: string | null;\n  city?: string | null;\n  state?: string | null;\n  postalCode?: string | null;\n  country?: string | null;\n  primaryColor?: string | null;\n  accentColor?: string | null;\n  introMessage?: string | null;\n  isPublic?: boolean | null;\n  services?: Array<Record<string, unknown>> | null;\n}\n\nexport interface Member {\n  userId: string;\n  role: Role;\n  email: string;\n  name?: string;\n  image?: string;\n  createdAt: number;\n}\n\nexport interface Invitation {\n  id: string;\n  practiceId: string;\n  practiceName?: string;\n  email: string;\n  role: Role;\n  status: 'pending' | 'accepted' | 'declined';\n  invitedBy: string;\n  expiresAt: number;\n  createdAt: number;\n}\n\nexport interface CreatePracticeData {\n  name: string;\n  slug?: string;\n  description?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface UpdatePracticeData {\n  name?: string;\n  slug?: string;\n  description?: string;\n  businessPhone?: string;\n  businessEmail?: string;\n  consultationFee?: MajorAmount | null;\n  logo?: string;\n  metadata?: Record<string, unknown>;\n}\n\ninterface UsePracticeManagementOptions {\n  /**\n   * When true (default), the hook will automatically fetch practices\n   * once the session is available. Tests and advanced callers can disable\n   * this to take full control over when loading happens via `refetch()`.\n   */\n  autoFetchPractices?: boolean;\n  /**\n   * When true (default), the hook will fetch pending invitations for the\n   * current user. Disable this if you don't need invitations for a given\n   * screen or test.\n   */\n  fetchInvitations?: boolean;\n  /**\n   * When true, fetches practice details for the active practice and merges\n   * them into the practice list snapshot.\n   */\n  fetchPracticeDetails?: boolean;\n}\n\ninterface UsePracticeManagementReturn {\n  // Practice CRUD\n  practices: Practice[];\n  currentPractice: Practice | null;\n  loading: boolean;\n  error: string | null;\n  \n  // Practice operations\n  createPractice: (data: CreatePracticeData) => Promise<Practice>;\n  updatePractice: (id: string, data: UpdatePracticeData) => Promise<void>;\n  updatePracticeDetails: (id: string, details: PracticeDetailsUpdate) => Promise<PracticeDetails | null>;\n  deletePractice: (id: string) => Promise<void>;\n  \n  // Team management\n  getMembers: (practiceId: string) => Member[];\n  fetchMembers: (practiceId: string, options?: { force?: boolean }) => Promise<void>;\n  updateMemberRole: (practiceId: string, userId: string, role: Role) => Promise<void>;\n  removeMember: (practiceId: string, userId: string) => Promise<void>;\n  \n  // Invitations\n  invitations: Invitation[];\n  sendInvitation: (practiceId: string, email: string, role: Role) => Promise<void>;\n  acceptInvitation: (invitationId: string) => Promise<void>;\n  declineInvitation: (invitationId: string) => Promise<void>;\n  \n  // Workspace data\n  getWorkspaceData: (practiceId: string, resource: string) => Record<string, unknown>[];\n  fetchWorkspaceData: (practiceId: string, resource: string) => Promise<void>;\n  \n  // Matter workflows\n  acceptMatter: (practiceId: string, matterId: string) => Promise<MatterTransitionResult>;\n  rejectMatter: (practiceId: string, matterId: string, reason?: string) => Promise<MatterTransitionResult>;\n  updateMatterStatus: (practiceId: string, matterId: string, status: MatterWorkflowStatus, reason?: string) => Promise<MatterTransitionResult>;\n  \n  refetch: () => Promise<void>;\n}\n\nfunction normalizePracticeRecord(raw: Record<string, unknown>): Practice {\n  const id = typeof raw.id === 'string' ? raw.id : String(raw.id ?? '');\n  const slug = typeof raw.slug === 'string' ? raw.slug : id;\n  const name = typeof raw.name === 'string' ? raw.name : 'Practice';\n\n  const rawIsPersonal = typeof raw.isPersonal === 'boolean' ? raw.isPersonal : undefined;\n\n  const rawStatus = typeof raw.subscriptionStatus === 'string' ? raw.subscriptionStatus : undefined;\n\n  const rawKind = typeof raw.kind === 'string' ? raw.kind : undefined;\n  const resolvedKind = rawKind === 'business' || rawKind === 'personal' || rawKind === 'practice'\n    ? rawKind\n    : undefined;\n  const normalizedStatus = normalizePracticeStatus(rawStatus);\n\n  const seats = typeof raw.seats === 'number'\n    ? raw.seats\n    : typeof raw.seats === 'string' && raw.seats.trim().length > 0\n      ? Number.parseInt(raw.seats, 10) || null\n      : null;\n\n  const subscriptionPeriodEnd = (() => {\n    // Preserve explicit null; coalesce camelCase and snake_case; allow undefined if missing\n    const camel = (raw as Record<string, unknown>).subscriptionPeriodEnd;\n    const snake = (raw as Record<string, unknown>).subscription_period_end;\n    const val = camel !== undefined ? camel : snake;\n    if (val === null) return null;\n    if (typeof val === 'number') return val;\n    if (typeof val === 'string' && val.trim().length > 0) {\n      const n = Number.parseInt(val, 10);\n      return Number.isFinite(n) ? n : undefined;\n    }\n    return undefined;\n  })();\n\n  // Parse config once for reuse (may contain profile fields)\n  const cfg = (() => {\n    const c = (raw as Record<string, unknown>).config as unknown;\n    if (c && typeof c === 'object' && !Array.isArray(c)) {\n      return c as Practice['config'] & { description?: string };\n    }\n    const metadata = (raw as Record<string, unknown>).metadata;\n    if (metadata && typeof metadata === 'object' && !Array.isArray(metadata)) {\n      return {\n        metadata: metadata as Record<string, unknown>\n      } as Practice['config'] & { description?: string };\n    }\n    return undefined as Practice['config'] & { description?: string } | undefined;\n  })();\n  const metadataRecord = (() => {\n    const direct = (raw as Record<string, unknown>).metadata;\n    if (isPlainObject(direct)) {\n      return direct as Record<string, unknown>;\n    }\n    if (cfg && isPlainObject(cfg.metadata)) {\n      return cfg.metadata as Record<string, unknown>;\n    }\n    return null;\n  })();\n  const betterAuthOrgId = (() => {\n    const direct = (raw as Record<string, unknown>).betterAuthOrgId;\n    if (typeof direct === 'string' && direct.trim().length > 0) return direct;\n    const fromCfg = cfg && (cfg as unknown as { betterAuthOrgId?: string }).betterAuthOrgId;\n    if (typeof fromCfg === 'string' && fromCfg.trim().length > 0) return fromCfg;\n    return id; // fallback to our DB id, aligned with backend mapping\n  })();\n\n  const onboardingCompletedAt = (() => {\n    const camel = (raw as Record<string, unknown>).businessOnboardingCompletedAt;\n    const snake = (raw as Record<string, unknown>).business_onboarding_completed_at;\n    const value = camel !== undefined ? camel : snake;\n    if (value === null) return null;\n    if (typeof value === 'number') return value;\n    if (typeof value === 'string' && value.trim().length > 0) {\n      const ts = new Date(value.trim()).getTime();\n      return Number.isFinite(ts) ? ts : null;\n    }\n    return undefined;\n  })();\n\n  const onboardingSkipped = (() => {\n    const camel = (raw as Record<string, unknown>).businessOnboardingSkipped;\n    const snake = (raw as Record<string, unknown>).business_onboarding_skipped;\n    const value = camel !== undefined ? camel : snake;\n    if (typeof value === 'boolean') return value;\n    if (typeof value === 'number') return value === 1;\n    if (typeof value === 'string') {\n      const normalized = value.trim().toLowerCase();\n      return normalized === '1' || normalized === 'true';\n    }\n    return undefined;\n  })();\n\n  const onboardingData = (() => {\n    const camel = (raw as Record<string, unknown>).businessOnboardingData;\n    const snake = (raw as Record<string, unknown>).business_onboarding_data;\n    const value = camel !== undefined ? camel : snake;\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n      return value as Record<string, unknown>;\n    }\n    if (typeof value === 'string' && value.trim().length > 0) {\n      try {\n        return JSON.parse(value) as Record<string, unknown>;\n      } catch {\n        return null;\n      }\n    }\n    return null;\n  })();\n\n  const onboardingStatus: BusinessOnboardingStatus = (() => {\n    if (resolvedKind === 'personal') {\n      return 'not_required';\n    }\n    if (typeof onboardingCompletedAt === 'number') {\n      return 'completed';\n    }\n    if (onboardingSkipped) {\n      return 'skipped';\n    }\n    return 'pending';\n  })();\n\n  const getDetailString = (camel: string, snake: string): string | null | undefined => {\n    const candidate =\n      (raw as Record<string, unknown>)[camel] ?? (raw as Record<string, unknown>)[snake];\n    if (candidate === null) return null;\n    if (typeof candidate === 'string') {\n      return candidate;\n    }\n    return undefined;\n  };\n\n  const getDetailBoolean = (camel: string, snake: string): boolean | null | undefined => {\n    const candidate =\n      (raw as Record<string, unknown>)[camel] ?? (raw as Record<string, unknown>)[snake];\n    if (candidate === null) return null;\n    if (typeof candidate === 'boolean') return candidate;\n    if (typeof candidate === 'number') return candidate === 1;\n    if (typeof candidate === 'string') {\n      const normalized = candidate.trim().toLowerCase();\n      if (normalized === 'true') return true;\n      if (normalized === 'false') return false;\n    }\n    return undefined;\n  };\n  const getDetailNumber = (camel: string, snake: string): number | null | undefined => {\n    const candidate =\n      (raw as Record<string, unknown>)[camel] ?? (raw as Record<string, unknown>)[snake];\n    if (candidate === null) return null;\n    if (typeof candidate === 'number' && Number.isFinite(candidate)) return candidate;\n    if (typeof candidate === 'string' && candidate.trim().length > 0) {\n      const parsed = Number(candidate);\n      return Number.isFinite(parsed) ? parsed : undefined;\n    }\n    return undefined;\n  };\n\n  const services = (() => {\n    const candidate =\n      (raw as Record<string, unknown>).services ?? (raw as Record<string, unknown>).services_list;\n    if (candidate === null) return null;\n    if (Array.isArray(candidate)) return candidate as Array<Record<string, unknown>>;\n    return undefined;\n  })();\n\n  const topLevelDescription = (() => {\n    const candidate = raw.description ?? raw.overview;\n    return typeof candidate === 'string' && candidate.trim().length > 0 ? candidate : undefined;\n  })();\n  const configDescription = (() => {\n    const desc = cfg && (cfg as Record<string, unknown>).description;\n    return typeof desc === 'string' && desc.trim().length > 0 ? desc : undefined;\n  })();\n  const metadataDescription = (() => {\n    const metadata = cfg && (cfg as Record<string, unknown>).metadata;\n    if (!metadata || typeof metadata !== 'object' || Array.isArray(metadata)) return undefined;\n    const desc = (metadata as Record<string, unknown>).description;\n    return typeof desc === 'string' && desc.trim().length > 0 ? desc : undefined;\n  })();\n\n  return {\n    id,\n    slug,\n    name,\n    description: topLevelDescription ?? configDescription ?? metadataDescription,\n    stripeCustomerId: (() => {\n      const val = (raw.stripeCustomerId ?? raw.stripe_customer_id ?? null);\n      return typeof val === 'string' && val.trim().length > 0 ? val : null;\n    })(),\n    consultationFee: (() => {\n      const val = raw.consultationFee ?? raw.consultation_fee ?? null;\n      if (val === null) return null;\n      if (typeof val === 'number' && Number.isFinite(val)) return asMajor(val);\n      if (typeof val === 'string' && val.trim().length > 0) {\n        const num = Number(val);\n        return Number.isFinite(num) ? asMajor(num) : null;\n      }\n      return null;\n    })(),\n    currency: (typeof raw.currency === 'string' && raw.currency.trim().length > 0)\n      ? raw.currency.trim()\n      : null,\n    paymentUrl: (() => {\n      const val = raw.paymentUrl ?? raw.payment_url ?? null;\n      return typeof val === 'string' && val.trim().length > 0 ? val : null;\n    })(),\n    businessPhone: getDetailString('businessPhone', 'business_phone') ?? null,\n    businessEmail: getDetailString('businessEmail', 'business_email') ?? null,\n    calendlyUrl: getDetailString('calendlyUrl', 'calendly_url') ?? null,\n    logo: getDetailString('logo', 'logo') ?? null,\n    seats,\n    subscriptionStatus: normalizedStatus,\n    subscriptionPeriodEnd,\n    metadata: metadataRecord,\n    config: cfg,\n    betterAuthOrgId,\n    kind: resolvedKind,\n    isPersonal: rawIsPersonal ?? (resolvedKind === 'personal'),\n    businessOnboardingCompletedAt: onboardingCompletedAt,\n    businessOnboardingSkipped: onboardingSkipped,\n    businessOnboardingHasDraft: onboardingData != null && Object.keys(onboardingData).length > 0,\n    businessOnboardingStatus: onboardingStatus,\n    billingIncrementMinutes: getDetailNumber('billingIncrementMinutes', 'billing_increment_minutes') ?? null,\n    website: getDetailString('website', 'website'),\n    address: getDetailString('address', 'address_line_1'),\n    apartment: getDetailString('apartment', 'address_line_2'),\n    city: getDetailString('city', 'city'),\n    state: getDetailString('state', 'state'),\n    postalCode: getDetailString('postalCode', 'postal_code'),\n    country: getDetailString('country', 'country'),\n    primaryColor: getDetailString('primaryColor', 'primary_color'),\n    accentColor: getDetailString('accentColor', 'accent_color'),\n    introMessage: getDetailString('introMessage', 'intro_message'),\n    isPublic: getDetailBoolean('isPublic', 'is_public'),\n    services\n  };\n}\n\nconst fetchPracticeDetailsFor = async (\n  practice: Practice,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<PracticeDetails | null> => {\n  const byId = await getPracticeDetails(practice.id, config);\n  if (byId) {\n    return byId;\n  }\n  const slug = practice.slug?.trim();\n  if (slug) {\n    return getPracticeDetailsBySlug(slug, config);\n  }\n  return null;\n};\n\nfunction mergePracticeDetails(practice: Practice, details: PracticeDetails | null): Practice {\n  if (!details) {\n    return practice;\n  }\n  const patch: Partial<Practice> = {};\n  const setIfDefined = <K extends keyof Practice>(key: K, value: Practice[K] | undefined) => {\n    if (value !== undefined) {\n      patch[key] = value;\n    }\n  };\n  const setIfNonNull = <K extends keyof Practice>(key: K, value: Practice[K] | undefined | null) => {\n    if (value !== undefined && value !== null) {\n      patch[key] = value as Practice[K];\n    }\n  };\n\n  setIfDefined('businessPhone', details.businessPhone as Practice['businessPhone'] | undefined);\n  setIfDefined('businessEmail', details.businessEmail as Practice['businessEmail'] | undefined);\n  setIfDefined('consultationFee', details.consultationFee as Practice['consultationFee'] | undefined);\n  setIfDefined('paymentUrl', details.paymentUrl as Practice['paymentUrl'] | undefined);\n  setIfDefined('calendlyUrl', details.calendlyUrl as Practice['calendlyUrl'] | undefined);\n  setIfDefined('billingIncrementMinutes', details.billingIncrementMinutes as Practice['billingIncrementMinutes'] | undefined);\n  setIfNonNull('website', details.website as Practice['website'] | undefined | null);\n  setIfNonNull('address', details.address as Practice['address'] | undefined | null);\n  setIfNonNull('apartment', details.apartment as Practice['apartment'] | undefined | null);\n  setIfNonNull('city', details.city as Practice['city'] | undefined | null);\n  setIfNonNull('state', details.state as Practice['state'] | undefined | null);\n  setIfNonNull('postalCode', details.postalCode as Practice['postalCode'] | undefined | null);\n  setIfNonNull('country', details.country as Practice['country'] | undefined | null);\n  setIfNonNull('primaryColor', details.primaryColor as Practice['primaryColor'] | undefined | null);\n  setIfNonNull('accentColor', details.accentColor as Practice['accentColor'] | undefined | null);\n  setIfNonNull('introMessage', details.introMessage as Practice['introMessage'] | undefined | null);\n  setIfNonNull('description', details.description as Practice['description'] | undefined | null);\n  setIfDefined('isPublic', details.isPublic as Practice['isPublic'] | undefined);\n  setIfDefined('services', details.services as Practice['services'] | undefined);\n  return {\n    ...practice,\n    ...patch\n  };\n}\n\nfunction normalizeWorkflowStatus(value: unknown): MatterWorkflowStatus {\n  const str = typeof value === 'string' ? value.toLowerCase() : '';\n  switch (str) {\n    case 'lead':\n    case 'open':\n    case 'in_progress':\n    case 'completed':\n    case 'archived':\n      return str;\n    default:\n      try {\n        // Use app logger if available; fallback to console\n        const maybeLogger = (globalThis as unknown as { appLogger?: { warn: (msg: string, data?: unknown) => void } }).appLogger;\n        if (maybeLogger && typeof maybeLogger.warn === 'function') {\n          maybeLogger.warn('normalizeWorkflowStatus: unexpected value', { value, type: typeof value });\n        } else {\n          console.warn('normalizeWorkflowStatus: unexpected value', { value, type: typeof value });\n        }\n      } catch (e) { void e; }\n      return 'lead';\n  }\n}\n\nfunction normalizeMatterTransitionResult(raw: unknown): MatterTransitionResult {\n  if (!raw || typeof raw !== 'object' || raw === null) {\n    throw new Error('Invalid matter transition response');\n  }\n\n  const record = raw as Record<string, unknown>;\n  const acceptedByRaw = record.acceptedBy as Record<string, unknown> | null | undefined;\n  const acceptedBy = acceptedByRaw && typeof acceptedByRaw === 'object'\n    ? {\n        userId: typeof acceptedByRaw.userId === 'string'\n          ? acceptedByRaw.userId\n          : String(acceptedByRaw.userId ?? ''),\n        acceptedAt: typeof acceptedByRaw.acceptedAt === 'string'\n          ? acceptedByRaw.acceptedAt\n          : null\n      }\n    : null;\n\n  return {\n    matterId: typeof record.matterId === 'string'\n      ? record.matterId\n      : String(record.matterId ?? ''),\n    status: normalizeWorkflowStatus(record.status),\n    previousStatus: normalizeWorkflowStatus(record.previousStatus),\n    updatedAt: (() => {\n      if (typeof record.updatedAt !== 'string' || record.updatedAt.trim().length === 0) {\n        throw new Error('Missing or invalid updatedAt in matter transition response');\n      }\n      return record.updatedAt;\n    })(),\n    acceptedBy,\n    success: typeof record.success === 'boolean' ? record.success : undefined,\n    error: typeof record.error === 'string' ? record.error : undefined\n  };\n}\n\nfunction resolveStripeDetailsSubmitted(payload: unknown): boolean | null {\n  let current = payload;\n  const visited = new Set<unknown>();\n\n  while (\n    current &&\n    typeof current === 'object' &&\n    'data' in (current as Record<string, unknown>) &&\n    (current as Record<string, unknown>).data !== undefined &&\n    !visited.has(current)\n  ) {\n    visited.add(current);\n    current = (current as Record<string, unknown>).data;\n  }\n\n  if (!current || typeof current !== 'object') {\n    return null;\n  }\n\n  const record = current as Record<string, unknown>;\n  const candidate = record.details_submitted ?? record.detailsSubmitted;\n  return typeof candidate === 'boolean' ? candidate : null;\n}\n\nfunction _generateIdempotencyKey(): string {\n  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\n    return crypto.randomUUID();\n  }\n  return `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;\n}\n\nexport function usePracticeManagement(options: UsePracticeManagementOptions = {}): UsePracticeManagementReturn {\n  const {\n    autoFetchPractices = true,\n    fetchInvitations: shouldFetchInvitations = true,\n    fetchPracticeDetails = false,\n  } = options;\n  const { session, isPending: sessionLoading, isAnonymous, activeOrganizationId } = useSessionContext();\n  const [practices, setPractices] = useState<Practice[]>([]);\n  const [currentPractice, setCurrentPractice] = useState<Practice | null>(null);\n  const members = useStore(membersStore);\n  const [invitations, setInvitations] = useState<Invitation[]>([]);\n  const [workspaceData, setWorkspaceData] = useState<Record<string, Record<string, Record<string, unknown>[]>>>({});\n  // Initialize loading to true when autoFetchPractices is enabled\n  // This ensures the UI shows a loading state during the first render before the fetch effect runs\n  const [loading, setLoading] = useState(autoFetchPractices);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Track if we've already fetched practices to prevent duplicate calls\n  const practicesFetchedRef = useRef(false);\n  const currentRequestRef = useRef<AbortController | null>(null);\n  const resolvedUserId = !session?.user || isAnonymous ? null : session.user.id;\n\n  useEffect(() => {\n    if (membersCacheUserId !== resolvedUserId) {\n      resetMembersCache();\n      membersCacheUserId = resolvedUserId;\n    }\n  }, [resolvedUserId]);\n\n  // Helper for workspace/local endpoints still served by the Worker\n  const workspaceCall = useCallback(async (url: string, options: RequestInit = {}, timeoutMs: number = 15000) => {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n    try {\n      const headers = new Headers(options.headers || {});\n      headers.set('Content-Type', 'application/json');\n\n      const response = await fetch(url, {\n        ...options,\n        credentials: 'include',\n        headers,\n        signal: controller.signal,\n      });\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(response.statusText || `HTTP ${response.status}`);\n      }\n\n      if (response.status === 204) {\n        return {};\n      }\n\n      const contentType = response.headers.get('content-type');\n      if (!contentType || !contentType.includes('application/json')) {\n        return {};\n      }\n\n      try {\n        return await response.json();\n      } catch {\n        return {};\n      }\n    } catch (error) {\n      clearTimeout(timeoutId);\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error('Request timed out');\n      }\n      throw error;\n    }\n  }, []);\n\n  // Helper functions to get data by practiceId\n  const getMembers = useCallback((practiceId: string): Member[] => {\n    return members[practiceId] || [];\n  }, [members]);\n\n\n  const getWorkspaceData = useCallback((practiceId: string, resource: string): Record<string, unknown>[] => {\n    return workspaceData[practiceId]?.[resource] || [];\n  }, [workspaceData]);\n\n  // Fetch user's practices\n  const fetchPractices = useCallback(async () => {\n    let currentFetchPromise: Promise<SharedPracticeSnapshot> | null = null;\n    try {\n      if (practicesFetchedRef.current && session?.user && (!fetchPracticeDetails || sharedPracticeIncludesDetails)) {\n        return;\n      }\n\n      const userId = session?.user?.id ?? null;\n      if (!userId || isAnonymous) {\n        setPractices([]);\n        setCurrentPractice(null);\n        setLoading(false);\n        practicesFetchedRef.current = false;\n        resetSharedPracticeCache();\n        resetPracticeDetailsStore();\n        clearPublicPracticeDetailsCache();\n        return;\n      }\n\n      if (sharedPracticeUserId && sharedPracticeUserId !== userId) {\n        resetSharedPracticeCache();\n      }\n\n      const applySnapshot = (snapshot: SharedPracticeSnapshot) => {\n        setPractices(snapshot.practices);\n        setCurrentPractice(snapshot.currentPractice);\n        setLoading(false);\n        practicesFetchedRef.current = true;\n      };\n\n      const hydrateSnapshotDetails = async (snapshot: SharedPracticeSnapshot) => {\n        if (!fetchPracticeDetails) return snapshot;\n        if (!snapshot.currentPractice) return snapshot;\n\n        if (currentRequestRef.current) {\n          currentRequestRef.current.abort();\n        }\n\n        const controller = new AbortController();\n        currentRequestRef.current = controller;\n\n        let details: PracticeDetails | null = null;\n        try {\n          details = await fetchPracticeDetailsFor(snapshot.currentPractice, { signal: controller.signal });\n          setPracticeDetailsEntry(snapshot.currentPractice.id, details);\n        } catch (detailsError) {\n          console.warn('Failed to fetch practice details:', detailsError);\n        }\n\n        if (!details) {\n          return snapshot;\n        }\n\n        const updatedCurrentPractice = mergePracticeDetails(snapshot.currentPractice, details);\n        const updatedPractices = snapshot.practices.map((practice) =>\n          practice.id === snapshot.currentPractice?.id\n            ? mergePracticeDetails(practice, details)\n            : practice\n        );\n\n        const updatedSnapshot = {\n          practices: updatedPractices,\n          currentPractice: updatedCurrentPractice\n        };\n        sharedPracticeSnapshot = updatedSnapshot;\n        sharedPracticeIncludesDetails = true;\n        return updatedSnapshot;\n      };\n\n      if (sharedPracticeSnapshot) {\n        if (!fetchPracticeDetails || sharedPracticeIncludesDetails || !sharedPracticeSnapshot.currentPractice) {\n          applySnapshot(sharedPracticeSnapshot);\n          return;\n        }\n\n        setLoading(true);\n        setError(null);\n        const hydrated = await hydrateSnapshotDetails(sharedPracticeSnapshot);\n        applySnapshot(hydrated);\n        return;\n      }\n\n      if (sharedPracticePromise) {\n        const cachedPromise = sharedPracticePromise;\n        try {\n          const cached = await sharedPracticePromise;\n          if (fetchPracticeDetails && !sharedPracticeIncludesDetails && cached.currentPractice) {\n            setLoading(true);\n            setError(null);\n            const hydrated = await hydrateSnapshotDetails(cached);\n            applySnapshot(hydrated);\n            return;\n          }\n          applySnapshot(cached);\n          return;\n        } catch (_err) {\n          console.warn('Cached practice promise failed, retrying with fresh fetch.');\n          if (sharedPracticePromise === cachedPromise) {\n            sharedPracticePromise = null;\n          }\n        }\n      }\n\n      if (currentRequestRef.current) {\n        currentRequestRef.current.abort();\n      }\n\n      const controller = new AbortController();\n      currentRequestRef.current = controller;\n\n      setLoading(true);\n      setError(null);\n\n      sharedPracticePromise = (async () => {\n        const rawPracticeList = await listPractices({ signal: controller.signal, scope: 'all' });\n\n        const normalizedList = rawPracticeList\n          .filter((item): item is Practice => typeof item === 'object' && item !== null)\n          .map((practice) => normalizePracticeRecord(practice as unknown as Record<string, unknown>))\n          .filter((practice) => practice.id.length > 0);\n\n        const activeOrgId = activeOrganizationId ?? null;\n        const activePractice = activeOrgId\n          ? normalizedList.find(practice =>\n            practice.betterAuthOrgId === activeOrgId || practice.id === activeOrgId\n          )\n          : undefined;\n        const currentPracticeNext = activePractice || normalizedList[0] || null;\n        let details: PracticeDetails | null = null;\n        let stripeDetailsSubmitted: boolean | null = ENABLE_PAYOUT_STATUS ? null : false;\n        if (currentPracticeNext) {\n          if (fetchPracticeDetails) {\n            try {\n              details = await fetchPracticeDetailsFor(currentPracticeNext, { signal: controller.signal });\n              setPracticeDetailsEntry(currentPracticeNext.id, details);\n            } catch (detailsError) {\n              console.warn('Failed to fetch practice details:', detailsError);\n            }\n          }\n          if (ENABLE_PAYOUT_STATUS) {\n            try {\n              const payload = await getOnboardingStatusPayload(\n                currentPracticeNext.betterAuthOrgId ?? currentPracticeNext.id,\n                { signal: controller.signal }\n              );\n              stripeDetailsSubmitted = resolveStripeDetailsSubmitted(payload);\n            } catch (stripeError) {\n              if (axios.isAxiosError(stripeError) && stripeError.response?.status === 404) {\n                stripeDetailsSubmitted = false;\n              } else {\n                console.warn('Failed to fetch onboarding status:', stripeError);\n              }\n            }\n          }\n        }\n\n        const applyStripeOverride = (practice: Practice): Practice => {\n          if (stripeDetailsSubmitted === null || practice.id !== currentPracticeNext?.id) {\n            return practice;\n          }\n          return {\n            ...practice,\n            businessOnboardingStatus: stripeDetailsSubmitted ? 'completed' : 'pending',\n            businessOnboardingCompletedAt: stripeDetailsSubmitted\n              ? practice.businessOnboardingCompletedAt ?? Date.now()\n              : null\n          };\n        };\n\n        const mergedPractices = details\n          ? normalizedList.map((practice) =>\n            practice.id === currentPracticeNext?.id\n              ? applyStripeOverride(mergePracticeDetails(practice, details))\n              : practice\n          )\n          : normalizedList.map((practice) =>\n            practice.id === currentPracticeNext?.id\n              ? applyStripeOverride(practice)\n              : practice\n          );\n        const mergedCurrentPractice = currentPracticeNext\n          ? applyStripeOverride(mergePracticeDetails(currentPracticeNext, details))\n          : null;\n\n        sharedPracticeIncludesDetails = Boolean(details);\n\n        return { practices: mergedPractices, currentPractice: mergedCurrentPractice };\n      })();\n      currentFetchPromise = sharedPracticePromise;\n\n      const snapshot = await sharedPracticePromise;\n      sharedPracticeSnapshot = snapshot;\n      sharedPracticeUserId = userId;\n\n      setPractices(snapshot.practices);\n      setCurrentPractice(snapshot.currentPractice);\n      practicesFetchedRef.current = true;\n    } catch (err) {\n      if (err instanceof Error && err.name === 'CanceledError') {\n        return;\n      }\n      console.error('Error in fetchPractices:', err);\n      setError(err instanceof Error ? err.message : 'Failed to fetch practices');\n      setCurrentPractice(null);\n      setPractices([]);\n    } finally {\n      setLoading(false);\n      currentRequestRef.current = null;\n      if (sharedPracticePromise === currentFetchPromise) {\n        sharedPracticePromise = null;\n      }\n    }\n  }, [activeOrganizationId, fetchPracticeDetails, isAnonymous, session]);\n\n  // Fetch practice invitations\n  const fetchInvitations = useCallback(async () => {\n    if (!session?.user?.id || isAnonymous) return;\n\n    if (getBackendApiUrl().includes('staging')) {\n      console.debug('Skipping fetchInvitations on staging because invitations are not available');\n      return;\n    }\n\n    try {\n      // Use imported function directly\n      const rawInvitations = await listPracticeInvitations();\n\n      // Define valid role and status values\n      const validRoles: Role[] = ['owner', 'admin', 'attorney', 'paralegal', 'member', 'client'];\n      const validStatuses: Array<'pending' | 'accepted' | 'declined'> = ['pending', 'accepted', 'declined'];\n\n      const validatedInvitations = rawInvitations\n        .map(invitation => {\n          // Validate invitation structure manually\n          if (!invitation || typeof invitation !== 'object') {\n            return null;\n          }\n          const inv = invitation as Record<string, unknown>;\n          if (\n            typeof inv.id === 'string' &&\n            typeof inv.practiceId === 'string' &&\n            typeof inv.email === 'string' &&\n            typeof inv.role === 'string' &&\n            typeof inv.status === 'string' &&\n            typeof inv.invitedBy === 'string' &&\n            typeof inv.expiresAt === 'number' &&\n            typeof inv.createdAt === 'number'\n          ) {\n            const normalizedRole = normalizePracticeRole(inv.role);\n            if (!normalizedRole || !validRoles.includes(normalizedRole)) {\n              console.error('Invalid invitation role:', inv.role, 'Expected one of:', validRoles, 'Invitation:', invitation);\n              return null;\n            }\n            // Validate status is one of the allowed values\n            if (!validStatuses.includes(inv.status as 'pending' | 'accepted' | 'declined')) {\n              console.error('Invalid invitation status:', inv.status, 'Expected one of:', validStatuses, 'Invitation:', invitation);\n              return null;\n            }\n            return {\n              id: inv.id,\n              practiceId: inv.practiceId,\n              practiceName: typeof inv.practiceName === 'string' ? inv.practiceName : undefined,\n              email: inv.email,\n              role: normalizedRole,\n              status: inv.status as 'pending' | 'accepted' | 'declined',\n              invitedBy: inv.invitedBy,\n              expiresAt: inv.expiresAt,\n              createdAt: inv.createdAt,\n            } as Invitation;\n          }\n          console.error('Invalid invitation data:', invitation);\n          return null;\n        })\n        .filter((invitation): invitation is Invitation => invitation !== null);\n\n      setInvitations(validatedInvitations);\n    } catch (err: unknown) {\n      // Don't set global error for invitation failures as it blocks the main UI\n      const axiosError = err as { response?: { status: number, data: unknown }, message?: string };\n      if (axiosError.response) {\n        // Use debug for expected API errors (like 400 Invalid Practice UUID) to avoid console noise\n        console.debug('Failed to fetch invitations:', axiosError.response.status, axiosError.response.data);\n      } else {\n        console.debug('Failed to fetch invitations:', axiosError.message || err);\n      }\n      setInvitations([]);\n    }\n  }, [isAnonymous, session]);\n\n  // Create practice\n  const createPractice = useCallback(async (data: CreatePracticeData): Promise<Practice> => {\n    if (!data?.name || data.name.trim().length === 0) {\n      throw new Error('Practice name is required');\n    }\n\n    // Only include slug if user explicitly provided one - API will auto-generate otherwise\n    const slug = data.slug && data.slug.trim().length > 0 ? data.slug.trim() : undefined;\n    const baseMetadata = data.description\n      ? { description: data.description }\n      : undefined;\n    const metadata = data.metadata\n      ? {\n          ...(baseMetadata ?? {}),\n          ...data.metadata\n        }\n      : baseMetadata;\n\n    const practice = await apiCreatePractice({\n      name: data.name,\n      ...(slug ? { slug } : {}),\n      ...(metadata ? { metadata } : {})\n    });\n\n    if (practice?.id) {\n      try {\n        await apiUpdatePracticeDetails(practice.id, { isPublic: true });\n        practice.isPublic = true;\n      } catch (err) {\n        console.warn('[usePracticeManagement] Failed to enable public visibility by default', err);\n      }\n    }\n\n    const normalized = normalizePracticeRecord(practice as unknown as Record<string, unknown>);\n    practicesFetchedRef.current = false;\n    await fetchPractices();\n    if (shouldFetchInvitations) {\n      await fetchInvitations();\n    }\n    return normalized;\n  }, [fetchPractices, fetchInvitations, shouldFetchInvitations]);\n\n  // Update practice\n  const updatePractice = useCallback(async (id: string, data: UpdatePracticeData): Promise<void> => {\n    if (!id) {\n      throw new Error('Practice id is required for update');\n    }\n\n    const payload: Parameters<typeof apiUpdatePractice>[1] = {};\n\n    if (typeof data.name === 'string' && data.name.trim().length > 0) {\n      payload.name = data.name.trim();\n    }\n\n    if (typeof data.slug === 'string' && data.slug.trim().length > 0) {\n      // API handles slug normalization - just pass through user input\n      payload.slug = data.slug.trim();\n    }\n\n    if (typeof data.businessPhone === 'string' && data.businessPhone.trim().length > 0) {\n      payload.businessPhone = data.businessPhone.trim();\n    }\n\n    if (typeof data.businessEmail === 'string' && data.businessEmail.trim().length > 0) {\n      payload.businessEmail = data.businessEmail.trim();\n    }\n\n    if (data.consultationFee === null) {\n      payload.consultationFee = null;\n    } else if (typeof data.consultationFee === 'number' && Number.isFinite(data.consultationFee)) {\n      payload.consultationFee = data.consultationFee;\n    }\n\n    if (typeof data.logo === 'string' && data.logo.trim().length > 0) {\n      payload.logo = data.logo.trim();\n    }\n\n    const existingPractice = practices.find(practice => practice.id === id);\n    const metadataBase = (() => {\n      const direct = existingPractice?.metadata;\n      if (isPlainObject(direct)) {\n        return direct;\n      }\n      const config = existingPractice?.config;\n      if (isPlainObject(config)) {\n        const configMetadata = (config as Record<string, unknown>).metadata;\n        if (isPlainObject(configMetadata)) {\n          return configMetadata;\n        }\n        if ('conversationConfig' in config || 'onboarding' in config) {\n          return config;\n        }\n      }\n      return {};\n    })();\n\n    let metadataNext: Record<string, unknown> | null = null;\n\n    if (isPlainObject(data.metadata)) {\n      metadataNext = {\n        ...metadataBase,\n        ...data.metadata\n      };\n    }\n\n    if (typeof data.description === 'string') {\n      metadataNext = {\n        ...(metadataNext ?? metadataBase),\n        description: data.description\n      };\n    }\n\n    if (metadataNext) {\n      payload.metadata = metadataNext;\n    }\n\n    if (Object.keys(payload).length === 0) {\n      return;\n    }\n\n    const response = await apiUpdatePractice(id, payload);\n    const mergedResponse: Record<string, unknown> = {\n      ...(existingPractice ?? {}),\n      ...(response as unknown as Record<string, unknown>)\n    };\n    if (\n      existingPractice?.slug &&\n      mergedResponse.slug === mergedResponse.id &&\n      existingPractice.slug !== mergedResponse.slug\n    ) {\n      mergedResponse.slug = existingPractice.slug;\n    }\n    if (\n      existingPractice?.name &&\n      (mergedResponse.name === 'Practice' || !mergedResponse.name)\n    ) {\n      mergedResponse.name = existingPractice.name;\n    }\n    const updatedPractice = normalizePracticeRecord(mergedResponse);\n\n    if (sharedPracticeSnapshot) {\n      const nextPractices = sharedPracticeSnapshot.practices.map((practice) =>\n        practice.id === id ? updatedPractice : practice\n      );\n      const nextCurrentPractice = sharedPracticeSnapshot.currentPractice?.id === id\n        ? updatedPractice\n        : sharedPracticeSnapshot.currentPractice;\n      sharedPracticeSnapshot = {\n        practices: nextPractices,\n        currentPractice: nextCurrentPractice\n      };\n    }\n\n    setCurrentPractice((prev) => (prev?.id === id ? updatedPractice : prev));\n    setPractices((prev) =>\n      prev.map((practice) => (practice.id === id ? updatedPractice : practice))\n    );\n\n    if (shouldFetchInvitations) {\n      await fetchInvitations();\n    }\n  }, [fetchInvitations, practices, shouldFetchInvitations]);\n\n  const updatePracticeDetails = useCallback(async (id: string, details: PracticeDetailsUpdate): Promise<PracticeDetails | null> => {\n    if (!id) {\n      throw new Error('Practice id is required for details update');\n    }\n    const updatedDetails = await apiUpdatePracticeDetails(id, details);\n    setPracticeDetailsEntry(id, updatedDetails);\n    if (updatedDetails) {\n      if (sharedPracticeSnapshot) {\n        const nextPractices = sharedPracticeSnapshot.practices.map((practice) =>\n          practice.id === id ? mergePracticeDetails(practice, updatedDetails) : practice\n        );\n        const nextCurrentPractice = sharedPracticeSnapshot.currentPractice?.id === id\n          ? mergePracticeDetails(sharedPracticeSnapshot.currentPractice, updatedDetails)\n          : sharedPracticeSnapshot.currentPractice;\n        sharedPracticeSnapshot = {\n          practices: nextPractices,\n          currentPractice: nextCurrentPractice\n        };\n        if (sharedPracticeSnapshot.currentPractice?.id === id) {\n          sharedPracticeIncludesDetails = true;\n        }\n      }\n      setCurrentPractice((prev) => {\n        if (!prev || prev.id !== id) return prev;\n        return mergePracticeDetails(prev, updatedDetails);\n      });\n      setPractices((prev) =>\n        prev.map((practice) =>\n          practice.id === id ? mergePracticeDetails(practice, updatedDetails) : practice\n        )\n      );\n    }\n    return updatedDetails;\n  }, []);\n\n  // Delete practice\n  const deletePractice = useCallback(async (id: string): Promise<void> => {\n    if (!id) {\n      throw new Error('Practice id is required for deletion');\n    }\n    await apiDeletePractice(id);\n    practicesFetchedRef.current = false;\n    await fetchPractices();\n    if (shouldFetchInvitations) {\n      await fetchInvitations();\n    }\n  }, [fetchPractices, fetchInvitations, shouldFetchInvitations]);\n\n  // Fetch members\n  const fetchMembers = useCallback(async (\n    practiceId: string,\n    options: { force?: boolean } = {}\n  ): Promise<void> => {\n    if (!practiceId) return;\n\n    const force = options.force ?? false;\n    if (!force && membersLoaded.has(practiceId)) {\n      return;\n    }\n\n    const inFlight = membersInFlight.get(practiceId);\n    if (inFlight) {\n      await inFlight;\n      return;\n    }\n\n    const promise = (async () => {\n      const data = await listPracticeMembers(practiceId);\n      // Validate and normalize members manually\n    const validRoles: Role[] = ['owner', 'admin', 'attorney', 'paralegal', 'member', 'client'];\n\n      return (Array.isArray(data) ? data : [])\n        .map(m => {\n          if (!m || typeof m !== 'object') {\n            return null;\n          }\n          const member = m as Record<string, unknown>;\n          const userId = typeof member.userId === 'string'\n            ? member.userId\n            : (typeof member.user_id === 'string' ? member.user_id : null);\n          const normalizedRole = normalizePracticeRole(member.role);\n          const createdAtValue = member.createdAt ?? member.created_at ?? member.joined_at;\n          const createdAt = typeof createdAtValue === 'number'\n            ? createdAtValue\n            : (typeof createdAtValue === 'string' && createdAtValue.trim()\n              ? Number(createdAtValue)\n              : null);\n          const email = typeof member.email === 'string'\n            ? member.email\n            : (typeof (member.user as Record<string, unknown> | undefined)?.email === 'string'\n              ? (member.user as Record<string, unknown>).email as string\n              : '');\n\n          if (!userId) {\n            console.error('Invalid or missing member userId:', member);\n            return null;\n          }\n\n          if (!normalizedRole || !validRoles.includes(normalizedRole)) {\n            console.error('Invalid member role:', member.role, 'Expected one of:', validRoles, 'Member:', member);\n            return null;\n          }\n\n          if (typeof email !== 'string' || !email.trim()) {\n            console.error('Invalid or missing member email:', member.email, 'Member:', member);\n            return null;\n          }\n\n          return {\n            userId,\n            role: normalizedRole,\n            email,\n            name: typeof member.name === 'string' ? member.name : undefined,\n            image: typeof member.image === 'string' ? member.image : undefined,\n            createdAt: Number.isFinite(createdAt ?? NaN) ? (createdAt as number) : Date.now(),\n          } as Member;\n        })\n        .filter((m): m is Member => m !== null);\n    })();\n\n    membersInFlight.set(practiceId, promise);\n    try {\n      const normalizedMembers = await promise;\n      membersLoaded.add(practiceId);\n      setMembersForPractice(practiceId, normalizedMembers);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to fetch members');\n      membersLoaded.delete(practiceId);\n      setMembersForPractice(practiceId, []);\n      throw err;\n    } finally {\n      membersInFlight.delete(practiceId);\n    }\n  }, []);\n\n  // Update member role\n  const updateMemberRole = useCallback(async (practiceId: string, userId: string, role: Role): Promise<void> => {\n    await apiUpdatePracticeMemberRole(practiceId, { userId, role });\n    await fetchMembers(practiceId, { force: true });\n  }, [fetchMembers]);\n\n  // Remove member\n  const removeMember = useCallback(async (practiceId: string, userId: string): Promise<void> => {\n    await apiDeletePracticeMember(practiceId, userId);\n    await fetchMembers(practiceId, { force: true });\n  }, [fetchMembers]);\n\n  // Send invitation\n  const sendInvitation = useCallback(async (practiceId: string, email: string, role: Role): Promise<void> => {\n    await createPracticeInvitation(practiceId, { email, role });\n    await fetchInvitations();\n  }, [fetchInvitations]);\n\n  // Accept invitation\n  const acceptInvitation = useCallback(async (invitationId: string): Promise<void> => {\n    await respondToPracticeInvitation(invitationId, 'accept');\n    practicesFetchedRef.current = false;\n    await fetchPractices();\n    if (shouldFetchInvitations) {\n      await fetchInvitations();\n    }\n  }, [fetchPractices, fetchInvitations, shouldFetchInvitations]);\n\n  const declineInvitation = useCallback(async (invitationId: string): Promise<void> => {\n    await respondToPracticeInvitation(invitationId, 'decline');\n    await fetchInvitations();\n  }, [fetchInvitations]);\n\n  // Fetch workspace data\n  const fetchWorkspaceData = useCallback(async (practiceId: string, resource: string): Promise<void> => {\n    try {\n      const data = await workspaceCall(getPracticeWorkspaceEndpoint(practiceId, resource));\n      setWorkspaceData(prev => ({\n        ...prev,\n        [practiceId]: {\n          ...prev[practiceId],\n          [resource]: (data && data[resource]) || []\n        }\n      }));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to fetch workspace data');\n    }\n  }, [workspaceCall]);\n\n  const acceptMatter = useCallback(async (practiceId: string, matterId: string): Promise<MatterTransitionResult> => {\n    if (!practiceId || !matterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n\n    // Deterministic idempotency key derived from operation params\n    const idempotencyKey = `matter:${practiceId}:${matterId}:accept`;\n    const endpoint = `${getPracticeWorkspaceEndpoint(practiceId, 'matters')}/${encodeURIComponent(matterId)}/accept`;\n    const response = await workspaceCall(endpoint, {\n      method: 'POST',\n      headers: {\n        'Idempotency-Key': idempotencyKey\n      }\n    });\n\n    const result = normalizeMatterTransitionResult(response);\n    if (result.success === false || (typeof result.error === 'string' && result.error.trim().length > 0)) {\n      throw new Error(`Matter accept failed: ${result.error || 'Unknown error'}`);\n    }\n    return result;\n  }, [workspaceCall]);\n\n  const rejectMatter = useCallback(async (practiceId: string, matterId: string, reason?: string): Promise<MatterTransitionResult> => {\n    if (!practiceId || !matterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n\n    const endpoint = `${getPracticeWorkspaceEndpoint(practiceId, 'matters')}/${encodeURIComponent(matterId)}/reject`;\n    const payload: Record<string, unknown> = {};\n    if (typeof reason === 'string' && reason.trim().length > 0) {\n      payload.reason = reason.trim();\n    }\n\n    const response = await workspaceCall(endpoint, {\n      method: 'POST',\n      body: JSON.stringify(payload),\n      headers: {\n        // Deterministic idempotency key derived from operation params\n        'Idempotency-Key': `matter:${practiceId}:${matterId}:reject:${payload.reason ?? ''}`\n      }\n    });\n\n    const result = normalizeMatterTransitionResult(response);\n    if (result.success === false || (typeof result.error === 'string' && result.error.trim().length > 0)) {\n      throw new Error(`Matter reject failed: ${result.error || 'Unknown error'}`);\n    }\n    return result;\n  }, [workspaceCall]);\n\n  const updateMatterStatus = useCallback(async (practiceId: string, matterId: string, status: MatterWorkflowStatus, reason?: string): Promise<MatterTransitionResult> => {\n    if (!practiceId || !matterId) {\n      throw new Error('Practice ID and matter ID are required');\n    }\n\n    const endpoint = `${getPracticeWorkspaceEndpoint(practiceId, 'matters')}/${encodeURIComponent(matterId)}/status`;\n    const payload: Record<string, unknown> = { status };\n    if (typeof reason === 'string' && reason.trim().length > 0) {\n      payload.reason = reason.trim();\n    }\n\n    const response = await workspaceCall(endpoint, {\n      method: 'PATCH',\n      body: JSON.stringify(payload),\n      headers: {\n        // Deterministic idempotency key derived from operation params\n        'Idempotency-Key': `matter:${practiceId}:${matterId}:status:${status}:${payload.reason ?? ''}`\n      }\n    });\n\n    const result = normalizeMatterTransitionResult(response);\n    if (result.success === false || (typeof result.error === 'string' && result.error.trim().length > 0)) {\n      throw new Error(`Matter status update failed: ${result.error || 'Unknown error'}`);\n    }\n    return result;\n  }, [workspaceCall]);\n\n  // Refetch all data\n  const refetch = useCallback(async () => {\n    // Reset the fetched flag to ensure we actually refetch\n    practicesFetchedRef.current = false;\n    resetSharedPracticeCache();\n    \n    const promises = [fetchPractices()];\n    \n    // Only fetch invitations if explicitly requested\n    if (shouldFetchInvitations) {\n      promises.push(fetchInvitations());\n    }\n    \n    await Promise.all(promises);\n  }, [fetchPractices, fetchInvitations, shouldFetchInvitations]);\n\n  // Refetch when session changes\n  useEffect(() => {\n    if (!autoFetchPractices || sessionLoading) {\n      return;\n    }\n\n    void fetchPractices().then(() => {\n      if (shouldFetchInvitations) {\n        void fetchInvitations();\n      }\n    });\n\n    return () => {\n      currentRequestRef.current?.abort();\n    };\n  }, [\n    autoFetchPractices,\n    sessionLoading,\n    session?.user?.id,\n    isAnonymous,\n    fetchPractices,\n    fetchInvitations,\n    shouldFetchInvitations\n  ]);\n\n  return {\n    practices,\n    currentPractice,\n    loading,\n    error,\n    createPractice,\n    updatePractice,\n    updatePracticeDetails,\n    deletePractice,\n    getMembers,\n    fetchMembers,\n    updateMemberRole,\n    removeMember,\n    invitations,\n    sendInvitation,\n    acceptInvitation,\n    declineInvitation,\n    getWorkspaceData,\n    fetchWorkspaceData,\n    acceptMatter,\n    rejectMatter,\n    updateMatterStatus,\n    refetch,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useTheme.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":21,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":21,"endColumn":19,"suggestions":[{"fix":{"range":[629,692],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":63,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":63,"endColumn":19,"suggestions":[{"fix":{"range":[2185,2249],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'preact/hooks';\n\nexport const useTheme = () => {\n  const [isDark, setIsDark] = useState(false);\n  const [isHydrated, setIsHydrated] = useState(false);\n  \n  useEffect(() => {\n    // Guard against non-browser environments\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\n      return;\n    }\n    \n    // Mark as hydrated after first render\n    setIsHydrated(true);\n    \n    // Safely read localStorage to determine if a saved theme exists\n    let savedTheme: string | null = null;\n    try {\n      savedTheme = localStorage.getItem('theme');\n    } catch (error) {\n      console.warn('Failed to read theme from localStorage:', error);\n    }\n    \n    // Create matchMedia query object for system preference\n    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    \n    // Compute initial shouldBeDark using savedTheme if present, otherwise use media query\n    const shouldBeDark = savedTheme === 'dark' || (!savedTheme && mediaQuery.matches);\n    \n    // Set state and document class accordingly\n    setIsDark(shouldBeDark);\n    document.documentElement.classList.toggle('dark', shouldBeDark);\n    \n    // If no saved theme, attach a 'change' listener to the media query\n    if (!savedTheme) {\n      const handleMediaChange = (e: MediaQueryListEvent) => {\n        setIsDark(e.matches);\n        document.documentElement.classList.toggle('dark', e.matches);\n      };\n      \n      // Add listener for system theme changes\n      mediaQuery.addEventListener('change', handleMediaChange);\n      \n      // Return cleanup function that removes the listener\n      return () => {\n        mediaQuery.removeEventListener('change', handleMediaChange);\n      };\n    }\n  }, []);\n  \n  // Sync DOM and localStorage with state changes\n  useEffect(() => {\n    if (!isHydrated) return; // Don't sync during SSR\n    \n    // Guard against non-browser environments\n    if (typeof document === 'undefined') return;\n    \n    document.documentElement.classList.toggle('dark', isDark);\n    try {\n      localStorage.setItem('theme', isDark ? 'dark' : 'light');\n    } catch (error) {\n      // Best-effort localStorage persistence\n      console.warn('Failed to persist theme to localStorage:', error);\n    }\n  }, [isDark, isHydrated]);\n  \n  const toggleTheme = () => {\n    setIsDark(prev => !prev);\n  };\n\n  return { isDark, toggleTheme };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useToast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useUniqueId.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/hooks/useWorkspace.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/i18n/hooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/i18n/index.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":149,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":149,"endColumn":19,"suggestions":[{"fix":{"range":[5058,5148],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":154,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":154,"endColumn":17,"suggestions":[{"fix":{"range":[5241,5328],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":166,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":166,"endColumn":23,"suggestions":[{"fix":{"range":[5731,5798],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":169,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":169,"endColumn":21,"suggestions":[{"fix":{"range":[5832,5902],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import i18next from 'i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport { initReactI18next } from 'react-i18next';\n\nimport commonEn from '../../locales/en/common.json';\nimport settingsEn from '../../locales/en/settings.json';\nimport authEn from '../../locales/en/auth.json';\nimport profileEn from '../../locales/en/profile.json';\nimport pricingEn from '../../locales/en/pricing.json';\nimport practiceEn from '../../locales/en/practice.json';\n\nexport const DEFAULT_LOCALE = 'en' as const;\n\n// Locales fully exposed in the UI (100% translated)\nexport const SUPPORTED_LOCALES = [\n  'en',  // English - 100%\n  'pt',  // Portugus - 100%\n  'ar',  //  - 100%\n  'es',  // Espaol - 100%\n  'ja',  //  - 100%\n  'zh',  //  - 100%\n  'vi',  // Ting Vit - 100%\n  'de',  // Deutsch - 100%\n  'fr',  // Franais - 100%\n] as const;\n\n// All locales we can load (may be incomplete; hidden from UI if not 100%)\nexport const AVAILABLE_LOCALES = [\n  'en','pt','ar','es','ja','zh','vi','de','fr',\n  'hi','uk','id','th','ko','pl','it','ru','tr','nl'\n] as const;\n\nexport type AnyLocale = typeof AVAILABLE_LOCALES[number];\n\n// Languages with incomplete translations (<100%) - files exist but not shown in selector:\n// 'hi'  -  - 60.3% (203 keys remaining)\n// 'uk'  -  - 60.3% (203 keys remaining)\n// 'id'  - Bahasa Indonesia - 60.3% (203 keys remaining)\n// 'th'  -  - 38.9% (312 keys remaining)\n// 'ko'  -  - 24.9% (384 keys remaining)\n// 'pl'  - Polski - 24.9% (384 keys remaining)\n// 'it'  - Italiano - 24.9% (384 keys remaining)\n// 'ru'  -  - 24.9% (384 keys remaining)\n// 'tr'  - Trke - 2.3% (499 keys remaining)\n// 'nl'  - Nederlands - 24.9% (384 keys remaining) - moved to incomplete due to excessive placeholders\n\nexport type AppLocale = typeof SUPPORTED_LOCALES[number];\n\n// RTL (Right-to-Left) languages\nexport const RTL_LOCALES: ReadonlySet<AppLocale> = new Set(['ar'] as const);\n\n/**\n * Check if a locale uses RTL (Right-to-Left) text direction\n */\nexport const isRTLLocale = (locale: AnyLocale): boolean => {\n  const normalized = locale.toLowerCase().split('-')[0];\n  return RTL_LOCALES.has(normalized as AppLocale);\n};\n\nconst NAMESPACES = ['common', 'settings', 'auth', 'profile', 'pricing', 'practice'] as const;\n\n// Type for locale resource bundles\ntype LocaleResourceBundle = Record<string, string>;\n\n// Type for locale index modules\ntype LocaleIndexModule = {\n  common: LocaleResourceBundle;\n  settings: LocaleResourceBundle;\n  auth: LocaleResourceBundle;\n  profile: LocaleResourceBundle;\n  pricing: LocaleResourceBundle;\n  practice: LocaleResourceBundle;\n};\n\n// Create typed loader maps for Vite static analysis (exclude default locale to avoid duplicate imports)\nconst localeIndexLoaders = import.meta.glob([\n  '../../locales/*/index.ts',\n  '!../../locales/en/index.ts'\n]) as Record<string, () => Promise<LocaleIndexModule>>;\n\nconst localeJsonLoaders = import.meta.glob([\n  '../../locales/*/*.json',\n  '!../../locales/en/*.json'\n]) as Record<string, () => Promise<{ default: LocaleResourceBundle }>>;\n\nconst STORAGE_KEY = 'blawby_locale';\nlet initialized = false;\n\nconst staticResources = {\n  en: {\n    common: commonEn,\n    settings: settingsEn,\n    auth: authEn,\n    profile: profileEn,\n    pricing: pricingEn,\n    practice: practiceEn\n  }\n};\n\nconst isSupportedLocale = (locale: string): locale is AppLocale => {\n  return SUPPORTED_LOCALES.includes(locale as AppLocale);\n};\n\nconst isAvailableLocale = (locale: string): locale is AnyLocale => {\n  return AVAILABLE_LOCALES.includes(locale as AnyLocale);\n};\n\nconst normalizeLocale = (locale?: string | null): AppLocale => {\n  if (!locale) return DEFAULT_LOCALE;\n  const lower = locale.toLowerCase();\n  const explicitMatch = isSupportedLocale(lower) ? lower : null;\n  if (explicitMatch) return explicitMatch;\n\n  const match = SUPPORTED_LOCALES.find((supported) => lower.startsWith(`${supported}-`));\n  return match ?? DEFAULT_LOCALE;\n};\n\nconst normalizeAnyLocale = (locale?: string | null): AnyLocale => {\n  if (!locale) return DEFAULT_LOCALE;\n  const lower = locale.toLowerCase();\n  const explicitMatch = isAvailableLocale(lower) ? lower : null;\n  if (explicitMatch) return explicitMatch;\n\n  const match = AVAILABLE_LOCALES.find((available) => lower.startsWith(`${available}-`));\n  return match ?? DEFAULT_LOCALE;\n};\n\nconst loadLocaleResources = async (locale: AnyLocale) => {\n  if (locale === DEFAULT_LOCALE) {\n    return;\n  }\n\n  // Try to load from index file first\n  const indexLoaderKey = `../../locales/${locale}/index.ts`;\n  const indexLoader = localeIndexLoaders[indexLoaderKey];\n  \n  if (indexLoader) {\n    try {\n      const localeModule = await indexLoader();\n      \n      NAMESPACES.forEach((namespace) => {\n        const alreadyLoaded = i18next.getResourceBundle(locale, namespace);\n        if (!alreadyLoaded && localeModule[namespace]) {\n          i18next.addResourceBundle(locale, namespace, localeModule[namespace], true, true);\n        }\n      });\n      return; // Successfully loaded from index\n    } catch (error) {\n      console.warn(`Failed to load locale index ${locale}, falling back to JSON files:`, error);\n      // Continue to fallback logic below\n    }\n  } else {\n    // No index loader found\n    console.warn(`No index loader found for locale ${locale}, falling back to JSON files`);\n  }\n  const namespaceData = await Promise.all(\n    NAMESPACES.map(async (namespace) => {\n      const jsonLoaderKey = `../../locales/${locale}/${namespace}.json`;\n      const jsonLoader = localeJsonLoaders[jsonLoaderKey];\n      \n      if (jsonLoader) {\n        try {\n          const module = await jsonLoader();\n          return [namespace, module.default] as const;\n        } catch (error) {\n          console.warn(`Failed to load ${locale}/${namespace}.json:`, error);\n        }\n      } else {\n        console.warn(`JSON loader not found for ${locale}/${namespace}.json`);\n      }\n      return [namespace, {}] as const;\n    })\n  );\n\n  namespaceData.forEach(([namespace, data]) => {\n    const alreadyLoaded = i18next.getResourceBundle(locale, namespace);\n    if (!alreadyLoaded && Object.keys(data).length > 0) {\n      i18next.addResourceBundle(locale, namespace, data, true, true);\n    }\n  });\n};\n\nexport const initI18n = async () => {\n  if (initialized) {\n    return i18next;\n  }\n\n  const initialLocale = normalizeLocale(\n    typeof window !== 'undefined' ? window.localStorage.getItem(STORAGE_KEY) : undefined\n  );\n\n  await i18next\n    .use(LanguageDetector)\n    .use(initReactI18next)\n    .init({\n      resources: staticResources,\n      fallbackLng: DEFAULT_LOCALE,\n      lng: initialLocale,\n      load: 'languageOnly',\n      supportedLngs: [...AVAILABLE_LOCALES],\n      ns: [...NAMESPACES],\n      defaultNS: 'common',\n      interpolation: {\n        escapeValue: false\n      },\n      detection: {\n        order: ['querystring', 'localStorage', 'navigator'],\n        caches: ['localStorage'],\n        lookupLocalStorage: STORAGE_KEY\n      },\n      react: {\n        useSuspense: true,\n        bindI18n: 'languageChanged loaded',\n        bindI18nStore: 'added removed'\n      }\n    });\n\n  const normalizedAnyLocale = normalizeAnyLocale(i18next.language);\n  await loadLocaleResources(normalizedAnyLocale);\n\n  // Set initial HTML dir and lang attributes\n  if (typeof window !== 'undefined') {\n    const isRTL = isRTLLocale(normalizedAnyLocale);\n    document.documentElement.setAttribute('dir', isRTL ? 'rtl' : 'ltr');\n    document.documentElement.setAttribute('lang', normalizedAnyLocale);\n  }\n\n  initialized = true;\n  return i18next;\n};\n\nexport const setLocale = async (nextLocale: string) => {\n  const target = normalizeAnyLocale(nextLocale);\n  await loadLocaleResources(target);\n  await i18next.changeLanguage(target);\n  \n  // Update text direction based on locale\n  if (typeof window !== 'undefined') {\n    window.localStorage.setItem(STORAGE_KEY, target);\n    \n    // Set HTML dir attribute for RTL support\n    const isRTL = isRTLLocale(target);\n    document.documentElement.setAttribute('dir', isRTL ? 'rtl' : 'ltr');\n    document.documentElement.setAttribute('lang', target);\n  }\n};\n\nexport const detectBestLocale = (): AppLocale => {\n  if (typeof navigator === 'undefined') {\n    return DEFAULT_LOCALE;\n  }\n\n  const [primary] = navigator.language.split('-');\n  return normalizeLocale(primary);\n};\n\nexport { i18next as i18n };\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/lib/apiClient.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":95,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":95,"endColumn":20,"suggestions":[{"fix":{"range":[3359,3443],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":609,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":609,"endColumn":17,"suggestions":[{"fix":{"range":[19472,19560],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":907,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":907,"endColumn":19,"suggestions":[{"fix":{"range":[28516,28659],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":920,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":920,"endColumn":18,"suggestions":[{"fix":{"range":[28850,28899],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1096,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1096,"endColumn":17,"suggestions":[{"fix":{"range":[34299,34394],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1184,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1184,"endColumn":20,"suggestions":[{"fix":{"range":[36925,36994],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1748,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1748,"endColumn":30,"suggestions":[{"fix":{"range":[58353,58423],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios, { type AxiosRequestConfig } from 'axios';\nimport {\n  getSubscriptionBillingPortalEndpoint,\n  getSubscriptionCancelEndpoint,\n  getSubscriptionListEndpoint,\n  getConversationLinkEndpoint\n} from '@/config/api';\nimport type { Conversation } from '@/shared/types/conversation';\nimport type { Address } from '@/shared/types/address';\nimport { getWorkerApiUrl } from '@/config/urls';\nimport {\n  toMajorUnits,\n  toMinorUnitsValue,\n  assertMajorUnits,\n  assertMinorUnits,\n  type MajorAmount\n} from '@/shared/utils/money';\n\nlet cachedBaseUrl: string | null = null;\nlet isHandling401: Promise<void> | null = null;\n// In-flight deduplicator: prevents concurrent duplicate requests for the same slug.\nconst publicPracticeDetailsInFlight = new Map<string, Promise<PublicPracticeDetails | null>>();\n// Persistent result cache: once a slug resolves, reuse the result for the entire session.\n// This is the primary fix for the \"Too Many Requests\" issue  previously every caller\n// (usePracticeConfig, usePracticeDetails, AwaitingInvitePage, forms.ts) would fire\n// independent HTTP requests because the in-flight map was cleared after each request.\nconst publicPracticeDetailsCache = new Map<string, PublicPracticeDetails | null>();\nconst ABSOLUTE_URL_PATTERN = /^(https?:)?\\/\\//i;\n\n/**\n * Clear the public practice details cache for a specific slug (or all slugs).\n * Call this on logout or when practice data is known to have changed.\n */\nexport const clearPublicPracticeDetailsCache = (slug?: string) => {\n  if (slug) {\n    publicPracticeDetailsCache.delete(slug.trim());\n    publicPracticeDetailsInFlight.delete(slug.trim());\n  } else {\n    publicPracticeDetailsCache.clear();\n    publicPracticeDetailsInFlight.clear();\n  }\n};\n\nconst normalizePublicFileUrl = (value?: string | null): string | null => {\n  if (!value) return null;\n  const trimmed = value.trim();\n  if (!trimmed) return null;\n  if (ABSOLUTE_URL_PATTERN.test(trimmed) || trimmed.startsWith('data:') || trimmed.startsWith('blob:')) {\n    return trimmed;\n  }\n  if (trimmed.startsWith('/')) {\n    return trimmed;\n  }\n  return `${getWorkerApiUrl()}/api/files/${encodeURIComponent(trimmed)}`;\n};\n\n/**\n * Get the base URL for backend API requests via the Worker proxy\n * Uses centralized URL configuration from src/config/urls.ts\n * \n * Caching strategy:\n * - Development: Never cache (always read the current URL)\n * - Production: Cache after first call\n */\nfunction ensureApiBaseUrl(): string {\n  // NEVER cache in development - always get the latest URL.\n  if (import.meta.env.DEV) {\n    return getWorkerApiUrl();\n  }\n\n  // In production, cache after first call\n  if (cachedBaseUrl) {\n    return cachedBaseUrl;\n  }\n\n  cachedBaseUrl = getWorkerApiUrl();\n  return cachedBaseUrl;\n}\n\n// Create axios instance without default baseURL\n// We'll set it dynamically in the interceptor to avoid stale base URLs.\nexport const apiClient = axios.create({\n  // Don't set baseURL here - let interceptor handle it dynamically\n});\n\napiClient.interceptors.request.use(\n  (config) => {\n    // Always get fresh baseURL in development.\n    // Force override any cached baseURL to avoid stale endpoints.\n    const baseUrl = ensureApiBaseUrl();\n    // Always set baseURL fresh - don't rely on existing value\n    if (config.baseURL !== baseUrl) {\n      config.baseURL = baseUrl;\n      if (import.meta.env.DEV) {\n        console.log('[apiClient] Updated baseURL to:', baseUrl, 'for request:', config.url);\n      }\n    }\n\n    // Use session cookies for auth; include credentials for cross-origin requests when allowed.\n    config.withCredentials = true;\n\n    return config;\n  },\n  (error) => Promise.reject(error)\n);\n\ntype PracticeMetadata = Record<string, unknown> | null | undefined;\n\nexport interface Practice {\n  id: string;\n  name: string;\n  slug: string;\n  logo?: string | null;\n  metadata?: PracticeMetadata;\n  businessPhone: string | null;\n  businessEmail: string | null;\n  consultationFee: MajorAmount | null; // Major currency units (e.g., USD dollars).\n  paymentUrl: string | null;\n  calendlyUrl: string | null;\n  createdAt?: string | null;\n  updatedAt?: string | null;\n  billingIncrementMinutes?: number | null;\n  website?: string | null;\n  address?: string | null;\n  apartment?: string | null;\n  city?: string | null;\n  state?: string | null;\n  postalCode?: string | null;\n  country?: string | null;\n  primaryColor?: string | null;\n  accentColor?: string | null;\n  introMessage?: string | null;\n  isPublic?: boolean | null;\n  services?: Array<Record<string, unknown>> | null;\n\n  // Subscription and practice management properties\n  kind?: 'personal' | 'business' | 'practice';\n  subscriptionStatus?: 'none' | 'trialing' | 'active' | 'past_due' | 'canceled' | 'incomplete' | 'incomplete_expired' | 'unpaid' | 'paused';\n  seats?: number | null;\n  config?: {\n    ownerEmail?: string;\n    metadata?: Record<string, unknown>;\n    description?: string;\n    [key: string]: unknown; // Allow additional config properties\n  };\n  stripeCustomerId?: string | null;\n  subscriptionPeriodEnd?: number | null;\n  description?: string;\n  isPersonal?: boolean | null;\n  betterAuthOrgId?: string;\n  businessOnboardingStatus?: 'not_required' | 'pending' | 'completed' | 'skipped';\n  businessOnboardingCompletedAt?: number | null;\n  businessOnboardingSkipped?: boolean;\n  businessOnboardingHasDraft?: boolean;\n}\n\nexport interface CreatePracticeRequest {\n  name: string;\n  slug?: string;\n  logo?: string;\n  metadata?: PracticeMetadata;\n  businessPhone?: string;\n  businessEmail?: string;\n  consultationFee?: MajorAmount;\n  paymentUrl?: string;\n  calendlyUrl?: string;\n}\n\nexport interface PracticeDetailsUpdate {\n  businessPhone?: string | null;\n  businessEmail?: string | null;\n  consultationFee?: MajorAmount | null;\n  paymentLinkEnabled?: boolean | null;\n  paymentLinkPrefillAmount?: MajorAmount | null;\n  paymentUrl?: string | null;\n  calendlyUrl?: string | null;\n  billingIncrementMinutes?: number | null;\n  website?: string | null;\n  address?: string | null;\n  apartment?: string | null;\n  city?: string | null;\n  state?: string | null;\n  postalCode?: string | null;\n  country?: string | null;\n  primaryColor?: string | null;\n  accentColor?: string | null;\n  introMessage?: string | null;\n  description?: string | null;\n  isPublic?: boolean | null;\n  services?: Array<Record<string, unknown>> | null;\n}\n\nexport interface UpdatePracticeRequest extends Partial<CreatePracticeRequest>, PracticeDetailsUpdate {}\n\nexport interface PracticeDetails {\n  id?: string;\n  businessPhone?: string | null;\n  businessEmail?: string | null;\n  consultationFee?: MajorAmount | null;\n  paymentLinkEnabled?: boolean | null;\n  paymentLinkPrefillAmount?: MajorAmount | null;\n  paymentUrl?: string | null;\n  calendlyUrl?: string | null;\n  billingIncrementMinutes?: number | null;\n  website?: string | null;\n  address?: string | null;\n  apartment?: string | null;\n  city?: string | null;\n  state?: string | null;\n  postalCode?: string | null;\n  country?: string | null;\n  primaryColor?: string | null;\n  accentColor?: string | null;\n  introMessage?: string | null;\n  description?: string | null;\n  isPublic?: boolean | null;\n  services?: Array<Record<string, unknown>> | null;\n}\n\nexport interface ConnectedAccountRequest {\n  practiceEmail: string;\n  practiceUuid: string;\n  returnUrl?: string;\n  refreshUrl?: string;\n}\n\nexport interface ConnectedAccountResponse {\n  practiceUuid: string;\n  stripeAccountId: string;\n  clientSecret: string | null;\n  onboardingUrl?: string | null;\n  chargesEnabled: boolean;\n  payoutsEnabled: boolean;\n  detailsSubmitted: boolean;\n}\n\nexport interface OnboardingStatus {\n  practiceUuid: string;\n  stripeAccountId: string | null;\n  clientSecret?: string | null;\n  chargesEnabled: boolean;\n  payoutsEnabled: boolean;\n  detailsSubmitted: boolean;\n  completed?: boolean;\n}\n\nexport interface BillingPortalPayload {\n  practiceId: string;\n  returnUrl?: string;\n  customerType?: 'user' | 'organization';\n}\n\nexport interface SubscriptionEndpointResult {\n  ok: boolean;\n  status: number;\n  data: unknown;\n}\n\nexport interface CurrentSubscriptionPlan {\n  id?: string | null;\n  name?: string | null;\n  displayName?: string | null;\n  description?: string | null;\n  stripeProductId?: string | null;\n  stripeMonthlyPriceId?: string | null;\n  stripeYearlyPriceId?: string | null;\n  monthlyPrice?: string | null;\n  yearlyPrice?: string | null;\n  currency?: string | null;\n  features?: string[] | null;\n  isActive?: boolean | null;\n}\n\nexport interface CurrentSubscription {\n  id?: string | null;\n  status?: string | null;\n  plan?: CurrentSubscriptionPlan | null;\n  cancelAtPeriodEnd?: boolean | null;\n  currentPeriodStart?: string | null;\n  currentPeriodEnd?: string | null;\n}\n\nexport interface UpdateConversationMatterRequest {\n  matterId?: string | null;\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nfunction unwrapApiData(payload: unknown): unknown {\n  let current = payload;\n  const visited = new Set<unknown>();\n\n  while (isRecord(current) && 'data' in current && !visited.has(current)) {\n    visited.add(current);\n    current = (current as Record<string, unknown>).data;\n  }\n\n  return current;\n}\n\nexport async function linkConversationToUser(\n  conversationId: string,\n  practiceId: string,\n  userId?: string | null\n): Promise<Conversation> {\n  if (!conversationId) {\n    throw new Error('conversationId is required to link conversation');\n  }\n  if (!practiceId) {\n    throw new Error('practiceId is required to link conversation');\n  }\n\n  const response = await apiClient.patch(\n    `${getConversationLinkEndpoint(conversationId)}?practiceId=${encodeURIComponent(practiceId)}`,\n    {\n      userId: userId || undefined\n    }\n  );\n\n  const conversation = unwrapApiData(response.data) as Conversation | null;\n  if (!conversation) {\n    throw new Error('Failed to link conversation');\n  }\n\n  return conversation;\n}\n\nexport async function updateConversationMatter(\n  conversationId: string,\n  matterId: string | null,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<Conversation> {\n  if (!conversationId) {\n    throw new Error('conversationId is required to update a conversation matter');\n  }\n\n  const response = await apiClient.patch(\n    `/api/conversations/${encodeURIComponent(conversationId)}/matter`,\n    { matterId } satisfies UpdateConversationMatterRequest,\n    { signal: config?.signal }\n  );\n\n  const data = unwrapApiData(response.data);\n  if (!isRecord(data)) {\n    throw new Error('Invalid response from updateConversationMatter');\n  }\n\n  return data as unknown as Conversation;\n}\n\nexport async function listMatterConversations(\n  practiceId: string,\n  matterId: string,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<Conversation[]> {\n  if (!practiceId) {\n    throw new Error('Missing required parameter: practiceId');\n  }\n  if (!matterId) {\n    throw new Error('Missing required parameter: matterId');\n  }\n\n  const response = await apiClient.get(\n    `/api/matters/${encodeURIComponent(practiceId)}/${encodeURIComponent(matterId)}/conversations`,\n    { signal: config?.signal }\n  );\n\n  const data = unwrapApiData(response.data);\n  if (!Array.isArray(data)) {\n    throw new Error('Invalid response from listMatterConversations');\n  }\n\n  return data as Conversation[];\n}\n\nasync function postSubscriptionEndpoint(\n  url: string,\n  body: Record<string, unknown>\n): Promise<SubscriptionEndpointResult> {\n  try {\n    const response = await apiClient.post(url, body, {\n      baseURL: undefined\n    });\n    return {\n      ok: true,\n      status: response.status,\n      data: response.data ?? null\n    };\n  } catch (error) {\n    if (axios.isAxiosError(error)) {\n      return {\n        ok: false,\n        status: error.response?.status ?? 0,\n        data: error.response?.data ?? null\n      };\n    }\n    return {\n      ok: false,\n      status: 0,\n      data: null\n    };\n  }\n}\n\nfunction toNullableString(value: unknown): string | null {\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed.length > 0 ? trimmed : null;\n  }\n  return null;\n}\n\nfunction normalizePracticePayload(payload: unknown): Practice {\n  if (!isRecord(payload)) {\n    throw new Error('Invalid practice payload');\n  }\n\n  const record = isRecord(payload.practice) ? payload.practice : payload;\n  const id = String(\n    record.id ??\n    record.uuid ??\n    record.practice_id ??\n    record.practice_uuid ??\n    record.practiceUuid ??\n    ''\n  );\n  const name = String(record.name ?? 'Practice');\n  const slug = toNullableString(record.slug) ?? id;\n\n  return {\n    id,\n    name,\n    slug,\n    logo: toNullableString(record.logo),\n    metadata: isRecord(record.metadata) ? record.metadata : undefined,\n    businessPhone: toNullableString(record.businessPhone ?? record.business_phone),\n    businessEmail: toNullableString(record.businessEmail ?? record.business_email),\n    consultationFee: (() => {\n      const rawFee = record.consultationFee ?? record.consultation_fee;\n      if (typeof rawFee !== 'number') return null;\n      assertMinorUnits(rawFee, 'practice.consultationFee');\n      return toMajorUnits(Number(rawFee));\n    })(),\n    paymentUrl: toNullableString(record.paymentUrl ?? record.payment_url),\n    calendlyUrl: toNullableString(record.calendlyUrl ?? record.calendly_url),\n    createdAt: toNullableString(record.createdAt ?? record.created_at),\n    updatedAt: toNullableString(record.updatedAt ?? record.updated_at),\n    billingIncrementMinutes: (() => {\n      const value = record.billingIncrementMinutes ?? record.billing_increment_minutes;\n      if (value === null || value === undefined) return null;\n      if (typeof value === 'number' && Number.isFinite(value)) return value;\n      if (typeof value === 'string' && value.trim().length > 0) {\n        const parsed = Number(value);\n        return Number.isFinite(parsed) ? parsed : null;\n      }\n      return null;\n    })(),\n    website: toNullableString(record.website),\n    address: toNullableString(record.address ?? record.address_line_1),\n    apartment: toNullableString(record.apartment ?? record.address_line_2),\n    city: toNullableString(record.city),\n    state: toNullableString(record.state),\n    postalCode: toNullableString(record.postalCode ?? record.postal_code),\n    country: toNullableString(record.country),\n    primaryColor: toNullableString(record.primaryColor ?? record.primary_color),\n    accentColor: toNullableString(record.accentColor ?? record.accent_color),\n    introMessage: toNullableString(record.introMessage ?? record.intro_message),\n    description: toNullableString(record.description ?? record.overview),\n    isPublic: 'isPublic' in record || 'is_public' in record\n      ? Boolean(record.isPublic ?? record.is_public)\n      : null,\n    services: Array.isArray(record.services)\n      ? (record.services as Array<Record<string, unknown>>)\n      : null\n  };\n}\n\nfunction unwrapPracticeResponse(data: unknown): Practice {\n  if (Array.isArray(data)) {\n    throw new Error('Expected a single practice object');\n  }\n\n  if (isRecord(data) && 'practice' in data) {\n    return normalizePracticePayload((data as Record<string, unknown>).practice);\n  }\n\n  if (isRecord(data) && 'data' in data && isRecord(data.data)) {\n    return normalizePracticePayload(data.data);\n  }\n\n  return normalizePracticePayload(data);\n}\n\nfunction unwrapPracticeListResponse(data: unknown): Practice[] {\n  if (Array.isArray(data)) {\n    return data.map(normalizePracticePayload);\n  }\n\n  if (isRecord(data)) {\n    if (Array.isArray(data.practices)) {\n      return data.practices.map(normalizePracticePayload);\n    }\n    if (Array.isArray(data.organizations)) {\n      return data.organizations.map(normalizePracticePayload);\n    }\n    if (Array.isArray(data.data)) {\n      return data.data.map(normalizePracticePayload);\n    }\n    if (isRecord(data.data)) {\n      const nested = data.data as Record<string, unknown>;\n      if (Array.isArray(nested.practices)) {\n        return nested.practices.map(normalizePracticePayload);\n      }\n      if (Array.isArray(nested.organizations)) {\n        return nested.organizations.map(normalizePracticePayload);\n      }\n      if (Array.isArray(nested.items)) {\n        return nested.items.map(normalizePracticePayload);\n      }\n    }\n  }\n\n  return [];\n}\n\nfunction normalizeConnectedAccountResponse(payload: unknown): ConnectedAccountResponse {\n  if (!isRecord(payload)) {\n    throw new Error('Invalid connected account payload');\n  }\n\n  return {\n    practiceUuid: String(payload.practice_uuid ?? payload.practiceUuid ?? ''),\n    stripeAccountId: String(payload.stripe_account_id ?? payload.stripeAccountId ?? ''),\n    clientSecret: toNullableString(payload.client_secret ?? payload.clientSecret),\n    onboardingUrl: toNullableString(payload.onboarding_url ?? payload.onboardingUrl ?? payload.url),\n    chargesEnabled: Boolean(payload.charges_enabled ?? payload.chargesEnabled),\n    payoutsEnabled: Boolean(payload.payouts_enabled ?? payload.payoutsEnabled),\n    detailsSubmitted: Boolean(payload.details_submitted ?? payload.detailsSubmitted)\n  };\n}\n\nfunction normalizeOnboardingStatus(payload: unknown): OnboardingStatus {\n  const normalized = unwrapApiData(payload);\n  if (!isRecord(normalized)) {\n    throw new Error('Invalid onboarding status payload');\n  }\n\n  return {\n    practiceUuid: String(normalized.practice_uuid ?? normalized.practiceUuid ?? ''),\n    stripeAccountId: toNullableString(normalized.stripe_account_id ?? normalized.stripeAccountId),\n    clientSecret: toNullableString(normalized.client_secret ?? normalized.clientSecret),\n    chargesEnabled: Boolean(normalized.charges_enabled ?? normalized.chargesEnabled),\n    payoutsEnabled: Boolean(normalized.payouts_enabled ?? normalized.payoutsEnabled),\n    detailsSubmitted: Boolean(normalized.details_submitted ?? normalized.detailsSubmitted),\n    completed: 'completed' in normalized ? Boolean(normalized.completed) : undefined\n  };\n}\n\ntype ListPracticesOptions = Pick<AxiosRequestConfig, 'signal'> & {\n  scope?: 'all' | 'tenant' | 'platform';\n};\n\nexport async function listPractices(configOrOptions?: ListPracticesOptions): Promise<Practice[]> {\n  const opts = configOrOptions ?? {};\n  const scope = opts.scope ?? 'tenant';\n  const response = await apiClient.get('/api/practice/list', {\n    signal: opts.signal\n  });\n  const practices = unwrapPracticeListResponse(response.data);\n  if (scope === 'platform') {\n    return [];\n  }\n  return practices;\n}\n\nexport async function getPractice(practiceId: string, config?: Pick<AxiosRequestConfig, 'signal'>): Promise<Practice> {\n  if (!practiceId) {\n    throw new Error('practiceId is required');\n  }\n  const response = await apiClient.get(`/api/practice/${encodeURIComponent(practiceId)}`, {\n    signal: config?.signal\n  });\n  return unwrapPracticeResponse(response.data);\n}\n\n\nexport async function createPractice(\n  payload: CreatePracticeRequest,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<Practice> {\n  const response = await apiClient.post('/api/practice', payload, {\n    signal: config?.signal\n  });\n  return unwrapPracticeResponse(response.data);\n}\n\nexport async function updatePractice(\n  practiceId: string,\n  payload: UpdatePracticeRequest,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<Practice> {\n  if (!practiceId) {\n    throw new Error('practiceId is required');\n  }\n  const normalized = normalizePracticeUpdatePayload(payload);\n  if (import.meta.env.DEV) {\n    console.info('[apiClient] updatePractice payload', { practiceId, payload: normalized });\n  }\n  const response = await apiClient.put(\n    `/api/practice/${encodeURIComponent(practiceId)}`,\n    normalized,\n    {\n      signal: config?.signal\n    }\n  );\n  return unwrapPracticeResponse(response.data);\n}\n\nexport async function deletePractice(\n  practiceId: string,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<void> {\n  if (!practiceId) {\n    throw new Error('practiceId is required');\n  }\n  await apiClient.delete(`/api/practice/${encodeURIComponent(practiceId)}`, {\n    signal: config?.signal\n  });\n}\n\nexport async function setActivePractice(practiceId: string): Promise<void> {\n  if (!practiceId) {\n    throw new Error('practiceId is required');\n  }\n  await apiClient.put(`/api/practice/${encodeURIComponent(practiceId)}/active`);\n}\n\nexport async function listPracticeInvitations(): Promise<unknown[]> {\n  const response = await apiClient.get('/api/practice/invitations');\n  const payload = unwrapApiData(response.data);\n  if (Array.isArray(payload)) {\n    return payload;\n  }\n  if (isRecord(payload) && Array.isArray(payload.invitations)) {\n    return payload.invitations as unknown[];\n  }\n  return [];\n}\n\nexport async function createPracticeInvitation(\n  practiceId: string,\n  payload: { email: string; role: string }\n): Promise<{ inviteUrl?: string; invitationId?: string } | null> {\n  const response = await apiClient.post(\n    `/api/practice/${encodeURIComponent(practiceId)}/invitations`,\n    payload\n  );\n  const data = unwrapApiData(response.data);\n  if (!isRecord(data)) {\n    return null;\n  }\n  const inviteUrl = toNullableString(\n    data.inviteUrl ??\n    data.invite_url ??\n    data.url ??\n    (isRecord(data.invitation) ? (data.invitation as Record<string, unknown>).inviteUrl ?? (data.invitation as Record<string, unknown>).invite_url : null)\n  );\n  const invitationId = toNullableString(\n    data.invitationId ??\n    data.invitation_id ??\n    data.id ??\n    (isRecord(data.invitation) ? (data.invitation as Record<string, unknown>).id : null)\n  );\n  if (!inviteUrl && !invitationId) {\n    return null;\n  }\n  return {\n    inviteUrl: inviteUrl ?? undefined,\n    invitationId: invitationId ?? undefined\n  };\n}\n\nexport async function triggerIntakeInvitation(intakeUuid: string): Promise<{ message?: string } | null> {\n  if (!intakeUuid) {\n    throw new Error('intakeUuid is required');\n  }\n  const response = await apiClient.post(\n    `/api/practice/client-intakes/${encodeURIComponent(intakeUuid)}/invite`,\n    {}\n  );\n  const data = unwrapApiData(response.data);\n  if (!isRecord(data)) {\n    return null;\n  }\n  const message = toNullableString(data.message);\n  return message ? { message } : null;\n}\n\nexport async function respondToPracticeInvitation(\n  invitationId: string,\n  action: 'accept' | 'decline'\n): Promise<void> {\n  await apiClient.post(\n    `/api/practice/invitations/${encodeURIComponent(invitationId)}/${action}`\n  );\n}\n\nexport async function listPracticeMembers(practiceId: string): Promise<unknown[]> {\n  const response = await apiClient.get(`/api/practice/${encodeURIComponent(practiceId)}/members`);\n  const payload = unwrapApiData(response.data);\n  if (Array.isArray(payload)) {\n    return payload;\n  }\n  if (isRecord(payload) && Array.isArray(payload.members)) {\n    return payload.members as unknown[];\n  }\n  return [];\n}\n\nexport async function updatePracticeMemberRole(\n  practiceId: string,\n  payload: { userId: string; role: string }\n): Promise<void> {\n  await apiClient.patch(`/api/practice/${encodeURIComponent(practiceId)}/members`, payload);\n}\n\nexport async function deletePracticeMember(\n  practiceId: string,\n  userId: string\n): Promise<void> {\n  await apiClient.delete(\n    `/api/practice/${encodeURIComponent(practiceId)}/members/${encodeURIComponent(userId)}`\n  );\n}\n\nexport type UserDetailStatus = 'lead' | 'active' | 'inactive' | 'archived';\n\nexport type UserDetailRecord = {\n  id: string;\n  organization_id: string;\n  user_id: string | null;\n  user: {\n    id: string;\n    name: string | null;\n    email: string | null;\n    phone: string | null;\n  } | null;\n  address_id: string | null;\n  status: UserDetailStatus;\n  currency: string | null;\n  created_at: string;\n  updated_at: string;\n};\n\nexport type UserDetailListResponse = {\n  data: UserDetailRecord[];\n  total: number;\n};\n\nexport async function listUserDetails(\n  practiceId: string,\n  params?: {\n    search?: string;\n    status?: UserDetailStatus;\n    limit?: number;\n    offset?: number;\n    client_id?: string;\n    signal?: AbortSignal;\n  }\n): Promise<UserDetailListResponse> {\n  if (!practiceId) {\n    throw new Error('practiceId is required');\n  }\n  const { signal, ...queryParams } = params ?? {};\n  const response = await apiClient.get(\n    `/api/user-details/${encodeURIComponent(practiceId)}`,\n    { params: queryParams, signal }\n  );\n  const payload = response.data;\n  if (isRecord(payload) && Array.isArray(payload.data)) {\n    return {\n      data: payload.data as UserDetailRecord[],\n      total: typeof payload.total === 'number' ? payload.total : payload.data.length\n    };\n  }\n  return {\n    data: [],\n    total: 0\n  };\n}\n\nexport async function getUserDetail(\n  practiceId: string,\n  userDetailId: string\n): Promise<UserDetailRecord | null> {\n  if (!practiceId || !userDetailId) {\n    throw new Error('practiceId and userDetailId are required');\n  }\n  const response = await apiClient.get(\n    `/api/user-details/${encodeURIComponent(practiceId)}`,\n    { params: { client_id: userDetailId } }\n  );\n  const payload = response.data;\n  if (isRecord(payload) && Array.isArray(payload.data) && payload.data.length > 0) {\n    return payload.data[0] as UserDetailRecord;\n  }\n  if (isRecord(payload) && isRecord(payload.data)) {\n    return payload.data as UserDetailRecord;\n  }\n  return null;\n}\n\nexport type CreateUserDetailPayload = {\n  name: string;\n  email: string;\n  phone?: string;\n  status?: UserDetailStatus;\n  currency?: string;\n  address?: Partial<Address>;\n  event_name?: string;\n};\n\ntype UserDetailBasePayload = {\n  name?: string;\n  email?: string;\n  phone?: string;\n  status?: UserDetailStatus;\n  currency?: string;\n  address?: Partial<Address>;\n  event_name?: string;\n};\n\ntype UpdateUserDetailPayload = UserDetailBasePayload & Record<string, unknown>;\n\nconst normalizeOptionalText = (value: unknown): string | undefined => {\n  if (typeof value !== 'string') return undefined;\n  const trimmed = value.trim();\n  return trimmed.length > 0 ? trimmed : undefined;\n};\n\nconst normalizeUserDetailAddress = (address?: Partial<Address>): Record<string, unknown> | undefined => {\n  if (!address) return undefined;\n  const normalized: Record<string, unknown> = {};\n  \n  const line1 = normalizeOptionalText(address.address);\n  if (line1 !== undefined) normalized.line1 = line1;\n  \n  const line2 = normalizeOptionalText(address.apartment);\n  if (line2 !== undefined) normalized.line2 = line2;\n  \n  const city = normalizeOptionalText(address.city);\n  if (city !== undefined) normalized.city = city;\n  \n  const state = normalizeOptionalText(address.state);\n  if (state !== undefined) normalized.state = state;\n  \n  const postalCode = normalizeOptionalText(address.postalCode);\n  if (postalCode !== undefined) normalized.postal_code = postalCode;\n  \n  const country = normalizeOptionalText(address.country);\n  if (country !== undefined) normalized.country = country.toUpperCase();\n\n  return Object.keys(normalized).length > 0 ? normalized : undefined;\n};\n\nconst normalizeUserDetailPayload = (payload: UserDetailBasePayload): Record<string, unknown> => {\n  const normalized: Record<string, unknown> = {};\n  const name = normalizeOptionalText(payload.name);\n  if (name !== undefined) normalized.name = name;\n  const email = normalizeOptionalText(payload.email);\n  if (email !== undefined) normalized.email = email;\n  const phone = normalizeOptionalText(payload.phone);\n  if (phone !== undefined) normalized.phone = phone;\n  if (payload.status !== undefined) normalized.status = payload.status;\n  const currency = normalizeOptionalText(payload.currency);\n  if (currency !== undefined) normalized.currency = currency;\n  const address = normalizeUserDetailAddress(payload.address);\n  if (address) normalized.address = address;\n  const eventName = normalizeOptionalText(payload.event_name);\n  if (eventName !== undefined) normalized.event_name = eventName;\n  return normalized;\n};\n\nexport async function createUserDetail(\n  practiceId: string,\n  payload: CreateUserDetailPayload\n): Promise<UserDetailRecord | null> {\n  if (!practiceId) {\n    throw new Error('practiceId is required');\n  }\n\n  const normalizedEmail = payload.email?.trim() || '';\n  const normalizedName = payload.name?.trim() || '';\n\n  if (!normalizedName || !normalizedEmail) {\n    throw new Error('Name and email are required');\n  }\n\n  // Use Better Auth organization invitation instead of direct user-details creation.\n  const { getClient } = await import('@/shared/lib/authClient');\n  const authClient = getClient();\n\n  try {\n    if (import.meta.env.DEV) {\n      console.info('[apiClient] inviteMember', {\n        organizationId: practiceId,\n        email: normalizedEmail,\n        role: 'member'\n      });\n    }\n    await authClient.organization.inviteMember({\n      email: normalizedEmail,\n      role: 'member',\n      organizationId: practiceId,\n    });\n    return null;\n  } catch (error) {\n    console.error('Failed to invite client:', error);\n    throw error;\n  }\n}\n\nexport async function updateUserDetail(\n  practiceId: string,\n  userDetailId: string,\n  payload: UpdateUserDetailPayload\n): Promise<UserDetailRecord | null> {\n  if (!practiceId || !userDetailId) {\n    throw new Error('practiceId and userDetailId are required');\n  }\n  const { address, name, email, phone, status, currency, event_name, ...rest } = payload;\n  const normalized = normalizeUserDetailPayload({ address, name, email, phone, status, currency, event_name });\n  const response = await apiClient.patch(\n    `/api/user-details/${encodeURIComponent(practiceId)}/update/${encodeURIComponent(userDetailId)}`,\n    { ...rest, ...normalized }\n  );\n  const data = response.data;\n  if (isRecord(data) && isRecord(data.data)) {\n    return data.data as UserDetailRecord;\n  }\n  return null;\n}\n\nexport async function deleteUserDetail(\n  practiceId: string,\n  userDetailId: string\n): Promise<void> {\n  if (!practiceId || !userDetailId) {\n    throw new Error('practiceId and userDetailId are required');\n  }\n  await apiClient.delete(\n    `/api/user-details/${encodeURIComponent(practiceId)}/delete/${encodeURIComponent(userDetailId)}`\n  );\n}\n\nexport type UserDetailMemoRecord = {\n  id: string;\n  content?: string | null;\n  event_time?: string | null;\n  created_at?: string;\n  updated_at?: string;\n  createdAt?: string;\n  updatedAt?: string;\n  user?: {\n    id?: string;\n    name?: string | null;\n    email?: string | null;\n  } | null;\n};\n\nexport async function listUserDetailMemos(\n  practiceId: string,\n  userDetailId: string\n): Promise<UserDetailMemoRecord[]> {\n  if (!practiceId || !userDetailId) {\n    throw new Error('practiceId and userDetailId are required');\n  }\n  const response = await apiClient.get(\n    `/api/user-details/${encodeURIComponent(practiceId)}/${encodeURIComponent(userDetailId)}/memos`\n  );\n  const payload = response.data;\n  if (isRecord(payload) && Array.isArray(payload.data)) {\n    return payload.data as UserDetailMemoRecord[];\n  }\n  if (Array.isArray(payload)) {\n    return payload as UserDetailMemoRecord[];\n  }\n  return [];\n}\n\nexport async function createUserDetailMemo(\n  practiceId: string,\n  userDetailId: string,\n  payload: Record<string, unknown>\n): Promise<UserDetailMemoRecord | null> {\n  if (!practiceId || !userDetailId) {\n    throw new Error('practiceId and userDetailId are required');\n  }\n  const response = await apiClient.post(\n    `/api/user-details/${encodeURIComponent(practiceId)}/${encodeURIComponent(userDetailId)}/memos`,\n    payload\n  );\n  const data = response.data;\n  if (isRecord(data) && isRecord(data.data)) {\n    return data.data as UserDetailMemoRecord;\n  }\n  return null;\n}\n\nexport async function updateUserDetailMemo(\n  practiceId: string,\n  userDetailId: string,\n  memoId: string,\n  payload: Record<string, unknown>\n): Promise<UserDetailMemoRecord | null> {\n  if (!practiceId || !userDetailId || !memoId) {\n    throw new Error('practiceId, userDetailId, and memoId are required');\n  }\n  const response = await apiClient.patch(\n    `/api/user-details/${encodeURIComponent(practiceId)}/${encodeURIComponent(userDetailId)}/memos/update/${encodeURIComponent(memoId)}`,\n    payload\n  );\n  const data = response.data;\n  if (isRecord(data) && isRecord(data.data)) {\n    return data.data as UserDetailMemoRecord;\n  }\n  return null;\n}\n\nexport async function deleteUserDetailMemo(\n  practiceId: string,\n  userDetailId: string,\n  memoId: string\n): Promise<void> {\n  if (!practiceId || !userDetailId || !memoId) {\n    throw new Error('practiceId, userDetailId, and memoId are required');\n  }\n  await apiClient.delete(\n    `/api/user-details/${encodeURIComponent(practiceId)}/${encodeURIComponent(userDetailId)}/memos/delete/${encodeURIComponent(memoId)}`\n  );\n}\n\nexport async function getOnboardingStatus(organizationId: string): Promise<OnboardingStatus> {\n  if (!organizationId) {\n    throw new Error('organizationId is required');\n  }\n  const response = await apiClient.get(\n    `/api/onboarding/organization/${encodeURIComponent(organizationId)}/status`\n  );\n  return normalizeOnboardingStatus(response.data);\n}\n\nexport async function getOnboardingStatusPayload(\n  organizationId: string,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<unknown> {\n  if (!organizationId) {\n    throw new Error('organizationId is required');\n  }\n  const response = await apiClient.get(\n    `/api/onboarding/organization/${encodeURIComponent(organizationId)}/status`,\n    { signal: config?.signal }\n  );\n  return response.data;\n}\n\nexport async function createConnectedAccount(\n  payload: ConnectedAccountRequest\n): Promise<ConnectedAccountResponse> {\n  if (!payload.practiceEmail || !payload.practiceUuid) {\n    throw new Error('practiceEmail and practiceUuid are required');\n  }\n\n  const response = await apiClient.post('/api/onboarding/connected-accounts', {\n    practice_email: payload.practiceEmail,\n    practice_uuid: payload.practiceUuid,\n    return_url: payload.returnUrl,\n    refresh_url: payload.refreshUrl\n  });\n\n  return normalizeConnectedAccountResponse(response.data);\n}\n\nexport async function updatePracticeDetails(\n  practiceId: string,\n  details: PracticeDetailsUpdate,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<PracticeDetails | null> {\n  if (!practiceId) {\n    throw new Error('practiceId is required');\n  }\n  const normalized = normalizePracticeDetailsPayload(details);\n  if (import.meta.env.DEV) {\n    console.info('[apiClient] updatePracticeDetails payload', { practiceId, payload: normalized });\n  }\n  const response = await apiClient.put(\n    `/api/practice/${encodeURIComponent(practiceId)}/details`,\n    normalized,\n    { signal: config?.signal }\n  );\n  return normalizePracticeDetailsResponse(response.data);\n}\n\nexport async function getPracticeDetails(\n  practiceId: string,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<PracticeDetails | null> {\n  if (!practiceId) {\n    throw new Error('practiceId is required');\n  }\n  try {\n    const response = await apiClient.get(\n      `/api/practice/${encodeURIComponent(practiceId)}/details`,\n      { signal: config?.signal }\n    );\n    return normalizePracticeDetailsResponse(response.data);\n  } catch (error) {\n    if (axios.isAxiosError(error) && error.response?.status === 404) {\n      return null;\n    }\n    throw error;\n  }\n}\n\nexport async function getPracticeDetailsBySlug(\n  slug: string,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<PracticeDetails | null> {\n  if (!slug) {\n    throw new Error('practice slug is required');\n  }\n  const normalizedSlug = slug.trim();\n  if (!normalizedSlug) {\n    throw new Error('practice slug is required');\n  }\n  try {\n    const response = await apiClient.get(\n      `/api/practice/details/${encodeURIComponent(normalizedSlug)}`,\n      { signal: config?.signal }\n    );\n    return normalizePracticeDetailsResponse(response.data);\n  } catch (error) {\n    if (axios.isAxiosError(error) && error.response?.status === 404) {\n      return null;\n    }\n    throw error;\n  }\n}\n\nexport interface PublicPracticeDetails {\n  practiceId?: string;\n  slug?: string;\n  details: PracticeDetails | null;\n  name?: string | null;\n  logo?: string | null;\n}\n\nexport async function getPublicPracticeDetails(\n  slug: string,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<PublicPracticeDetails | null> {\n  if (!slug) {\n    throw new Error('practice slug is required');\n  }\n  const normalizedSlug = slug.trim();\n\n  // 1. Return from persistent cache if already resolved (primary dedup across all callers).\n  if (publicPracticeDetailsCache.has(normalizedSlug)) {\n    return publicPracticeDetailsCache.get(normalizedSlug) ?? null;\n  }\n\n  // 2. Return in-flight promise if a request is already underway (concurrent dedup).\n  const existing = publicPracticeDetailsInFlight.get(normalizedSlug);\n  if (existing) {\n    return existing;\n  }\n\n  const requestPromise = (async () => {\n    try {\n      const apiUrl = `${getWorkerApiUrl()}/api/practice/details/${encodeURIComponent(normalizedSlug)}`;\n      if (import.meta.env.DEV) {\n        console.log('[getPublicPracticeDetails] Making request to:', apiUrl);\n      }\n\n      const response = await axios.get(\n        apiUrl,\n        {\n          signal: config?.signal,\n          withCredentials: true\n        }\n      );\n      const details = normalizePracticeDetailsResponse(response.data);\n      const displayDetails = extractPublicPracticeDisplayDetails(response.data);\n      const practiceId = extractPublicPracticeId(response.data);\n      if (!details) {\n        // Cache null so we don't keep retrying a practice that returned no details.\n        publicPracticeDetailsCache.set(normalizedSlug, null);\n        return null;\n      }\n      const result: PublicPracticeDetails = {\n        practiceId: practiceId ?? undefined,\n        slug: normalizedSlug,\n        details,\n        name: displayDetails.name,\n        logo: displayDetails.logo\n      };\n      publicPracticeDetailsCache.set(normalizedSlug, result);\n      return result;\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        if (error.response?.status === 404) {\n          // Cache null for 404  the practice doesn't exist, no point retrying.\n          publicPracticeDetailsCache.set(normalizedSlug, null);\n          return null;\n        }\n      }\n      // Do NOT cache transient errors (rate limit, network failure) so callers can retry.\n      throw error;\n    }\n  })();\n\n  publicPracticeDetailsInFlight.set(normalizedSlug, requestPromise);\n  try {\n    return await requestPromise;\n  } finally {\n    if (publicPracticeDetailsInFlight.get(normalizedSlug) === requestPromise) {\n      publicPracticeDetailsInFlight.delete(normalizedSlug);\n    }\n  }\n}\n\nfunction normalizePracticeUpdatePayload(payload: UpdatePracticeRequest): Record<string, unknown> {\n  const normalized = normalizePracticeDetailsPayload(payload);\n\n  if ('name' in payload && payload.name !== undefined) normalized.name = payload.name;\n  if ('slug' in payload && payload.slug !== undefined) normalized.slug = payload.slug;\n  if ('logo' in payload && payload.logo !== undefined) normalized.logo = payload.logo;\n  if ('metadata' in payload && payload.metadata !== undefined) normalized.metadata = payload.metadata;\n\n  return normalized;\n}\n\nfunction extractPublicPracticeDisplayDetails(\n  payload: unknown\n): { name?: string | null; logo?: string | null } {\n  if (!isRecord(payload)) {\n    return {};\n  }\n\n  const candidates: Record<string, unknown>[] = [];\n  const pushCandidate = (value: unknown) => {\n    if (isRecord(value)) {\n      candidates.push(value);\n    }\n  };\n\n  if ('details' in payload && isRecord(payload.details)) {\n    if ('data' in payload.details && isRecord(payload.details.data)) {\n      pushCandidate(payload.details.data);\n    }\n    pushCandidate(payload.details);\n  }\n\n  if ('data' in payload && isRecord(payload.data)) {\n    if ('details' in payload.data && isRecord(payload.data.details)) {\n      pushCandidate(payload.data.details);\n    }\n    pushCandidate(payload.data);\n  }\n\n  pushCandidate(payload);\n\n  for (const candidate of candidates) {\n    const name = toNullableString(candidate.name ?? candidate.practiceName ?? candidate.practice_name);\n    const rawLogo = toNullableString(candidate.logo ?? candidate.practiceLogo ?? candidate.practice_logo);\n    const logo = normalizePublicFileUrl(rawLogo);\n    if (name || logo) {\n      return { name, logo };\n    }\n  }\n\n  return {};\n}\n\nfunction extractPublicPracticeId(payload: unknown): string | null {\n  if (!isRecord(payload)) {\n    return null;\n  }\n  const direct = toNullableString(\n    payload.practiceId ??\n    payload.practice_id ??\n    payload.organizationId ??\n    payload.organization_id\n  );\n  if (direct) {\n    return direct;\n  }\n  const organization = payload.organization;\n  if (isRecord(organization)) {\n    const orgId = toNullableString(organization.id ?? organization.practiceId ?? organization.practice_id);\n    if (orgId) {\n      return orgId;\n    }\n  }\n  return null;\n}\n\nfunction normalizePracticeDetailsPayload(payload: PracticeDetailsUpdate): Record<string, unknown> {\n  const normalized: Record<string, unknown> = {};\n  const normalizeTextOrUndefined = (value: unknown): string | undefined => {\n    if (value === undefined || value === null) return undefined; // Do not send nulls\n    if (typeof value !== 'string') return undefined;\n    const trimmed = value.trim();\n    return trimmed.length > 0 ? trimmed : undefined;\n  };\n  const normalizeServiceKey = (value: string): string => (\n    value\n      .trim()\n      .toUpperCase()\n      .replace(/[^A-Z0-9]+/g, '_')\n      .replace(/^_+|_+$/g, '')\n  );\n\n  const businessEmail = normalizeTextOrUndefined(payload.businessEmail);\n  if (businessEmail !== undefined) normalized.business_email = businessEmail;\n  const businessPhone = normalizeTextOrUndefined(payload.businessPhone);\n  if (businessPhone !== undefined) normalized.business_phone = businessPhone;\n  if ('consultationFee' in payload && payload.consultationFee !== undefined && payload.consultationFee !== null) {\n    if (typeof payload.consultationFee === 'number') {\n      assertMajorUnits(payload.consultationFee, 'practice.consultationFee');\n    }\n    normalized.consultation_fee = toMinorUnitsValue(payload.consultationFee);\n  }\n  if ('paymentLinkEnabled' in payload && payload.paymentLinkEnabled !== undefined) {\n    normalized.payment_link_enabled = payload.paymentLinkEnabled;\n  }\n  if ('paymentLinkPrefillAmount' in payload && payload.paymentLinkPrefillAmount !== undefined) {\n    if (payload.paymentLinkPrefillAmount === null) {\n      normalized.payment_link_prefill_amount = null;\n    } else if (typeof payload.paymentLinkPrefillAmount === 'number') {\n      assertMajorUnits(payload.paymentLinkPrefillAmount, 'practice.paymentLinkPrefillAmount');\n      normalized.payment_link_prefill_amount = toMinorUnitsValue(payload.paymentLinkPrefillAmount);\n    }\n  }\n  const paymentUrl = normalizeTextOrUndefined(payload.paymentUrl);\n  if (paymentUrl !== undefined) normalized.payment_url = paymentUrl;\n  const calendlyUrl = normalizeTextOrUndefined(payload.calendlyUrl);\n  if (calendlyUrl !== undefined) normalized.calendly_url = calendlyUrl;\n  if ('billingIncrementMinutes' in payload) {\n    if (payload.billingIncrementMinutes === null) {\n      normalized.billing_increment_minutes = null;\n    } else if (typeof payload.billingIncrementMinutes === 'number' && Number.isFinite(payload.billingIncrementMinutes)) {\n      normalized.billing_increment_minutes = Math.round(payload.billingIncrementMinutes);\n    }\n  }\n  const website = normalizeTextOrUndefined(payload.website);\n  if (website !== undefined) normalized.website = website;\n  const address: Record<string, unknown> = {};\n  const addressField = normalizeTextOrUndefined(payload.address);\n  if (addressField !== undefined) address.line1 = addressField;\n  const apartmentField = normalizeTextOrUndefined(payload.apartment);\n  if (apartmentField !== undefined) address.line2 = apartmentField;\n  const city = normalizeTextOrUndefined(payload.city);\n  if (city !== undefined) address.city = city;\n  const state = normalizeTextOrUndefined(payload.state);\n  if (state !== undefined) address.state = state;\n  const postalCode = normalizeTextOrUndefined(payload.postalCode);\n  if (postalCode !== undefined) address.postal_code = postalCode;\n  const country = normalizeTextOrUndefined(payload.country);\n  if (country !== undefined) address.country = country;\n  if (Object.keys(address).length > 0) {\n    normalized.address = address;\n  }\n  if ('primaryColor' in payload && payload.primaryColor !== undefined) {\n    normalized.primary_color = payload.primaryColor;\n  }\n  if ('accentColor' in payload && payload.accentColor !== undefined) {\n    normalized.accent_color = payload.accentColor;\n  }\n  const introMessage = normalizeTextOrUndefined(payload.introMessage);\n  if (introMessage !== undefined) normalized.intro_message = introMessage;\n  const description = normalizeTextOrUndefined(payload.description);\n  if (description !== undefined) normalized.overview = description;\n  if ('isPublic' in payload && payload.isPublic !== undefined) {\n    normalized.is_public = payload.isPublic;\n  }\n  if ('services' in payload && payload.services !== undefined) {\n    if (Array.isArray(payload.services)) {\n      normalized.services = payload.services\n        .map((service) => {\n          if (!isRecord(service)) {\n            return null;\n          }\n          const rawId = toNullableString(service.id);\n          const id = rawId && /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(rawId)\n            ? rawId\n            : null;\n          const name = toNullableString(service.name ?? service.title);\n          if (!name) {\n            return null;\n          }\n          const description = toNullableString(service.description);\n          const rawKey = toNullableString(service.key);\n          const baseKey = rawKey ?? name ?? id;\n          const key = baseKey ? normalizeServiceKey(baseKey) : '';\n          if (!key) {\n            return null;\n          }\n          const next: Record<string, unknown> = { name, key };\n          if (id) {\n            next.id = id;\n          }\n          if (description) {\n            next.description = description;\n          }\n          return next;\n        })\n        .filter((service): service is Record<string, unknown> => Boolean(service));\n    } else {\n      normalized.services = payload.services;\n    }\n  }\n\n  return normalized;\n}\n\nfunction normalizePracticeDetailsResponse(payload: unknown): PracticeDetails | null {\n  if (!isRecord(payload)) {\n    return null;\n  }\n  const hasMappedDetailKey = (value: Record<string, unknown>): boolean => ([\n    'overview',\n    'description',\n    'intro_message',\n    'introMessage',\n    'business_phone',\n    'businessPhone',\n    'business_email',\n    'businessEmail',\n    'consultation_fee',\n    'consultationFee',\n    'payment_link_enabled',\n    'paymentLinkEnabled',\n    'payment_link_prefill_amount',\n    'paymentLinkPrefillAmount',\n    'billing_increment_minutes',\n    'billingIncrementMinutes',\n    'payment_url',\n    'paymentUrl',\n    'calendly_url',\n    'calendlyUrl',\n    'website',\n    'is_public',\n    'isPublic',\n    'services',\n    'address'\n  ].some((key) => key in value));\n  const resolveCandidate = (value: unknown): Record<string, unknown> | null =>\n    isRecord(value) && hasMappedDetailKey(value) ? value : null;\n  const container = (() => {\n    if ('details' in payload && isRecord(payload.details)) {\n      if ('data' in payload.details && isRecord(payload.details.data)) {\n        const nested = resolveCandidate(payload.details.data);\n        if (nested) return nested;\n      }\n      const direct = resolveCandidate(payload.details);\n      if (direct) return direct;\n    }\n    if ('data' in payload && isRecord(payload.data)) {\n      if ('details' in payload.data && isRecord(payload.data.details)) {\n        const nested = resolveCandidate(payload.data.details);\n        if (nested) return nested;\n      }\n      if ('practice' in payload.data && isRecord(payload.data.practice)) {\n        const nested = resolveCandidate(payload.data.practice);\n        if (nested) return nested;\n      }\n      if ('organization' in payload.data && isRecord(payload.data.organization)) {\n        const nested = resolveCandidate(payload.data.organization);\n        if (nested) return nested;\n      }\n      const direct = resolveCandidate(payload.data);\n      if (direct) return direct;\n    }\n    if ('practice' in payload && isRecord(payload.practice)) {\n      const nested = resolveCandidate(payload.practice);\n      if (nested) return nested;\n    }\n    if ('organization' in payload && isRecord(payload.organization)) {\n      const nested = resolveCandidate(payload.organization);\n      if (nested) return nested;\n    }\n    return resolveCandidate(payload);\n  })();\n  if (!container) {\n    return null;\n  }\n\n  const address = isRecord(container.address) ? container.address : {};\n  const getOptionalNullableString = (\n    source: Record<string, unknown>,\n    keys: string[]\n  ): string | null | undefined => {\n    for (const key of keys) {\n      if (key in source) {\n        return toNullableString(source[key]);\n      }\n    }\n    return undefined;\n  };\n  const getOptionalNullableNumber = (\n    source: Record<string, unknown>,\n    keys: string[]\n  ): number | null | undefined => {\n    for (const key of keys) {\n      if (key in source) {\n        const value = source[key];\n        if (value === null) return null;\n        if (typeof value === 'number' && Number.isFinite(value)) return value;\n        if (typeof value === 'string' && value.trim().length > 0) {\n          const parsed = Number(value);\n          return Number.isFinite(parsed) ? parsed : undefined;\n        }\n        return undefined;\n      }\n    }\n    return undefined;\n  };\n\n  return {\n    id: getOptionalNullableString(container, ['id', 'uuid', 'practice_id', 'practiceId', 'organization_id', 'organizationId']),\n    businessPhone: getOptionalNullableString(container, ['business_phone', 'businessPhone']),\n    businessEmail: getOptionalNullableString(container, ['business_email', 'businessEmail']),\n    consultationFee: (() => {\n      if ('consultation_fee' in container || 'consultationFee' in container) {\n        const value = container.consultation_fee ?? container.consultationFee;\n        if (typeof value === 'number') {\n          assertMinorUnits(value, 'practice.details.consultationFee');\n          return toMajorUnits(value);\n        }\n        return null;\n      }\n      return undefined;\n    })(),\n    paymentLinkEnabled: (() => {\n      if ('payment_link_enabled' in container || 'paymentLinkEnabled' in container) {\n        const value = container.payment_link_enabled ?? container.paymentLinkEnabled;\n        return typeof value === 'boolean' ? value : null;\n      }\n      return undefined;\n    })(),\n    paymentLinkPrefillAmount: (() => {\n      if ('payment_link_prefill_amount' in container || 'paymentLinkPrefillAmount' in container) {\n        const value = container.payment_link_prefill_amount ?? container.paymentLinkPrefillAmount;\n        if (typeof value === 'number') {\n          assertMinorUnits(value, 'practice.details.paymentLinkPrefillAmount');\n          return toMajorUnits(value);\n        }\n        return null;\n      }\n      return undefined;\n    })(),\n    paymentUrl: getOptionalNullableString(container, ['payment_url', 'paymentUrl']),\n    calendlyUrl: getOptionalNullableString(container, ['calendly_url', 'calendlyUrl']),\n    billingIncrementMinutes: getOptionalNullableNumber(container, ['billing_increment_minutes', 'billingIncrementMinutes']),\n    website: getOptionalNullableString(container, ['website']),\n    introMessage: getOptionalNullableString(container, ['intro_message', 'introMessage']),\n    description: getOptionalNullableString(container, ['overview', 'description']),\n    isPublic: 'is_public' in container || 'isPublic' in container\n      ? Boolean(container.is_public ?? container.isPublic)\n      : undefined,\n    services: 'services' in container\n      ? (Array.isArray(container.services) ? (container.services as Array<Record<string, unknown>>) : null)\n      : undefined,\n    address: getOptionalNullableString(address, ['line1', 'address']) ?? getOptionalNullableString(container, ['address']),\n    apartment: getOptionalNullableString(address, ['line2', 'apartment']) ?? getOptionalNullableString(container, ['apartment']),\n    city: getOptionalNullableString(address, ['city']) ?? getOptionalNullableString(container, ['city']),\n    state: getOptionalNullableString(address, ['state']) ?? getOptionalNullableString(container, ['state']),\n    postalCode: getOptionalNullableString(address, ['postal_code', 'postalCode'])\n      ?? getOptionalNullableString(container, ['postalCode', 'postal_code']),\n    country: getOptionalNullableString(address, ['country']) ?? getOptionalNullableString(container, ['country']),\n     primaryColor: getOptionalNullableString(container, ['primary_color', 'primaryColor']),\n     accentColor: getOptionalNullableString(container, ['accent_color', 'accentColor'])\n   };\n }\n\nexport async function requestBillingPortalSession(\n  payload: BillingPortalPayload\n): Promise<SubscriptionEndpointResult> {\n  return postSubscriptionEndpoint(getSubscriptionBillingPortalEndpoint(), {\n    referenceId: payload.practiceId,\n    customerType: payload.customerType,\n    returnUrl: payload.returnUrl\n  });\n}\n\nexport async function getCurrentSubscription(\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<CurrentSubscription | null> {\n  const response = await apiClient.get('/api/subscriptions/current', {\n    signal: config?.signal\n  });\n  const payload = response.data;\n  if (!isRecord(payload) || !('subscription' in payload)) {\n    throw new Error('Invalid /api/subscriptions/current payload: missing subscription.');\n  }\n\n  const container = payload.subscription;\n  if (container === null) {\n    return null;\n  }\n  if (!isRecord(container)) {\n    throw new Error('Invalid /api/subscriptions/current payload: subscription must be an object or null.');\n  }\n\n  const plan = isRecord(container.plan)\n    ? {\n      id: toNullableString(container.plan.id),\n      name: toNullableString(container.plan.name),\n      displayName: toNullableString(container.plan.display_name),\n      description: toNullableString(container.plan.description),\n      stripeProductId: toNullableString(container.plan.stripe_product_id),\n      stripeMonthlyPriceId: toNullableString(container.plan.stripe_monthly_price_id),\n      stripeYearlyPriceId: toNullableString(container.plan.stripe_yearly_price_id),\n      monthlyPrice: toNullableString(container.plan.monthly_price),\n      yearlyPrice: toNullableString(container.plan.yearly_price),\n      currency: toNullableString(container.plan.currency),\n      features: Array.isArray(container.plan.features)\n        ? container.plan.features.filter((feature): feature is string => typeof feature === 'string')\n        : null,\n      isActive: typeof container.plan.is_active === 'boolean' ? container.plan.is_active : null\n    }\n    : null;\n\n  return {\n    id: toNullableString(container.id),\n    status: toNullableString(container.status),\n    plan,\n    cancelAtPeriodEnd: typeof container.cancel_at_period_end === 'boolean' ? container.cancel_at_period_end : null,\n    currentPeriodStart: toNullableString(container.period_start ?? container.current_period_start),\n    currentPeriodEnd: toNullableString(container.period_end ?? container.current_period_end)\n  };\n}\n\nexport async function requestSubscriptionCancellation(\n  practiceId: string\n): Promise<SubscriptionEndpointResult> {\n  return postSubscriptionEndpoint(getSubscriptionCancelEndpoint(), { practiceId });\n}\n\nexport interface SubscriptionListItem {\n  id: string;\n  status: string;\n  [key: string]: unknown;\n}\n\nexport interface SubscriptionListResponse {\n  subscriptions?: SubscriptionListItem[];\n  data?: SubscriptionListItem[];\n}\n\nexport interface AuthSubscriptionListItem {\n  id?: string | null;\n  status?: string | null;\n  cancelAtPeriodEnd?: boolean | null;\n  cancel_at_period_end?: boolean | null;\n  currentPeriodEnd?: string | null;\n  current_period_end?: string | null;\n  plan?: Record<string, unknown> | null;\n  [key: string]: unknown;\n}\n\nfunction normalizeSubscriptionListResponse(payload: unknown): Record<string, unknown>[] {\n  if (Array.isArray(payload)) {\n    return payload.filter(isRecord);\n  }\n  if (isRecord(payload)) {\n    const subscriptions = payload.subscriptions;\n    if (Array.isArray(subscriptions)) {\n      return subscriptions.filter(isRecord);\n    }\n    const data = payload.data;\n    if (Array.isArray(data)) {\n      return data.filter(isRecord);\n    }\n  }\n  return [];\n}\n\nexport async function listAuthSubscriptions(\n  referenceId: string,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<AuthSubscriptionListItem[]> {\n  if (!referenceId) {\n    throw new Error('referenceId is required');\n  }\n\n  const response = await apiClient.get(\n    getSubscriptionListEndpoint(),\n    {\n      params: { referenceId },\n      baseURL: undefined, // Use full URL from getSubscriptionListEndpoint\n      signal: config?.signal\n    }\n  );\n\n  return normalizeSubscriptionListResponse(response.data) as AuthSubscriptionListItem[];\n}\n\nexport async function listSubscriptions(\n  referenceId: string,\n  config?: Pick<AxiosRequestConfig, 'signal'>\n): Promise<SubscriptionListItem[]> {\n  if (!referenceId) {\n    throw new Error('referenceId is required');\n  }\n\n  // Use GET request with referenceId as query parameter\n  const response = await apiClient.get(\n    getSubscriptionListEndpoint(),\n    {\n      params: { referenceId },\n      baseURL: undefined, // Use full URL from getSubscriptionListEndpoint\n      signal: config?.signal\n    }\n  );\n\n  // Handle different response shapes\n  const data = response.data as SubscriptionListResponse;\n  return normalizeSubscriptionListResponse(data) as SubscriptionListItem[];\n}\n\napiClient.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    if (error.response?.status === 401) {\n      // Guard against concurrent 401s - only handle once\n      if (!isHandling401) {\n        // Create the handler promise immediately and assign it\n        const handle401 = async () => {\n          try {\n            if (typeof window !== 'undefined') {\n              try {\n                window.dispatchEvent(new CustomEvent('auth:unauthorized'));\n              } catch (eventErr) {\n                console.error('Error dispatching auth:unauthorized event:', eventErr);\n                // Don't rethrow - let the original 401 error be the main error\n              }\n            }\n          } finally {\n            // Reset guard after handling completes, regardless of errors\n            isHandling401 = null;\n          }\n        };\n\n        // Assign the promise immediately before any async work\n        isHandling401 = handle401();\n      }\n      // Wait for the handling to complete (or already in progress)\n      await isHandling401;\n    }\n    return Promise.reject(error);\n  }\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/lib/authClient.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":180,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":180,"endColumn":20,"suggestions":[{"fix":{"range":[7101,7256],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createAuthClient } from 'better-auth/react';\nimport { organizationClient } from 'better-auth/client/plugins';\nimport { anonymousClient } from 'better-auth/client/plugins';\nimport { stripeClient } from '@better-auth/stripe/client';\nimport { transformSessionUser, type BetterAuthSessionUser } from '@/shared/types/user';\nimport { getWorkerApiUrl } from '@/config/urls';\n\n// Type for the auth client (inferred from createAuthClient return type)\ntype AuthClientType = ReturnType<typeof createAuthClient>;\ntype AuthSession = ReturnType<AuthClientType['useSession']>;\ntype AuthSessionData = AuthSession['data'];\ntype TypedSessionData = AuthSessionData extends { user: unknown; session: infer S }\n  ? { user: BetterAuthSessionUser; session: S }\n  : AuthSessionData;\n\n// Auth requests are proxied through the Worker to keep session cookies same-origin.\nfunction getAuthBaseUrl(): string | undefined {\n  if (typeof window === 'undefined') {\n    return 'https://placeholder-auth-server.com';\n  }\n\n  return getWorkerApiUrl();\n}\n\n// Cached auth client instance (only one is ever created and cached - the browser client)\n// Note: During SSR/build (prerender), a placeholder is created but never cached or used at runtime\nlet cachedAuthClient: AuthClientType | null = null;\n\n/**\n * Get or create the auth client instance.\n * The client is created lazily on first access and cached for subsequent calls.\n * Validation of VITE_BACKEND_API_URL happens in getBackendApiUrl() before client creation.\n * \n * During SSR/build, returns a placeholder client that will never be used at runtime.\n * \n * @throws {Error} If VITE_BACKEND_API_URL is missing (browser context)\n */\n/**\n * Get or create the auth client instance.\n * \n * IMPORTANT: Only ONE client is ever active at runtime:\n * - During build/prerender: Returns a minimal placeholder (prevents build errors, never cached)\n * - At runtime (browser): Creates and caches the real client (reused for all subsequent calls)\n * \n * The SSR placeholder is discarded after build - the browser client replaces it on first access.\n * \n * @throws {Error} If VITE_BACKEND_API_URL is missing (browser context)\n */\nfunction getAuthClient(): AuthClientType {\n  // If already created (browser context), return cached client\n  if (cachedAuthClient) {\n    return cachedAuthClient;\n  }\n\n  // During SSR/build (prerender), return minimal placeholder (not cached)\n  // This is ONLY to prevent build errors - it's never used at runtime\n  if (typeof window === 'undefined') {\n    const placeholderBaseURL = getAuthBaseUrl(); // Returns a placeholder during SSR/build, not the real backend URL.\n    return createAuthClient({\n      plugins: [organizationClient(), anonymousClient(), stripeClient({ subscription: true })],\n      baseURL: placeholderBaseURL,\n      fetchOptions: {\n        credentials: 'include'\n      }\n    });\n  }\n\n  // Browser context - create the REAL client (only one is ever created and cached)\n  const client = createAuthClient({\n    plugins: [organizationClient(), anonymousClient(), stripeClient({ subscription: true })],\n    baseURL: getAuthBaseUrl(),\n    fetchOptions: {\n      credentials: 'include'\n    }\n  });\n\n  // Cache the browser client (only one is ever created)\n  cachedAuthClient = client;\n  return client;\n}\n\n// Helper to get the actual client (for cases where proxy doesn't work)\nexport function getClient(): AuthClientType {\n  return getAuthClient();\n}\n\n// Export the auth client getter\nexport const authClient = new Proxy({} as AuthClientType, {\n  get(_target, prop) {\n    const client = getAuthClient();\n    const value = (client as Record<PropertyKey, unknown>)[prop];\n\n    // If it's a function, it might also have properties (like subscription.upgrade, subscription.list)\n    // Create a proxy that handles both calling the function AND accessing its properties\n    if (typeof value === 'function') {\n      const boundFn = value.bind(client);\n      // Create a function that has the properties from the original value\n      // We'll use Object.assign to copy properties, but the main approach is to proxy property access\n      const proxiedFn = Object.assign(boundFn, value);\n\n      // Return a proxy that handles both function calls and property access\n      return new Proxy(proxiedFn, {\n        apply(_target, _thisArg, args) {\n          // When called as a function, call the bound function\n          return boundFn(...args);\n        },\n        get(_target, subProp) {\n          // When accessing properties (like subscription.upgrade), get them from the original value\n          // Properties are on the original function, not the bound one\n          const subValue = (value as unknown as Record<PropertyKey, unknown>)[subProp];\n\n          if (typeof subValue === 'function') {\n            // Bind nested functions to the original value to preserve 'this'\n            return subValue.bind(value);\n          }\n          // Handle further nesting (e.g., subscription.upgrade might return an object)\n          if (subValue && typeof subValue === 'object') {\n            return new Proxy(subValue, {\n              get(_target, subSubProp) {\n                const subSubValue = subValue[subSubProp];\n                if (typeof subSubValue === 'function') {\n                  return subSubValue.bind(subValue);\n                }\n                return subSubValue;\n              }\n            });\n          }\n          return subValue;\n        }\n      });\n    }\n\n    // If it's an object (like signUp, signIn, organization which have nested methods), return a proxy for it\n    if (value && typeof value === 'object') {\n      return new Proxy(value, {\n        get(_target, subProp) {\n          const subValue = value[subProp];\n          if (typeof subValue === 'function') {\n            // Bind the function to preserve 'this' context\n            return subValue.bind(value);\n          }\n          // Handle further nesting (e.g., signUp.email)\n          if (subValue && typeof subValue === 'object') {\n            return new Proxy(subValue, {\n              get(_target, subSubProp) {\n                const subSubValue = subValue[subSubProp];\n                if (typeof subSubValue === 'function') {\n                  return subSubValue.bind(subValue);\n                }\n                return subSubValue;\n              }\n            });\n          }\n          return subValue;\n        }\n      });\n    }\n    return value;\n  }\n}) as AuthClientType;\n\nexport const signOut = (...args: Parameters<AuthClientType['signOut']>) => getAuthClient().signOut(...args);\n\n// useSession is a React hook - must be called directly, not wrapped\nexport const useSession = () => {\n  const client = getAuthClient();\n  return client.useSession();\n};\n\nexport const useTypedSession = (): Omit<AuthSession, 'data'> & { data: TypedSessionData | undefined } => {\n  const client = getAuthClient();\n  const session = client.useSession();\n  const rawUser = session.data?.user as Record<string, unknown> | undefined;\n  let typedUser: BetterAuthSessionUser | undefined;\n\n  if (rawUser) {\n    try {\n      typedUser = transformSessionUser(rawUser);\n    } catch (error) {\n      console.error('[Auth] Failed to transform session user', {\n        error,\n        userId: typeof rawUser.id === 'string' ? rawUser.id : undefined\n      });\n    }\n  }\n\n  if (session.data && typedUser) {\n    return {\n      ...session,\n      data: { ...session.data, user: typedUser }\n    };\n  }\n\n  return {\n    ...session,\n    data: undefined\n  };\n};\n\nexport const useActiveMemberRole = () => {\n  const client = getAuthClient();\n  return client.useActiveMemberRole();\n};\n\nexport const getSession = (...args: Parameters<AuthClientType['getSession']>) => getAuthClient().getSession(...args);\ntype UpdateUserArgs = Parameters<AuthClientType['updateUser']>;\ntype UpdateUserInput = Partial<BetterAuthSessionUser> & Record<string, unknown>;\ntype UpdateUserFn = (data: UpdateUserInput, options?: UpdateUserArgs[1]) => ReturnType<AuthClientType['updateUser']>;\n\nexport const updateUser: UpdateUserFn = (data, options) =>\n  getAuthClient().updateUser(\n    data as UpdateUserArgs[0],\n    options as UpdateUserArgs[1]\n  );\nexport const deleteUser = (...args: Parameters<AuthClientType['deleteUser']>) => getAuthClient().deleteUser(...args);\n\n// Keep type export for compatibility\nexport type AuthClient = typeof authClient;\n\n// Two-factor auth exports\nexport const hasTwoFactorPlugin = () => {\n  const client = getAuthClient();\n  return Boolean(client.twoFactor);\n};\n\nexport type TwoFactorClient = NonNullable<AuthClientType['twoFactor']>;\n\n// Better Auth organization plugin methods (external API uses \"organization\" terminology):\n// Note: These methods wrap Better Auth's organization plugin API which uses \"organization\" in its interface.\n// Internally we use \"practice\" terminology, but the Better Auth API still requires \"organizationId\" parameters.\n// - authClient.organization.setActive({ organizationId: string }) - Set active practice\n// - authClient.organization.create({ name, slug, logo?, metadata? }) - Create practice\n// - authClient.organization.list() - List user's practices\n// - authClient.organization.listMembers({ organizationId?, limit?, offset? }) - List members\n// - authClient.organization.getFullOrganization({ organizationId?, organizationSlug? }) - Get full practice details\n// - authClient.useActiveOrganization() - React hook for active practice\n// - authClient.organization.getActiveMemberRole() - Get user's role in active practice\n// See: https://better-auth.com/docs/plugins/organization\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/lib/conversationApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/lib/preferencesApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/mapping/addressMapping.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/mapping/payloadMapping.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/notifications/oneSignalClient.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":19,"suggestions":[{"fix":{"range":[1638,1716],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":154,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":154,"endColumn":19,"suggestions":[{"fix":{"range":[4305,4355],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":163,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":163,"endColumn":19,"suggestions":[{"fix":{"range":[4496,4558],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":196,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":196,"endColumn":17,"suggestions":[{"fix":{"range":[5264,5315],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":203,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":203,"endColumn":19,"suggestions":[{"fix":{"range":[5477,5563],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":223,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":223,"endColumn":17,"suggestions":[{"fix":{"range":[6017,6110],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":320,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":320,"endColumn":19,"suggestions":[{"fix":{"range":[8453,8520],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getWorkerApiUrl } from '@/config/urls';\n\ntype OneSignalInitOptions = {\n  appId: string;\n  allowLocalhostAsSecureOrigin?: boolean;\n  serviceWorkerPath?: string;\n  serviceWorkerUpdaterPath?: string;\n  serviceWorkerParam?: { scope?: string };\n};\n\ntype OneSignalPushSubscription = {\n  id?: string | null;\n  optedIn?: boolean | null;\n  optIn?: () => Promise<void> | void;\n  optOut?: () => Promise<void> | void;\n};\n\ntype OneSignalNotifications = {\n  requestPermission?: () => Promise<void> | void;\n};\n\ntype OneSignalUser = {\n  id?: string | null;\n  PushSubscription?: OneSignalPushSubscription | null;\n};\n\nexport type OneSignalSDK = {\n  init: (options: OneSignalInitOptions) => Promise<void> | void;\n  User?: OneSignalUser | null;\n  Notifications?: OneSignalNotifications | null;\n  getUserId?: () => Promise<string | null> | string | null;\n};\n\nconst DESTINATIONS_ENDPOINT = '/api/notifications/destinations';\nconst ONESIGNAL_WORKER_PATH = 'OneSignalSDKWorker.js';\nconst ONESIGNAL_UPDATER_PATH = 'OneSignalSDKUpdaterWorker.js';\n\nlet initStarted = false;\nlet pendingOneSignalId: string | null = null;\nlet inFlightRegistration: Promise<void> | null = null;\nlet lastRegistrationKey: string | null = null;\n\nexport type NotificationPermissionState = 'granted' | 'denied' | 'default' | 'unsupported';\n\nexport type OptInResult = {\n  permission: NotificationPermissionState;\n  subscribed: boolean;\n};\n\nexport function initOneSignal(): void {\n  if (initStarted || typeof window === 'undefined') {\n    return;\n  }\n\n  initStarted = true;\n  const appId = import.meta.env.VITE_ONESIGNAL_APP_ID;\n\n  if (!appId) {\n    if (import.meta.env.DEV) {\n      console.warn('[OneSignal] VITE_ONESIGNAL_APP_ID not set; skipping SDK init.');\n    }\n    return;\n  }\n\n  const boot = (sdk: OneSignalSDK) => {\n    void initializeSdk(sdk, appId);\n  };\n\n  const maybeSdk = window.OneSignal as OneSignalSDK | undefined;\n  if (maybeSdk && typeof maybeSdk.init === 'function') {\n    boot(maybeSdk);\n  } else {\n    const deferred = window.OneSignalDeferred ?? [];\n    deferred.push(boot);\n    window.OneSignalDeferred = deferred;\n  }\n\n  window.addEventListener('auth:session-updated', handleSessionUpdated);\n  window.addEventListener('auth:session-cleared', handleSessionCleared);\n}\n\nexport function getNotificationPermissionState(): NotificationPermissionState {\n  if (typeof window === 'undefined' || !('Notification' in window)) {\n    return 'unsupported';\n  }\n  return Notification.permission as NotificationPermissionState;\n}\n\nexport async function optInDesktopNotifications(): Promise<OptInResult> {\n  if (typeof window === 'undefined' || !('Notification' in window)) {\n    return { permission: 'unsupported', subscribed: false };\n  }\n\n  initOneSignal();\n\n  const sdk = await waitForOneSignalSdk();\n  if (sdk?.Notifications?.requestPermission && Notification.permission !== 'granted') {\n    await sdk.Notifications.requestPermission();\n  } else if (Notification.permission !== 'granted' && Notification.requestPermission) {\n    await Notification.requestPermission();\n  }\n\n  const permission = Notification.permission as NotificationPermissionState;\n  if (permission !== 'granted') {\n    return { permission, subscribed: false };\n  }\n\n  if (sdk?.User?.PushSubscription?.optIn) {\n    await sdk.User.PushSubscription.optIn();\n  }\n\n  const onesignalId = sdk ? await waitForOneSignalId(sdk, { requireOptedIn: true }) : null;\n  if (!onesignalId) {\n    return { permission, subscribed: false };\n  }\n\n  pendingOneSignalId = onesignalId;\n  await registerDestination(onesignalId);\n\n  return { permission, subscribed: true };\n}\n\nexport async function optOutDesktopNotifications(): Promise<boolean> {\n  if (typeof window === 'undefined' || !('Notification' in window)) {\n    return false;\n  }\n\n  initOneSignal();\n\n  pendingOneSignalId = null;\n  lastRegistrationKey = null;\n\n  const sdk = await waitForOneSignalSdk();\n  if (!sdk?.User?.PushSubscription) {\n    return false;\n  }\n\n  const onesignalId = await waitForOneSignalId(sdk, { requireOptedIn: false });\n  if (!onesignalId) {\n    return false;\n  }\n\n  let success = true;\n\n  try {\n    if (sdk.User.PushSubscription.optOut) {\n      await sdk.User.PushSubscription.optOut();\n    } else {\n      success = false;\n    }\n  } catch (error) {\n    success = false;\n    if (import.meta.env.DEV) {\n      console.warn('[OneSignal] opt-out failed', error);\n    }\n  }\n\n  try {\n    await disableDestination(onesignalId);\n  } catch (error) {\n    success = false;\n    if (import.meta.env.DEV) {\n      console.warn('[OneSignal] Destination disable failed', error);\n    }\n  }\n\n  return success;\n}\n\nfunction handleSessionUpdated(): void {\n  if (!pendingOneSignalId) {\n    return;\n  }\n  void registerDestination(pendingOneSignalId);\n}\n\nfunction handleSessionCleared(): void {\n  lastRegistrationKey = null;\n}\n\nasync function initializeSdk(OneSignal: OneSignalSDK, appId: string): Promise<void> {\n  try {\n    const initOptions: OneSignalInitOptions = {\n      appId,\n      serviceWorkerPath: ONESIGNAL_WORKER_PATH,\n      serviceWorkerUpdaterPath: ONESIGNAL_UPDATER_PATH,\n      serviceWorkerParam: { scope: '/' }\n    };\n\n    if (import.meta.env.DEV) {\n      initOptions.allowLocalhostAsSecureOrigin = true;\n    }\n\n    await OneSignal.init(initOptions);\n  } catch (error) {\n    console.warn('[OneSignal] SDK init failed', error);\n    return;\n  }\n\n  const onesignalId = await waitForOneSignalId(OneSignal, { requireOptedIn: true });\n  if (!onesignalId) {\n    if (import.meta.env.DEV) {\n      console.warn('[OneSignal] User id not available; skipping destination registration.');\n    }\n    return;\n  }\n\n  pendingOneSignalId = onesignalId;\n  await registerDestination(onesignalId);\n}\n\ntype OneSignalIdOptions = {\n  requireOptedIn?: boolean;\n};\n\nasync function waitForOneSignalId(\n  OneSignal: OneSignalSDK,\n  options: OneSignalIdOptions = {}\n): Promise<string | null> {\n  const requireOptedIn = options.requireOptedIn ?? false;\n  const id = await resolveOneSignalId(OneSignal, requireOptedIn);\n  if (!id && import.meta.env.DEV) {\n    console.warn('[OneSignal] User id not available after initial check; registration skipped.');\n  }\n  return id;\n}\n\nasync function resolveOneSignalId(\n  OneSignal: OneSignalSDK,\n  requireOptedIn: boolean\n): Promise<string | null> {\n  if (requireOptedIn && OneSignal.User?.PushSubscription?.optedIn === false) {\n    return null;\n  }\n\n  const subscriptionId = normalizeId(OneSignal.User?.PushSubscription?.id);\n  if (subscriptionId) {\n    return subscriptionId;\n  }\n\n  return null;\n}\n\nfunction normalizeId(value: unknown): string | null {\n  if (typeof value !== 'string') {\n    return null;\n  }\n  const trimmed = value.trim();\n  return trimmed ? trimmed : null;\n}\n\nasync function waitForOneSignalSdk(timeoutMs = 3000): Promise<OneSignalSDK | undefined> {\n  if (typeof window === 'undefined') {\n    return undefined;\n  }\n\n  const maybeSdk = window.OneSignal as OneSignalSDK | undefined;\n  if (maybeSdk?.init) {\n    return maybeSdk;\n  }\n\n  return new Promise((resolve) => {\n    let settled = false;\n    const resolveOnce = (sdk?: OneSignalSDK) => {\n      if (settled) return;\n      settled = true;\n      resolve(sdk);\n    };\n\n    const deferred = window.OneSignalDeferred ?? [];\n    deferred.push((sdk: OneSignalSDK) => resolveOnce(sdk));\n    window.OneSignalDeferred = deferred;\n\n    setTimeout(() => resolveOnce(window.OneSignal as OneSignalSDK | undefined), timeoutMs);\n  });\n}\n\nasync function registerDestination(onesignalId: string): Promise<void> {\n  const registrationKey = onesignalId;\n  if (lastRegistrationKey === registrationKey) {\n    return;\n  }\n\n  while (inFlightRegistration) {\n    await inFlightRegistration;\n    if (lastRegistrationKey === registrationKey) {\n      return;\n    }\n  }\n\n  const baseUrl = getWorkerApiUrl();\n\n  const send = async () => {\n    const response = await fetch(`${baseUrl}${DESTINATIONS_ENDPOINT}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      credentials: 'include',\n      body: JSON.stringify({\n        onesignalId,\n        platform: 'web'\n      })\n    });\n\n    if (!response.ok) {\n      const text = await response.text().catch(() => '');\n      throw new Error(`Destination registration failed (${response.status}): ${text}`);\n    }\n  };\n\n  inFlightRegistration = send();\n\n  try {\n    await inFlightRegistration;\n    lastRegistrationKey = registrationKey;\n  } catch (error) {\n    lastRegistrationKey = null;\n    if (import.meta.env.DEV) {\n      console.warn('[OneSignal] Destination registration failed', error);\n    }\n  } finally {\n    inFlightRegistration = null;\n  }\n}\n\nasync function disableDestination(onesignalId: string): Promise<void> {\n  const baseUrl = getWorkerApiUrl();\n  const response = await fetch(`${baseUrl}${DESTINATIONS_ENDPOINT}/${onesignalId}`, {\n    method: 'DELETE',\n    credentials: 'include'\n  });\n\n  if (!response.ok) {\n    const text = await response.text().catch(() => '');\n    throw new Error(`Destination disable failed (${response.status}): ${text}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/schemas/api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/schemas/client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/schemas/intake.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/schemas/practice.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/schemas/ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/services/upload/UploadTransport.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":39,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":39,"endColumn":19,"suggestions":[{"fix":{"range":[984,1084],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Upload Transport Service\n * \n * Handles file uploads with progress tracking using XHR.\n * Integrates with existing Cloudflare Workers /api/files/upload endpoint.\n */\n\nimport { getWorkerApiUrl } from '@/config/urls';\n\nexport interface UploadProgress {\n  loaded: number;\n  total: number;\n  percentage: number;\n}\n\nexport interface UploadResult {\n  fileId: string;\n  fileName: string;\n  fileType: string;\n  fileSize: number;\n  url: string;\n  storageKey: string;\n}\n\nexport interface UploadOptions {\n  practiceId: string;\n  conversationId?: string;\n  onProgress?: (progress: UploadProgress) => void;\n  onSuccess?: (result: UploadResult) => void;\n  onError?: (error: Error) => void;\n  signal?: AbortSignal;\n}\n\nexport const getWorkerRequestUrl = (path: string): string => {\n  const baseUrl = getWorkerApiUrl();\n  try {\n    const resolved = new URL(path, baseUrl);\n    if (typeof window !== 'undefined' && window.location.protocol === 'https:' && resolved.protocol === 'http:') {\n      console.warn('[UploadTransport] Worker API is HTTP on an HTTPS page; upgrading to HTTPS:', baseUrl);\n      resolved.protocol = 'https:';\n      return resolved.toString();\n    }\n    return resolved.toString();\n  } catch {\n    return path;\n  }\n};\n\n/**\n * Upload a file with progress tracking using XMLHttpRequest\n * \n * @param file - The file to upload\n * @param options - Upload configuration and callbacks\n * @returns Promise that resolves with upload result\n */\nexport async function uploadWithProgress(\n  file: File,\n  options: UploadOptions\n): Promise<UploadResult> {\n  const { practiceId, conversationId, onProgress, onSuccess, onError, signal } = options;\n\n  return new Promise((resolve, reject) => {\n    // Preflight abort check - if already aborted, don't create XHR\n    if (signal?.aborted) {\n      const abortError = new Error('Upload cancelled');\n      abortError.name = 'AbortError';\n      reject(abortError);\n      return;\n    }\n\n    const xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    \n    // Track last progress values for accurate final progress update\n    let lastProgress: { loaded: number; total: number } | null = null;\n\n    // Store abort handler for cleanup\n    let abortHandler: (() => void) | null = null;\n\n    // Cleanup function to remove abort signal listener\n    const cleanup = () => {\n      if (signal && abortHandler) {\n        signal.removeEventListener('abort', abortHandler);\n        abortHandler = null;\n      }\n    };\n\n    // Wrapper functions that ensure cleanup is called\n    const resolveWithCleanup = (result: UploadResult) => {\n      cleanup();\n      resolve(result);\n    };\n\n    const rejectWithCleanup = (error: Error) => {\n      cleanup();\n      reject(error);\n    };\n\n    // Handle upload progress\n    xhr.upload.addEventListener('progress', (event) => {\n      if (event.lengthComputable && onProgress) {\n        lastProgress = {\n          loaded: event.loaded,\n          total: event.total\n        };\n        const progress: UploadProgress = {\n          loaded: event.loaded,\n          total: event.total,\n          percentage: Math.round((event.loaded / event.total) * 90) // Cap at 90% during upload\n        };\n        onProgress(progress);\n      }\n    });\n\n    // Handle successful upload\n    xhr.addEventListener('load', () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        try {\n          const response = JSON.parse(xhr.responseText);\n          \n          if (response.success && response.data) {\n            const prefix = conversationId\n              ? `uploads/${practiceId}/${conversationId}`\n              : null;\n            const storageKey = response.data.storageKey || (prefix\n              ? (response.data.fileExtension\n                ? `${prefix}/${response.data.fileId}.${response.data.fileExtension}`\n                : `${prefix}/${response.data.fileId}`)\n              : undefined);\n            if (!storageKey) {\n              throw new Error('Upload failed: missing storageKey');\n            }\n            const result: UploadResult = {\n              fileId: response.data.fileId,\n              fileName: response.data.fileName,\n              fileType: response.data.fileType,\n              fileSize: response.data.fileSize,\n              url: response.data.url,\n              storageKey\n            };\n\n            // Final progress update to 100%\n            if (onProgress) {\n              const total = lastProgress?.total || file.size;\n              const _loaded = lastProgress?.loaded || file.size;\n              onProgress({\n                loaded: total, // Use total as loaded for 100% completion\n                total,\n                percentage: 100\n              });\n            }\n\n            onSuccess?.(result);\n            resolveWithCleanup(result);\n          } else {\n            const error = new Error(response.message || 'Upload failed: Invalid response format');\n            onError?.(error);\n            rejectWithCleanup(error);\n          }\n        } catch (parseError) {\n          const error = new Error(`Upload failed: Invalid JSON response - ${parseError instanceof Error ? parseError.message : 'Unknown error'}`);\n          onError?.(error);\n          rejectWithCleanup(error);\n        }\n      } else {\n        const error = new Error(`Upload failed: HTTP ${xhr.status} - ${xhr.statusText}`);\n        onError?.(error);\n        rejectWithCleanup(error);\n      }\n    });\n\n    // Handle network errors\n    xhr.addEventListener('error', () => {\n      const error = new Error('Network error during upload');\n      onError?.(error);\n      rejectWithCleanup(error);\n    });\n\n    // Handle abort\n    xhr.addEventListener('abort', () => {\n      const error = new Error('Upload cancelled');\n      onError?.(error);\n      rejectWithCleanup(error);\n    });\n\n    // Handle abort signal\n    if (signal) {\n      // Preflight abort check - if already aborted, don't attach listener\n      if (signal.aborted) {\n        const abortError = new Error('Upload cancelled');\n        abortError.name = 'AbortError';\n        rejectWithCleanup(abortError);\n        return;\n      }\n      \n      abortHandler = () => {\n        xhr.abort();\n      };\n      signal.addEventListener('abort', abortHandler);\n    }\n\n    // Build FormData (matches existing endpoint format)\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('practiceId', practiceId);\n    if (conversationId) {\n      formData.append('conversationId', conversationId);\n    }\n\n    // Send request to existing endpoint\n    xhr.open('POST', getWorkerRequestUrl('/api/files/upload'));\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    xhr.send(formData);\n  });\n}\n\n/**\n * Cancel an ongoing upload\n * \n * @param xhr - The XMLHttpRequest instance to cancel\n */\nexport function cancelUpload(xhr: XMLHttpRequest): void {\n  if (xhr.readyState !== XMLHttpRequest.DONE) {\n    xhr.abort();\n  }\n}\n\n/**\n * Validate file before upload\n * \n * @param file - The file to validate\n * @returns Validation result with error message if invalid\n */\nexport function validateFile(file: File): { isValid: boolean; error?: string } {\n  const MAX_FILE_SIZE = 25 * 1024 * 1024; // 25MB\n  const ALLOWED_TYPES = [\n    'image/jpeg',\n    'image/jpg', // Retained for legacy systems that may report this non-standard MIME type\n    'image/png',\n    'image/webp',\n    'image/gif',\n    'video/mp4',\n    'video/webm',\n    'audio/mpeg',\n    'audio/wav',\n    'audio/ogg',\n    'application/pdf',\n    'text/plain',\n    'text/csv',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/vnd.ms-excel',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n  ];\n\n  if (file.size > MAX_FILE_SIZE) {\n    return {\n      isValid: false,\n      error: `File size must be less than ${Math.round(MAX_FILE_SIZE / 1024 / 1024)}MB`\n    };\n  }\n\n  if (!ALLOWED_TYPES.includes(file.type)) {\n    return {\n      isValid: false,\n      error: 'File type not supported'\n    };\n  }\n\n  return { isValid: true };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/stores/practiceDetailsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/address.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/conversation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/domains.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/intake.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/matter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/matterStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/notifications.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/onboarding.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/preferences.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/user.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/types/workspace.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/Accordion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/Button.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":76,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":76,"endColumn":19,"suggestions":[{"fix":{"range":[1974,2155],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentChildren, toChildArray, cloneElement } from 'preact';\nimport type { JSX } from 'preact';\nimport { forwardRef } from 'preact/compat';\n\ntype ButtonVariant =\n  | 'primary'\n  | 'secondary'\n  | 'ghost'\n  | 'icon'\n  | 'inverted'\n  | 'danger'\n  | 'warning'\n  | 'danger-ghost'\n  | 'accent-ghost'\n  | 'outline'\n  | 'link'\n  | 'menu-item'\n  | 'tab';\ntype ButtonSize =\n  | 'xs'\n  | 'sm'\n  | 'md'\n  | 'lg'\n  | 'icon'\n  | 'icon-xs'\n  | 'icon-sm'\n  | 'icon-md'\n  | 'icon-lg';\n\ninterface ButtonProps extends JSX.HTMLAttributes<HTMLButtonElement> {\n  variant?: ButtonVariant;\n  size?: ButtonSize;\n  disabled?: boolean;\n  children?: ComponentChildren;\n  className?: string;\n  type?: 'button' | 'submit' | 'reset';\n  form?: string;\n  style?: JSX.CSSProperties;\n  icon?: ComponentChildren;\n  iconPosition?: 'left' | 'right';\n  'aria-current'?: 'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false';\n  'aria-pressed'?: boolean | 'true' | 'false' | 'mixed';\n  'aria-expanded'?: boolean | 'true' | 'false';\n  'aria-label'?: string;\n  'aria-describedby'?: string;\n  title?: string;\n}\n\nexport const Button = forwardRef<HTMLButtonElement, ButtonProps>(function Button({\n  variant = 'primary',\n  size = 'md',\n  disabled = false,\n  onClick,\n  children,\n  className = '',\n  type = 'button',\n  style,\n  icon,\n  iconPosition = 'left',\n  'aria-current': ariaCurrent,\n  'aria-pressed': ariaPressed,\n  'aria-expanded': ariaExpanded,\n  'aria-label': ariaLabel,\n  'aria-describedby': ariaDescribedby,\n  title,\n  ...rest\n}, ref) {\n  // Check if this is an icon-only button (no children, only icon)\n  const hasChildren = toChildArray(children).length > 0;\n  const isIconOnly = !hasChildren && Boolean(icon);\n\n  // Development-time accessibility warning for icon-only buttons\n  if (typeof import.meta !== 'undefined' && import.meta.env?.DEV && isIconOnly) {\n    const hasAccessibleLabel = Boolean(ariaLabel || rest['aria-labelledby'] || title);\n    if (!hasAccessibleLabel) {\n      console.warn(\n        'Button: Icon-only button detected without accessible label. ' +\n        'Please add an aria-label, aria-labelledby, or title prop for accessibility.'\n      );\n    }\n  }\n\n  const variantToClass: Record<ButtonVariant, string> = {\n    primary: 'btn-primary',\n    secondary: 'btn-secondary',\n    ghost: 'btn-ghost',\n    icon: 'btn-icon',\n    inverted: 'btn-inverted',\n    danger: 'btn-danger',\n    warning: 'btn-warning',\n    'danger-ghost': 'btn-danger-ghost',\n    'accent-ghost': 'btn-accent-ghost',\n    outline: 'btn-outline',\n    link: 'btn-link',\n    'menu-item': 'btn-menu-item',\n    tab: 'btn-tab'\n  };\n\n  const sizeToClass = (resolvedSize: ButtonSize): string => {\n    if (resolvedSize === 'icon') return 'btn-icon-md';\n    if (resolvedSize === 'icon-xs') return 'btn-icon-xs';\n    if (resolvedSize === 'icon-sm') return 'btn-icon-sm';\n    if (resolvedSize === 'icon-md') return 'btn-icon-md';\n    if (resolvedSize === 'icon-lg') return 'btn-icon-lg';\n    if (isIconOnly) return `btn-icon-${resolvedSize}`;\n    return `btn-${resolvedSize}`;\n  };\n\n  const hasVariantOverride = /\\bbtn-(primary|secondary|ghost|icon|inverted|danger|warning|danger-ghost|accent-ghost|outline|link|menu-item|tab)\\b/.test(className);\n  const hasSizeOverride = /\\bbtn-(xs|sm|md|lg|icon-xs|icon-sm|icon-md|icon-lg)\\b/.test(className);\n\n  const classes = [\n    'btn',\n    hasVariantOverride ? '' : variantToClass[variant],\n    hasSizeOverride ? '' : sizeToClass(size),\n    className\n  ].filter(Boolean).join(' ');\n\n  const renderContent = () => {\n    if (isIconOnly) {\n      return icon;\n    }\n    \n    if (!icon) {\n      return children;\n    }\n    \n    // Helper function to make icon decorative\n    const makeIconDecorative = (iconElement: ComponentChildren) => {\n      if (typeof iconElement === 'object' && iconElement !== null && 'type' in iconElement) {\n        // If it's a Preact element, clone it with decorative attributes\n        return cloneElement(iconElement as JSX.Element, { \n          'aria-hidden': 'true', \n          focusable: 'false' \n        });\n      }\n      // If it's a string or other type, wrap it in a span with decorative attributes\n      return <span aria-hidden=\"true\">{iconElement}</span>;\n    };\n    \n    if (iconPosition === 'right') {\n      return (\n        <>\n          {children}\n          <span className={variant === 'menu-item' ? '' : 'ml-2'}>{makeIconDecorative(icon)}</span>\n        </>\n      );\n    }\n    \n    return (\n      <>\n        <span className={variant === 'menu-item' ? '' : 'mr-2'}>{makeIconDecorative(icon)}</span>\n        {children}\n      </>\n    );\n  };\n  \n  return (\n    <button\n      ref={ref}\n      type={type}\n      className={classes}\n      disabled={disabled}\n      onClick={onClick}\n      style={style}\n      aria-current={ariaCurrent}\n      aria-pressed={ariaPressed}\n      aria-expanded={ariaExpanded}\n      aria-label={ariaLabel}\n      aria-describedby={ariaDescribedby}\n      {...rest}\n    >\n      {renderContent()}\n    </button>\n  );\n}); \n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/CopyButton.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":46,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":46,"endColumn":20,"suggestions":[{"fix":{"range":[1306,1359],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useEffect } from 'preact/hooks';\nimport { ClipboardIcon } from '@heroicons/react/24/outline';\nimport { Button } from './Button';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\n\ninterface CopyButtonProps {\n  text: string;\n  label?: string;\n  className?: string;\n  disabled?: boolean;\n}\n\nexport const CopyButton = ({ text, label, className = '', disabled = false }: CopyButtonProps) => {\n  const { showSuccess, showError } = useToastContext();\n  const [copied, setCopied] = useState(false);\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  \n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n    };\n  }, []);\n  \n  const handleCopy = async () => {\n    if (disabled) return;\n    \n    try {\n      await navigator.clipboard.writeText(text);\n      setCopied(true);\n      showSuccess('Copied!', label || text);\n      \n      // Clear any existing timeout\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      \n      // Set timeout to reset copied state\n      timeoutRef.current = setTimeout(() => {\n        setCopied(false);\n        timeoutRef.current = null;\n      }, 2000);\n    } catch (error) {\n      console.error('Failed to copy to clipboard:', error);\n      showError('Failed to copy to clipboard', error instanceof Error ? error.message : 'Unknown error');\n    }\n  };\n  \n  return (\n    <Button \n      variant=\"icon\" \n      size=\"sm\" \n      onClick={handleCopy} \n      disabled={disabled}\n      aria-label={copied ? 'Copied!' : 'Copy to clipboard'}\n      className={className}\n    >\n      <ClipboardIcon className=\"w-4 h-4\" />\n      {copied ? 'Copied!' : (label || 'Copy')}\n    </Button>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/Icon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/Logo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/SidebarNavigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/__tests__/CopyButton.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/__tests__/SidebarNavigation.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/accessibility/ariaLabels.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/accessibility/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/activity/ActivityTimeline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/activity/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/address/AddressExperienceForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/address/AddressFields.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/address/AddressInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/badges/OnboardingStatusBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/badges/RoleBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/badges/StatusBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/badges/__tests__/StatusBadge.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/badges/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/cards/NextStepsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/cards/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/dropdown/DropdownMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/dropdown/DropdownMenuCheckboxItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/dropdown/DropdownMenuContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/dropdown/DropdownMenuItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/dropdown/DropdownMenuTrigger.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":22,"suggestions":[{"fix":{"range":[1697,1765],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":78,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":78,"endColumn":22,"suggestions":[{"fix":{"range":[2331,2401],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":108,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":108,"endColumn":26,"suggestions":[{"fix":{"range":[3489,3546],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":120,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":120,"endColumn":26,"suggestions":[{"fix":{"range":[3980,4039],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentChildren, cloneElement, isValidElement, RefObject, VNode } from 'preact';\nimport { useContext, useRef } from 'preact/hooks';\nimport { cn } from '@/shared/utils/cn';\nimport { DropdownContext } from './DropdownMenu';\n\nexport interface DropdownMenuTriggerProps {\n  children: ComponentChildren;\n  asChild?: boolean;\n  className?: string;\n  onClick?: () => void;\n  onKeyDown?: (event: KeyboardEvent) => void;\n}\n\nexport const DropdownMenuTrigger = ({\n  children,\n  asChild = false,\n  className = '',\n  onClick,\n  onKeyDown\n}: DropdownMenuTriggerProps) => {\n  const context = useContext(DropdownContext);\n  const triggerRef = useRef<HTMLElement | null>(null);\n  \n  if (!context) {\n    throw new Error('DropdownMenuTrigger must be used within a DropdownMenu');\n  }\n\n  const { isOpen, handleOpenChange, dropdownId } = context;\n\n  // Helper function to safely assign refs\n  const assignRef = (node: HTMLElement | null, targetRef: RefObject<HTMLElement | null>, forwardedRef?: unknown) => {\n    // Update the target ref\n    if (targetRef) {\n      (targetRef as RefObject<HTMLElement | null>).current = node;\n    }\n    \n    // Handle forwarded ref (function or object)\n    if (forwardedRef) {\n      if (typeof forwardedRef === 'function') {\n        (forwardedRef as (node: HTMLElement | null) => void)(node);\n      } else if (forwardedRef && typeof forwardedRef === 'object' && 'current' in forwardedRef) {\n        (forwardedRef as { current: HTMLElement | null }).current = node;\n      }\n    }\n  };\n\n  const handleClick = (_event?: MouseEvent) => {\n    // Always call the custom onClick if provided (safely)\n    if (onClick) {\n      try {\n        onClick();\n      } catch (error) {\n        console.error('Error in dropdown trigger onClick callback:', error);\n      }\n    }\n    \n    // Always toggle the dropdown state\n    handleOpenChange(!isOpen);\n  };\n\n  const handleKeyDown = (event: KeyboardEvent) => {\n    // Handle keyboard navigation\n    if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault();\n      handleClick();\n    } else if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      if (!isOpen) {\n        handleOpenChange(true);\n      }\n    }\n    \n    // Call custom onKeyDown if provided\n    if (onKeyDown) {\n      try {\n        onKeyDown(event);\n      } catch (error) {\n        console.error('Error in dropdown trigger onKeyDown callback:', error);\n      }\n    }\n  };\n\n  if (asChild) {\n    // When asChild is true, we expect the child to be a single element\n    // that we'll clone with additional props\n    if (!isValidElement(children)) {\n      throw new Error('DropdownMenuTrigger with asChild requires a single React element as children');\n    }\n\n    // Assert children is a VNode and extract props\n    const childElement = children as VNode<Record<string, unknown>>;\n    const childProps = childElement.props as Record<string, unknown>;\n\n    // Create merged ref function with proper typing\n    const mergedRef = (element: HTMLElement | null) => {\n      assignRef(element, triggerRef, childElement.ref);\n    };\n\n    // Prepare trigger props to merge\n    const triggerProps = {\n      onClick: (event: MouseEvent) => {\n        // Call the child's onClick if it exists with error handling\n        const onClickHandler = childProps.onClick;\n        if (onClickHandler && typeof onClickHandler === 'function') {\n          try {\n            (onClickHandler as (event: MouseEvent) => void)(event);\n          } catch (error) {\n            console.error('Error in child onClick callback:', error);\n          }\n        }\n        handleClick(event);\n      },\n      onKeyDown: (event: KeyboardEvent) => {\n        // Call the child's onKeyDown if it exists with error handling\n        const onKeyDownHandler = childProps.onKeyDown;\n        if (onKeyDownHandler && typeof onKeyDownHandler === 'function') {\n          try {\n            (onKeyDownHandler as (event: KeyboardEvent) => void)(event);\n          } catch (error) {\n            console.error('Error in child onKeyDown callback:', error);\n          }\n        }\n        handleKeyDown(event);\n      },\n      ref: mergedRef,\n      'aria-haspopup': 'menu' as const,\n      'aria-expanded': isOpen,\n      'aria-controls': `${dropdownId}-menu`,\n      id: `${dropdownId}-trigger`,\n      className: cn(\n        (typeof childProps.className === 'string' ? childProps.className : '') || '',\n        className\n      ),\n      tabIndex: 0, // Ensure keyboard accessibility\n    };\n\n    // Clone the child element with merged props\n    return cloneElement(childElement, triggerProps);\n  }\n\n  return (\n    <button\n      type=\"button\"\n      ref={(node) => assignRef(node, triggerRef)}\n      onClick={handleClick}\n      onKeyDown={handleKeyDown}\n      className={cn(\n        'flex items-center gap-2 px-3 py-1 text-sm text-input-text rounded-md',\n        'hover:bg-surface-glass/50 focus:outline-none focus:ring-2 focus:ring-accent-500',\n        className\n      )}\n      aria-haspopup=\"menu\"\n      aria-expanded={isOpen}\n      aria-controls={`${dropdownId}-menu`}\n      id={`${dropdownId}-trigger`}\n    >\n      {children}\n    </button>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/dropdown/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/form/Form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/form/FormActions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/form/FormControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/form/FormDescription.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/form/FormField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/form/FormItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/form/FormLabel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/form/FormMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/form/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/Checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/Combobox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/CurrencyInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/DatePicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/EmailInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/FileInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/Input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/LogoUploadInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/MarkdownUploadTextarea.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[649,652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[649,652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/NumberInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/PasswordInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/PhoneInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/RadioGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/RadioGroupWithDescriptions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/SegmentedToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/Switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/Textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/URLInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/input/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/AppShell.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/BottomBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/FormGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/FormItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/IconContainer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/LoadingSpinner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/Page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/PageHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/Panel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/SectionDivider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/SetupShell.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/SplitView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/accentBackdrop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/layout/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/navigation/Breadcrumbs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/navigation/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/practice/PracticeProfileTextFields.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/profile/atoms/Avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/profile/atoms/ProfileIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/profile/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/profile/molecules/ProfileButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/profile/molecules/ProfileDropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/profile/molecules/ProfileMenuItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/profile/molecules/StackedAvatars.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/profile/organisms/UserProfileDisplay.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":109,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":109,"endColumn":20,"suggestions":[{"fix":{"range":[3284,3327],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * UserProfileDisplay - Organism Component\n * \n * Orchestrates collapsed/expanded states and dropdown for user profile.\n * Handles state management and user interactions.\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { UserIcon } from '@heroicons/react/24/outline';\nimport { ProfileButton } from '../molecules/ProfileButton';\nimport { ProfileDropdown } from '../molecules/ProfileDropdown';\nimport { useSessionContext } from '@/shared/contexts/SessionContext';\nimport { useToastContext } from '@/shared/contexts/ToastContext';\nimport { signOut } from '@/shared/utils/auth';\nimport { useNavigation } from '@/shared/utils/navigation';\nimport { useMobileDetection } from '@/shared/hooks/useMobileDetection';\nimport { useTranslation } from '@/shared/i18n/hooks';\n\ninterface UserProfileDisplayProps {\n  isCollapsed?: boolean;\n}\n\nexport const UserProfileDisplay = ({ \n  isCollapsed = false\n}: UserProfileDisplayProps) => {\n  const { t } = useTranslation(['profile', 'common']);\n  const { session, isPending, error } = useSessionContext();\n  const { showError } = useToastContext();\n  const [showDropdown, setShowDropdown] = useState(false);\n  const [signOutError, setSignOutError] = useState<string | null>(null);\n  const dropdownRef = useRef<HTMLDivElement>(null);\n  const { navigateToAuth, navigate } = useNavigation();\n  const isMobile = useMobileDetection();\n\n  // Derive user data from session and practice\n  const user = session?.user ? {\n    id: session.user.id,\n    name: session.user.name || session.user.email || 'User',\n    email: session.user.email,\n    image: session.user.image\n  } : null;\n\n\n  const loading = isPending;\n\n  // Handle dropdown close when clicking outside or pressing Escape\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {\n        setShowDropdown(false);\n      }\n    };\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        setShowDropdown(false);\n      }\n    };\n\n    if (showDropdown) {\n      document.addEventListener('mousedown', handleClickOutside);\n      document.addEventListener('keydown', handleKeyDown);\n    }\n\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [showDropdown]);\n\n  const handleSignIn = () => {\n    navigateToAuth('signin');\n  };\n\n  const handleProfileClick = () => {\n    if (isMobile) {\n      // On mobile, directly navigate to settings\n      if (window.location.pathname.startsWith('/settings')) {\n        return;\n      }\n      navigate('/settings');\n    } else {\n      // On desktop, show dropdown\n      setShowDropdown(!showDropdown);\n    }\n  };\n\n  const handleSettingsClick = () => {\n    setShowDropdown(false);\n    if (window.location.pathname.startsWith('/settings')) {\n      return;\n    }\n    navigate('/settings');\n  };\n\n  const handleHelpClick = () => {\n    setShowDropdown(false);\n    navigate('/settings/help');\n  };\n\n\n  const handleLogoutClick = async () => {\n    setShowDropdown(false);\n    setSignOutError(null); // Clear any previous errors\n    \n    try {\n      await signOut({ navigate });\n    } catch (error) {\n      console.error('Error signing out:', error);\n      \n      // Show user-friendly error message via toast\n      const errorMessage = error instanceof Error && error.message\n        ? error.message\n        : t('profile:errors.signOutFailed');\n      \n      showError(\n        t('profile:errors.signOutFailedTitle'),\n        errorMessage\n      );\n      \n      // Also set local error state for inline display as fallback\n      setSignOutError(errorMessage);\n    }\n  };\n\n  if (loading) {\n    return (\n      <div className={`flex items-center ${isCollapsed ? 'justify-center py-2' : 'gap-3 px-3 py-2'}`}>\n        <div className=\"w-8 h-8 bg-surface-glass/60 rounded-full animate-pulse\" />\n        {!isCollapsed && <div className=\"w-20 h-4 bg-surface-glass/60 rounded animate-pulse\" />}\n      </div>\n    );\n  }\n\n  // Handle session fetch errors\n  if (error) {\n    return (\n      <div className={`p-2 border-t border-line-glass/30`}>\n        <div className={`flex items-center ${isCollapsed ? 'justify-center py-2' : 'gap-3 px-3 py-2'}`}>\n          <div className=\"w-8 h-8 bg-red-100 dark:bg-red-900/20 rounded-full flex items-center justify-center flex-shrink-0\">\n            <UserIcon className=\"w-4 h-4 text-red-600 dark:text-red-400\" />\n          </div>\n          {!isCollapsed && (\n            <div className=\"flex-1 min-w-0\">\n              <p className=\"text-sm font-medium text-red-600 dark:text-red-400\">\n                Failed to load session\n              </p>\n              <p className=\"text-xs text-input-placeholder\">\n                Please try refreshing the page\n              </p>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  if (!user) {\n    return (\n      <div className={`p-2 border-t border-line-glass/30`}>\n        <button\n          onClick={handleSignIn}\n          className={`flex items-center w-full rounded-lg text-left transition-colors text-input-text hover:bg-surface-glass/50 ${\n            isCollapsed \n              ? 'justify-center py-2' \n              : 'gap-3 px-3 py-2'\n          }`}\n          title={isCollapsed ? t('profile:menu.signIn') : undefined}\n          aria-label={t('profile:aria.signInButton')}\n        >\n          <UserIcon className=\"w-5 h-5 flex-shrink-0\" />\n          {!isCollapsed && <span className=\"text-sm font-medium\">{t('profile:menu.signIn')}</span>}\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`p-2 border-t border-line-glass/30 w-full overflow-visible`}>\n      <div className=\"relative w-full max-w-full\" ref={dropdownRef}>\n        <ProfileButton\n          name={user.name}\n          image={user.image}\n          secondaryText={user.email ?? null}\n          isCollapsed={isCollapsed}\n          onClick={handleProfileClick}\n        />\n        \n        {/* Dropdown - only show on desktop */}\n        {showDropdown && !isMobile && (\n          <ProfileDropdown\n            onSettings={handleSettingsClick}\n            onHelp={handleHelpClick}\n            onLogout={handleLogoutClick}\n            signOutError={signOutError}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/atoms/CollapsibleToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/atoms/NavigationIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/atoms/NotificationDot.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/atoms/PracticeLogo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/atoms/StatusDot.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/molecules/NavigationItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/molecules/NavigationList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/molecules/SidebarHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/sidebar/organisms/SidebarContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/table/DataTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/table/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/tabs/Tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/tabs/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/tag/TagInput.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/tag/TagInput.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":149,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":149,"endColumn":22,"suggestions":[{"fix":{"range":[4942,4993],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TagInput - Molecule Component\n * \n * Multi-select input with freeform entry, tag display, and optional suggestions.\n * Follows ARIA combobox pattern for accessibility.\n */\n\nimport { useState, useRef, useEffect, useMemo, useCallback } from 'preact/hooks';\nimport { forwardRef } from 'preact/compat';\nimport { cn } from '@/shared/utils/cn';\nimport { useTranslation } from '@/shared/i18n/hooks';\nimport { useUniqueId } from '@/shared/hooks/useUniqueId';\nimport { Tag } from './atoms/Tag';\n\nexport interface TagInputProps {\n  value: string[];\n  onChange: (tags: string[]) => void;\n  suggestions?: string[];\n  placeholder?: string;\n  label?: string;\n  description?: string;\n  error?: string;\n  disabled?: boolean;\n  maxTags?: number;\n  maxTagLength?: number;\n  allowDuplicates?: boolean;\n  normalizeTag?: (tag: string) => string;\n  delimiters?: string[];\n  onValidate?: (tag: string) => boolean | string;\n  asyncSuggestions?: (query: string) => Promise<string[]>;\n  size?: 'sm' | 'md' | 'lg';\n  variant?: 'default' | 'error' | 'success';\n  className?: string;\n  // i18n support\n  labelKey?: string;\n  descriptionKey?: string;\n  placeholderKey?: string;\n  errorKey?: string;\n  namespace?: string;\n  // ARIA\n  id?: string;\n  'aria-label'?: string;\n  'data-testid'?: string;\n}\n\nexport const TagInput = forwardRef<HTMLInputElement, TagInputProps>(({\n  value = [],\n  onChange,\n  suggestions = [],\n  placeholder = 'Type and press Enter',\n  label,\n  description,\n  error,\n  disabled = false,\n  maxTags,\n  maxTagLength,\n  allowDuplicates = false,\n  normalizeTag,\n  delimiters = [',', 'Enter'],\n  onValidate,\n  asyncSuggestions,\n  size = 'md',\n  variant = 'default',\n  className = '',\n  labelKey,\n  descriptionKey,\n  placeholderKey,\n  errorKey,\n  namespace = 'common',\n  id,\n  'aria-label': ariaLabel,\n  'data-testid': dataTestId,\n  ...restProps\n}, ref) => {\n  const { t } = useTranslation(namespace);\n  const generatedId = useUniqueId('tag-input');\n  const inputId = id || generatedId;\n  const containerRef = useRef<HTMLDivElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const dropdownRef = useRef<HTMLDivElement>(null);\n  const liveRegionRef = useRef<HTMLDivElement>(null);\n\n  const [inputValue, setInputValue] = useState('');\n  const [isDropdownOpen, setIsDropdownOpen] = useState(false);\n  const [focusedSuggestionIndex, setFocusedSuggestionIndex] = useState(-1);\n  const [isComposing, setIsComposing] = useState(false);\n  const [asyncSuggestionsList, setAsyncSuggestionsList] = useState<string[]>([]);\n  const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);\n\n  const displayLabel = labelKey ? t(labelKey) : label;\n  const displayDescription = descriptionKey ? t(descriptionKey) : description;\n  const displayPlaceholder = placeholderKey ? t(placeholderKey) : placeholder;\n  const displayError = errorKey ? t(errorKey) : error;\n\n  // Combine static and async suggestions\n  const allSuggestions = useMemo(() => {\n    if (asyncSuggestionsList.length > 0) {\n      return [...suggestions, ...asyncSuggestionsList];\n    }\n    return suggestions;\n  }, [suggestions, asyncSuggestionsList]);\n\n  // Helper function to compute filtered suggestions synchronously\n  const computeFilteredSuggestions = useCallback((query: string, suggestionsList: string[], currentTags: string[]) => {\n    if (!query.trim()) return [];\n    \n    const lowerInput = query.toLowerCase();\n    return suggestionsList\n      .filter(suggestion => {\n        const lowerSuggestion = suggestion.toLowerCase();\n        // Don't show if already in tags (unless duplicates allowed)\n        if (!allowDuplicates && currentTags.includes(suggestion)) return false;\n        // Filter by input match\n        return lowerSuggestion.includes(lowerInput);\n      })\n      .slice(0, 10); // Limit to 10 suggestions\n  }, [allowDuplicates]);\n\n  // Filter suggestions based on input and existing tags\n  const filteredSuggestions = useMemo(() => {\n    return computeFilteredSuggestions(inputValue, allSuggestions, value);\n  }, [inputValue, allSuggestions, value, computeFilteredSuggestions]);\n\n  // Precompute delimiter regex for paste handling (support multi-character tokens)\n  const delimiterRegex = useMemo<RegExp | null>(() => {\n    const tokens = delimiters\n      .filter(d => d !== 'Enter') // Enter is not in paste text\n      .map(d => (d === 'Tab' ? '\\t' : d))\n      .map(d => d.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'));\n    if (tokens.length === 0) {\n      return null;\n    }\n    return new RegExp(`(?:${tokens.join('|')})`);\n  }, [delimiters]);\n\n  // Load async suggestions\n  useEffect(() => {\n    if (!asyncSuggestions || !inputValue.trim() || isComposing) {\n      setAsyncSuggestionsList([]);\n      return;\n    }\n\n    const timeoutId = setTimeout(async () => {\n      setIsLoadingSuggestions(true);\n      try {\n        const results = await asyncSuggestions(inputValue);\n        setAsyncSuggestionsList(results || []);\n      } catch (error) {\n        console.error('Error loading suggestions:', error);\n        setAsyncSuggestionsList([]);\n      } finally {\n        setIsLoadingSuggestions(false);\n      }\n    }, 300); // Debounce 300ms\n\n    return () => clearTimeout(timeoutId);\n  }, [inputValue, asyncSuggestions, isComposing]);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        containerRef.current &&\n        !containerRef.current.contains(event.target as Node)\n      ) {\n        setIsDropdownOpen(false);\n        setFocusedSuggestionIndex(-1);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  // Announce tag changes to screen readers\n  const announceTagChange = useCallback((message: string) => {\n    if (liveRegionRef.current) {\n      liveRegionRef.current.textContent = message;\n      // Clear after announcement\n      setTimeout(() => {\n        if (liveRegionRef.current) {\n          liveRegionRef.current.textContent = '';\n        }\n      }, 1000);\n    }\n  }, []);\n\n  const normalizeTagValue = useCallback((tag: string): string => {\n    let normalized = tag.trim();\n    if (normalizeTag) {\n      normalized = normalizeTag(normalized);\n    }\n    return normalized;\n  }, [normalizeTag]);\n\n  const validateTag = useCallback((tag: string): { valid: boolean; error?: string } => {\n    if (!tag) {\n      return { valid: false };\n    }\n\n    if (maxTagLength && tag.length > maxTagLength) {\n      return { valid: false, error: `Tag must be ${maxTagLength} characters or less` };\n    }\n\n    if (onValidate) {\n      const result = onValidate(tag);\n      if (result === false) {\n        return { valid: false, error: 'Invalid tag' };\n      }\n      if (typeof result === 'string') {\n        return { valid: false, error: result };\n      }\n    }\n\n    return { valid: true };\n  }, [maxTagLength, onValidate]);\n\n  const addTag = useCallback((tag: string) => {\n    const normalized = normalizeTagValue(tag);\n    if (!normalized) return;\n\n    // Check max tags\n    if (maxTags && value.length >= maxTags) {\n      announceTagChange(`Maximum of ${maxTags} tags reached`);\n      return;\n    }\n\n    // Check duplicates\n    if (!allowDuplicates && value.includes(normalized)) {\n      announceTagChange(`${normalized} is already added`);\n      return;\n    }\n\n    // Validate tag\n    const validation = validateTag(normalized);\n    if (!validation.valid) {\n      if (validation.error) {\n        announceTagChange(validation.error);\n      }\n      return;\n    }\n\n    onChange([...value, normalized]);\n    announceTagChange(`Added ${normalized}`);\n    setInputValue('');\n    setIsDropdownOpen(false);\n    setFocusedSuggestionIndex(-1);\n  }, [value, onChange, maxTags, allowDuplicates, normalizeTagValue, validateTag, announceTagChange]);\n\n  const removeTag = useCallback((index: number) => {\n    const removedTag = value[index];\n    onChange(value.filter((_, i) => i !== index));\n    announceTagChange(`Removed ${removedTag}`);\n    // Refocus input after removal\n    setTimeout(() => inputRef.current?.focus(), 0);\n  }, [value, onChange, announceTagChange]);\n\n  const handleInputChange = (newValue: string) => {\n    setInputValue(newValue);\n    \n    // Compute filtered suggestions synchronously from newValue\n    const computedFiltered = computeFilteredSuggestions(newValue, allSuggestions, value);\n    const hasSuggestions = computedFiltered.length > 0 || isLoadingSuggestions;\n    setIsDropdownOpen(newValue.trim().length > 0 && hasSuggestions);\n    setFocusedSuggestionIndex(-1);\n  };\n\n  const handlePaste = useCallback((e: ClipboardEvent) => {\n    const pastedText = e.clipboardData?.getData('text') || '';\n    if (!pastedText) return;\n\n    // If any configured delimiter is present, handle splitting\n    if (delimiterRegex?.test(pastedText)) {\n      e.preventDefault();\n      \n      // Split using precomputed regex\n      const rawTags = pastedText\n        .split(delimiterRegex)\n        .map(tag => normalizeTagValue(tag))\n        .filter(tag => tag.length > 0);\n\n      // Snapshot current value to avoid stale closure\n      const currentValueSnapshot = [...value];\n      \n      // Collect all valid tags from pasted text\n      const newTags: string[] = [];\n      \n      for (const tag of rawTags) {\n        // Check max tags limit\n        if (maxTags && currentValueSnapshot.length + newTags.length >= maxTags) break;\n        \n        // Skip duplicates if not allowed\n        if (!allowDuplicates && (currentValueSnapshot.includes(tag) || newTags.includes(tag))) continue;\n        \n        // Validate tag\n        const validation = validateTag(tag);\n        if (validation.valid) {\n          newTags.push(tag);\n        }\n      }\n\n      // Call onChange once with merged array\n      if (newTags.length > 0) {\n        onChange([...currentValueSnapshot, ...newTags]);\n        announceTagChange(`Added ${newTags.length} tag${newTags.length !== 1 ? 's' : ''}`);\n      }\n\n      setInputValue('');\n    }\n  }, [delimiterRegex, normalizeTagValue, value, onChange, maxTags, allowDuplicates, validateTag, announceTagChange]);\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if (disabled || isComposing) return;\n\n    // Handle dropdown navigation\n    if (isDropdownOpen && filteredSuggestions.length > 0) {\n      switch (e.key) {\n        case 'ArrowDown':\n          e.preventDefault();\n          setFocusedSuggestionIndex(prev =>\n            prev < filteredSuggestions.length - 1 ? prev + 1 : 0\n          );\n          return;\n        case 'ArrowUp':\n          e.preventDefault();\n          setFocusedSuggestionIndex(prev =>\n            prev > 0 ? prev - 1 : filteredSuggestions.length - 1\n          );\n          return;\n        case 'Enter':\n          e.preventDefault();\n          if (focusedSuggestionIndex >= 0) {\n            addTag(filteredSuggestions[focusedSuggestionIndex]);\n          } else if (inputValue.trim()) {\n            addTag(inputValue);\n          }\n          return;\n        case 'Escape':\n          e.preventDefault();\n          setIsDropdownOpen(false);\n          setFocusedSuggestionIndex(-1);\n          return;\n      }\n    }\n\n    // Handle tag removal with Backspace\n    if (e.key === 'Backspace' && !inputValue && value.length > 0) {\n      removeTag(value.length - 1);\n      return;\n    }\n\n    // Handle Enter to add tag\n    if (e.key === 'Enter' && inputValue.trim() && !isDropdownOpen) {\n      e.preventDefault();\n      addTag(inputValue);\n      return;\n    }\n\n    // Handle comma as delimiter\n    if (e.key === ',' && delimiters.includes(',') && inputValue.trim()) {\n      e.preventDefault();\n      addTag(inputValue);\n      return;\n    }\n\n    // Handle other delimiters (except Enter which is handled above)\n    if (delimiters.includes(e.key) && e.key !== 'Enter' && inputValue.trim()) {\n      e.preventDefault();\n      addTag(inputValue);\n      return;\n    }\n  };\n\n  const descriptionId = displayDescription ? `${inputId}-description` : undefined;\n  const errorId = displayError ? `${inputId}-error` : undefined;\n  const computedAriaDescribedBy = [\n    descriptionId,\n    errorId\n  ].filter(Boolean).join(' ') || undefined;\n\n  const listboxId = `${inputId}-suggestions`;\n\n  // Match Input size classes exactly\n  const sizeClasses = {\n    sm: 'px-2 py-1 text-sm',\n    md: 'px-3 py-2 text-sm',\n    lg: 'px-4 py-3 text-base'\n  };\n\n  // Container padding matches Input\n  const containerPaddingClasses = {\n    sm: 'px-2 py-1 min-h-[2rem] gap-1.5',\n    md: 'px-3 py-2 min-h-[2.5rem] gap-2',\n    lg: 'px-4 py-3 min-h-[3rem] gap-2'\n  };\n\n  const variantClasses = {\n    default: 'border-input-border focus-within:ring-accent-500 focus-within:border-accent-500',\n    error: 'border-red-500 dark:border-red-400 focus-within:ring-red-500 focus-within:border-red-500',\n    success: 'border-green-500 dark:border-green-400 focus-within:ring-green-500 focus-within:border-green-400'\n  };\n\n  return (\n    <div className={cn('w-full', className)} ref={containerRef}>\n      {displayLabel && (\n        <label htmlFor={inputId} className=\"block text-sm font-medium text-input-text mb-1\">\n          {displayLabel}\n        </label>\n      )}\n\n      <div className=\"relative\">\n        {/* Tags container with input */}\n        <div\n          className={cn(\n            'flex flex-wrap items-center w-full border rounded-lg',\n            'bg-input-bg text-input-text',\n            'focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-0 transition-colors',\n            containerPaddingClasses[size],\n            variantClasses[variant],\n            disabled && 'opacity-50 cursor-not-allowed'\n          )}\n        >\n          {/* Existing tags */}\n          {value.map((tag, index) => (\n            <Tag\n              key={`${tag}-${index}`}\n              size={size}\n              onRemove={() => removeTag(index)}\n              disabled={disabled}\n            >\n              {tag}\n            </Tag>\n          ))}\n\n          {/* Input field */}\n          <input\n            ref={(node) => {\n              if (typeof ref === 'function') ref(node);\n              else if (ref) ref.current = node;\n              inputRef.current = node;\n            }}\n            type=\"text\"\n            value={inputValue}\n            onChange={(e) => handleInputChange((e.target as HTMLInputElement).value)}\n            onKeyDown={handleKeyDown}\n            onPaste={handlePaste}\n            onCompositionStart={() => setIsComposing(true)}\n            onCompositionEnd={() => setIsComposing(false)}\n            onFocus={() => {\n              const computedFiltered = computeFilteredSuggestions(inputValue, allSuggestions, value);\n              if (inputValue.trim() && (computedFiltered.length > 0 || isLoadingSuggestions)) {\n                setIsDropdownOpen(true);\n              }\n            }}\n            placeholder={value.length === 0 ? displayPlaceholder : ''}\n            disabled={disabled}\n            className={cn(\n              'flex-1 min-w-[120px] border-0 bg-transparent outline-none',\n              sizeClasses[size],\n              'text-input-text',\n              'placeholder:text-input-placeholder',\n              disabled && 'cursor-not-allowed'\n            )}\n            id={inputId}\n            role=\"combobox\"\n            aria-expanded={isDropdownOpen}\n            aria-controls={isDropdownOpen ? listboxId : undefined}\n            aria-haspopup=\"listbox\"\n            aria-label={ariaLabel || displayLabel || 'Tag input'}\n            aria-describedby={computedAriaDescribedBy}\n            aria-autocomplete=\"list\"\n            aria-activedescendant={\n              focusedSuggestionIndex >= 0\n                ? `${inputId}-suggestion-${focusedSuggestionIndex}`\n                : undefined\n            }\n            data-testid={dataTestId}\n            {...restProps}\n          />\n        </div>\n\n        {/* Suggestions dropdown */}\n        {isDropdownOpen && (filteredSuggestions.length > 0 || isLoadingSuggestions) && (\n          <div\n            ref={dropdownRef}\n            id={listboxId}\n            role=\"listbox\"\n            className={cn(\n              'absolute z-50 w-full mt-1 bg-surface-glass/80 backdrop-blur-xl',\n              'border border-line-glass/30 rounded-lg shadow-glass',\n              'max-h-60 overflow-y-auto'\n            )}\n          >\n            {isLoadingSuggestions && (\n              <div className=\"px-3 py-2 text-sm text-input-placeholder\">\n                Loading suggestions...\n              </div>\n            )}\n            {!isLoadingSuggestions && filteredSuggestions.length === 0 && inputValue.trim() && (\n              <div className=\"px-3 py-2 text-sm text-input-placeholder\">\n                No suggestions found\n              </div>\n            )}\n            {filteredSuggestions.map((suggestion, index) => (\n              <button\n                key={suggestion}\n                type=\"button\"\n                id={`${inputId}-suggestion-${index}`}\n                role=\"option\"\n                aria-selected={focusedSuggestionIndex === index}\n                onClick={() => addTag(suggestion)}\n                className={cn(\n                  'w-full text-left px-3 py-2 text-sm text-input-text',\n                  'hover:bg-surface-glass/50',\n                  'focus:outline-none focus:bg-surface-glass/50',\n                  focusedSuggestionIndex === index && 'bg-accent-50 dark:bg-accent-900/20'\n                )}\n              >\n                {suggestion}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Live region for screen reader announcements */}\n      <div\n        ref={liveRegionRef}\n        className=\"sr-only\"\n        role=\"status\"\n        aria-live=\"polite\"\n        aria-atomic=\"true\"\n      />\n\n      {displayError && (\n        <p id={errorId} className=\"text-xs text-red-600 dark:text-red-400 mt-1\" role=\"alert\" aria-live=\"assertive\">\n          {displayError}\n        </p>\n      )}\n\n      {displayDescription && !displayError && (\n        <p id={descriptionId} className=\"mt-1 text-xs text-input-placeholder\">\n          {displayDescription}\n        </p>\n      )}\n    </div>\n  );\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/tag/atoms/Tag.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/tag/atoms/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/tag/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/upload/atoms/FileIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/upload/atoms/ProgressRing.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":28,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":28,"endColumn":17,"suggestions":[{"fix":{"range":[706,819],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ProgressRing - Atom Component\n * \n * Pure circular progress indicator. No file-specific logic.\n * Just renders a progress ring with given percentage.\n */\n\nimport { cn } from '@/shared/utils/cn';\n\ninterface ProgressRingProps {\n  progress: number; // 0-100\n  size?: 'sm' | 'md' | 'lg';\n  className?: string;\n  'aria-label'?: string;\n}\n\nexport const ProgressRing = ({ \n  progress, \n  size = 'md',\n  className,\n  'aria-label': ariaLabel\n}: ProgressRingProps) => {\n  // Clamp progress to 0-100 range\n  const clampedProgress = Math.min(100, Math.max(0, progress));\n  \n  // Development warning for out-of-range values\n  if (process.env.NODE_ENV === 'development' && (progress < 0 || progress > 100)) {\n    console.warn(`ProgressRing: progress value ${progress} is out of range (0-100). Clamped to ${clampedProgress}.`);\n  }\n  \n  const sizeClasses = {\n    sm: 'w-6 h-6',\n    md: 'w-8 h-8',\n    lg: 'w-10 h-10'\n  };\n  \n  const radius = size === 'sm' ? 10 : size === 'md' ? 14 : 18;\n  const circumference = 2 * Math.PI * radius;\n  const strokeDasharray = `${(clampedProgress / 100) * circumference} ${circumference}`;\n\n  return (\n    <div className={cn('absolute inset-0 flex items-center justify-center', className)}>\n      <svg \n        className={cn(\n          '-rotate-90',\n          sizeClasses[size]\n        )} \n        viewBox={`0 0 ${radius * 2 + 4} ${radius * 2 + 4}`}\n        role=\"img\"\n        aria-label={ariaLabel}\n      >\n      {/* Background circle */}\n      <circle\n        cx={radius + 2}\n        cy={radius + 2}\n        r={radius}\n        stroke=\"currentColor\"\n        strokeWidth=\"2\"\n        fill=\"none\"\n        className=\"text-light-file-progress-bg dark:text-dark-file-progress-bg\"\n      />\n      {/* Progress circle */}\n      <circle\n        cx={radius + 2}\n        cy={radius + 2}\n        r={radius}\n        stroke=\"currentColor\"\n        strokeWidth=\"2\"\n        fill=\"none\"\n        strokeLinecap=\"round\"\n        className=\"text-light-file-progress-fill dark:text-dark-file-progress-fill transition-all duration-300\"\n        strokeDasharray={strokeDasharray}\n      />\n      </svg>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/upload/atoms/RemoveButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/upload/atoms/StatusOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/upload/molecules/FileCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/upload/molecules/FileIconWithStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/upload/molecules/FileInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/upload/molecules/FileUploadStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/upload/organisms/FileDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/validation/defaultValues.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/validation/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/validation/schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/validation/schemas/address.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/ui/validation/useFormValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/__tests__/deepEqual.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/__tests__/errorHandler.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/accentColors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/addressFormat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/addressValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/auth.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":41,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":41,"endColumn":21,"suggestions":[{"fix":{"range":[1252,1326],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":68,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":68,"endColumn":18,"suggestions":[{"fix":{"range":[1938,1981],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { signOut as betterAuthSignOut } from '@/shared/lib/authClient';\n\n/**\n * Centralized sign out utility that handles:\n * 1. Better Auth sign out (revokes session)\n * 2. Remove auth-related localStorage hints (without touching unrelated app data)\n * 3. Optional callback for custom behavior\n */\nexport async function signOut(options?: {\n  skipReload?: boolean;\n  onSuccess?: () => void;\n  navigate?: (path: string, replace?: boolean) => void;\n  fetchOptions?: {\n    onSuccess?: () => void;\n  };\n}): Promise<void> {\n  try {\n    const handleSuccess = () => {\n      // Remove other auth-related localStorage (non-token data)\n      try {\n        const authKeys = [\n          'onboardingCompleted',\n          'onboardingCheckDone',\n          'businessSetupPending',\n          'cartPreferences',\n          'cartData',\n        ];\n\n        for (const key of authKeys) {\n          localStorage.removeItem(key);\n        }\n\n        // Clean any Better Auth specific markers\n        const betterAuthKeys = Object.keys(localStorage).filter((key) =>\n          key.startsWith('better-auth') || key.startsWith('__better-auth')\n        );\n        for (const key of betterAuthKeys) {\n          localStorage.removeItem(key);\n        }\n      } catch (error) {\n        console.warn('Failed to clear auth-related localStorage entries:', error);\n      }\n\n      if (options?.onSuccess) {\n        options.onSuccess();\n      }\n\n      if (!options?.skipReload) {\n        if (options?.navigate) {\n          options.navigate('/auth', true);\n        } else if (typeof window !== 'undefined') {\n          window.location.href = '/auth';\n        }\n      }\n    };\n\n    // Sign out from Better Auth (uses Better Auth method only)\n    await betterAuthSignOut({\n      fetchOptions: {\n        ...options?.fetchOptions,\n        onSuccess: () => {\n          options?.fetchOptions?.onSuccess?.();\n          handleSuccess();\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Error signing out:', error);\n    throw error;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/cn.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/conversationalForm.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/currencyFormatter.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":18,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":18,"endColumn":17,"suggestions":[{"fix":{"range":[552,622],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":48,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":48,"endColumn":17,"suggestions":[{"fix":{"range":[1462,1600],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":86,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":86,"endColumn":17,"suggestions":[{"fix":{"range":[2657,2776],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":106,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":106,"endColumn":17,"suggestions":[{"fix":{"range":[3285,3353],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Currency Formatter Utility\n// Locale-aware currency formatting for pricing displays\n\n/**\n * Validates and sanitizes a currency code\n * @param currency - The currency code to validate\n * @returns Valid currency code or 'USD' as fallback\n */\nfunction sanitizeCurrency(currency: string | null | undefined): string {\n  if (!currency || typeof currency !== 'string') {\n    return 'USD';\n  }\n  \n  const sanitized = currency.toUpperCase().trim();\n  \n  // Must be exactly 3 alphabetic characters (ISO 4217 format)\n  if (!/^[A-Z]{3}$/.test(sanitized)) {\n    console.warn(`Invalid currency code: ${currency}, defaulting to USD`);\n    return 'USD';\n  }\n  \n  return sanitized;\n}\n\n/**\n * Format a price amount using Intl.NumberFormat for locale-aware currency display\n * @param amount - The numeric amount to format\n * @param currency - The ISO currency code (e.g., 'USD', 'EUR', 'GBP')\n * @param locale - The locale code (e.g., 'en', 'es', 'fr', 'de')\n * @returns Formatted currency string\n */\nexport function formatCurrency(\n  amount: number,\n  currency: string = \"USD\",\n  locale: string = \"en\"\n): string {\n  const sanitizedCurrency = sanitizeCurrency(currency);\n  \n  try {\n    return new Intl.NumberFormat(locale, {\n      style: \"currency\",\n      currency: sanitizedCurrency,\n      minimumFractionDigits: amount % 1 === 0 ? 0 : 2,\n      maximumFractionDigits: 2,\n    }).format(amount);\n  } catch (error) {\n    // Fallback to en-US with requested currency preserved\n    console.warn(\n      `Currency formatting failed for locale ${locale}, falling back to en-US with ${sanitizedCurrency}`,\n      error\n    );\n    return new Intl.NumberFormat(\"en-US\", {\n      style: \"currency\",\n      currency: sanitizedCurrency,\n      minimumFractionDigits: amount % 1 === 0 ? 0 : 2,\n      maximumFractionDigits: 2,\n    }).format(amount);\n  }\n}\n\n/**\n * Get the currency symbol for a given currency code in a specific locale\n * @param currency - The ISO currency code (e.g., 'USD', 'EUR', 'GBP')\n * @param locale - The locale code (e.g., 'en', 'es', 'fr', 'de')\n * @returns Currency symbol string\n */\nexport function getCurrencySymbol(\n  currency: string = \"USD\",\n  locale: string = \"en\"\n): string {\n  const sanitizedCurrency = sanitizeCurrency(currency);\n  \n  try {\n    const formatter = new Intl.NumberFormat(locale, {\n      style: \"currency\",\n      currency: sanitizedCurrency,\n      minimumFractionDigits: 0,\n      maximumFractionDigits: 0,\n    });\n\n    // Extract symbol using formatToParts\n    const parts = formatter.formatToParts(0);\n    const symbolPart = parts.find((p) => p.type === \"currency\");\n    return symbolPart?.value ?? sanitizedCurrency;\n  } catch (error) {\n    console.warn(\n      `Currency symbol retrieval failed for ${sanitizedCurrency} in locale ${locale}`,\n      error\n    );\n    return sanitizedCurrency;\n  }\n}\n/**\n * Format price for display without currency symbol\n * @param amount - The numeric amount to format\n * @param locale - The locale code (e.g., 'en', 'es', 'fr', 'de')\n * @returns Formatted number string\n */\nexport function formatPrice(amount: number, locale: string = \"en\"): string {\n  try {\n    return new Intl.NumberFormat(locale, {\n      minimumFractionDigits: amount % 1 === 0 ? 0 : 2,\n      maximumFractionDigits: 2,\n    }).format(amount);\n  } catch (error) {\n    console.warn(`Price formatting failed for locale ${locale}`, error);\n    return amount.toFixed(amount % 1 === 0 ? 0 : 2);\n  }\n}\n\n/**\n * Build a complete price display string with currency and billing period\n * @param amount - The numeric amount\n * @param currency - The ISO currency code\n * @param billingPeriod - Translation key for billing period (e.g., 'monthly', 'yearly')\n * @param locale - The locale code\n * @param t - Translation function from i18next\n * @returns Formatted price string like \"$20 USD / month\"\n */\nexport function buildPriceDisplay(\n  amount: number,\n  currency: string,\n  billingPeriod: \"month\" | \"year\",\n  locale: string,\n  t: (key: string) => string\n): string {\n  const sanitizedCurrency = sanitizeCurrency(currency);\n  const formattedAmount = formatCurrency(amount, sanitizedCurrency, locale);\n  const period = t(\n    `pricing:billing.${billingPeriod === \"month\" ? \"monthly\" : \"yearly\"}`\n  );\n\n  return `${formattedAmount} / ${period}`;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/dateFormatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/dateOnly.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/dateTime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/debounce.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/deepEqual.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/devFlags.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":25,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":25,"endColumn":19,"suggestions":[{"fix":{"range":[650,718],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Determines whether the client should force paid state in development/test environments.\n * Consolidates logic shared between cart and onboarding flows.\n */\nexport function isForcePaidEnabled(): boolean {\n  if (import.meta.env.MODE === 'production') {\n    return false;\n  }\n\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  try {\n    const params = new URLSearchParams(window.location.search);\n    if (params.get('forcePaid') === '1') {\n      return true;\n    }\n\n    if (typeof localStorage !== 'undefined') {\n      return localStorage.getItem('forcePaid') === '1';\n    }\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.warn('[devFlags] Failed to resolve forcePaid flag:', error);\n    }\n  }\n\n  return false;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/environment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/errorHandler.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":155,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":155,"endColumn":21,"suggestions":[{"fix":{"range":[5006,5073],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":162,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":162,"endColumn":18,"suggestions":[{"fix":{"range":[5217,5405],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":169,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":169,"endColumn":18,"suggestions":[{"fix":{"range":[5538,5663],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":222,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":222,"endColumn":19,"suggestions":[{"fix":{"range":[6848,6893],"text":""},"messageId":"removeMethodCall","desc":"Remove the console method call."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Production-safe error handling utilities for frontend components\n * Sanitizes errors to prevent exposure of sensitive information\n */\n\nimport { isProduction } from './environment';\n\ninterface ErrorContext {\n  component?: string;\n  action?: string;\n  userId?: string;\n  sessionId?: string;\n  [key: string]: unknown;\n}\n\ninterface SanitizedError {\n  message: string;\n  name: string;\n  timestamp: string;\n  context: ErrorContext;\n  isProduction: boolean;\n}\n\n/**\n * Sanitizes error data to remove sensitive information\n */\nfunction sanitizeError(error: unknown, context: ErrorContext = {}, visited: WeakSet<object> = new WeakSet()): SanitizedError {\n  const isProd = isProduction();\n  \n  // Extract safe error information\n  let message = 'An unexpected error occurred';\n  let name = 'Error';\n  \n  if (error instanceof Error) {\n    message = error.message || message;\n    name = error.name || name;\n  } else if (typeof error === 'string') {\n    message = error;\n  } else if (error && typeof error === 'object') {\n    message = (error as { message?: string }).message || message;\n    name = (error as { name?: string }).name || name;\n  }\n\n  // Sanitize context to remove PII and sensitive data\n  const sanitizedContext: ErrorContext = {};\n  for (const [key, value] of Object.entries(context)) {\n    if (typeof value === 'string') {\n      // Allow componentStack in development for debugging\n      if (key === 'componentStack' && !isProd) {\n        sanitizedContext[key] = value;\n      } else if (key.toLowerCase().includes('token') || \n          key.toLowerCase().includes('password') || \n          key.toLowerCase().includes('secret') ||\n          key.toLowerCase().includes('key') ||\n          value.includes('@') ||\n          value.startsWith('http')) {\n        sanitizedContext[key] = '[REDACTED]';\n      } else {\n        sanitizedContext[key] = value;\n      }\n    } else if (typeof value === 'number' || typeof value === 'boolean') {\n      sanitizedContext[key] = value;\n    } else if (value && typeof value === 'object') {\n      // Check for circular references\n      if (visited.has(value)) {\n        sanitizedContext[key] = '[Circular]';\n        continue;\n      }\n      \n      // Add to visited set before recursing\n      visited.add(value);\n      \n      try {\n        if (Array.isArray(value)) {\n          // Preserve array structure by mapping each element\n          sanitizedContext[key] = value.map(item => {\n            if (item && typeof item === 'object') {\n              if (visited.has(item)) {\n                return '[Circular]';\n              }\n              visited.add(item);\n              try {\n                const result = sanitizeError(error, item, visited).context;\n                return result;\n              } finally {\n                visited.delete(item);\n              }\n            }\n            return item;\n          });\n        } else {\n          // Recursively sanitize nested objects\n          sanitizedContext[key] = sanitizeError(error, value as Record<string, unknown>, visited).context;\n        }\n      } finally {\n        // Remove from visited set after processing\n        visited.delete(value);\n      }\n    }\n  }\n\n  return {\n    message,\n    name,\n    timestamp: new Date().toISOString(),\n    context: sanitizedContext,\n    isProduction: isProd\n  };\n}\n\n/**\n * Checks if Sentry is available for error tracking\n */\nfunction isSentryAvailable(): boolean {\n  return typeof window !== 'undefined' && \n         typeof (window as { Sentry?: { captureException?: (error: unknown, context?: { tags?: Record<string, string>; extra?: Record<string, unknown> }) => void } }).Sentry !== 'undefined' &&\n         typeof (window as { Sentry?: { captureException?: (error: unknown, context?: { tags?: Record<string, string>; extra?: Record<string, unknown> }) => void } }).Sentry?.captureException === 'function';\n}\n\n/**\n * Production-safe error handler that:\n * 1. Captures errors in Sentry if available\n * 2. Logs sanitized errors to console in development\n * 3. Logs minimal information in production\n * 4. Never exposes stack traces or sensitive data\n */\nexport function handleError(\n  error: unknown, \n  context: ErrorContext = {},\n  options: {\n    component?: string;\n    action?: string;\n    silent?: boolean;\n  } = {}\n): void {\n  const sanitized = sanitizeError(error, {\n    ...context,\n    component: options.component,\n    action: options.action\n  });\n\n  // Always try to capture in Sentry if available\n  if (isSentryAvailable()) {\n    try {\n      (window as { Sentry?: { captureException?: (error: unknown, context?: { tags?: Record<string, string>; extra?: Record<string, unknown> }) => void } }).Sentry?.captureException?.(error, {\n        tags: {\n          component: options.component,\n          action: options.action\n        },\n        extra: sanitized.context\n      });\n    } catch (sentryError) {\n      // If Sentry fails, fall back to console logging only if not in production and not silent\n      if (!sanitized.isProduction && !options.silent) {\n        console.warn('[ErrorHandler] Sentry capture failed:', sentryError);\n      }\n    }\n  }\n\n  // Only log to console in development or if explicitly not silent\n  if (!sanitized.isProduction && !options.silent) {\n    console.error(`[${options.component || 'ErrorHandler'}] ${sanitized.message}`, {\n      error: sanitized.name,\n      context: sanitized.context,\n      timestamp: sanitized.timestamp\n    });\n  } else if (!options.silent) {\n    // In production, log minimal information without context to prevent sensitive data leakage\n    console.error(`[${options.component || 'ErrorHandler'}] ${sanitized.message}`, {\n      timestamp: sanitized.timestamp\n    });\n  }\n}\n\n/**\n * Async error handler for promise rejections and async operations\n */\nexport async function handleAsyncError<T>(\n  operation: () => Promise<T>,\n  context: ErrorContext = {},\n  options: {\n    component?: string;\n    action?: string;\n    fallback?: T;\n    silent?: boolean;\n  } = {}\n): Promise<T | undefined> {\n  try {\n    return await operation();\n  } catch (error) {\n    handleError(error, context, options);\n    return options.fallback;\n  }\n}\n\n/**\n * Error boundary helper for React components\n */\nexport function createErrorBoundaryHandler(componentName: string) {\n  return (error: Error, errorInfo: { componentStack: string }) => {\n    handleError(error, {\n      component: componentName,\n      action: 'error-boundary',\n      componentStack: errorInfo.componentStack\n    });\n  };\n}\n\n/**\n * Safe console logging that respects production environment\n */\nexport function safeLog(\n  level: 'log' | 'warn' | 'error' | 'info',\n  message: string,\n  data?: unknown,\n  options: { component?: string; force?: boolean } = {}\n): void {\n  const isProd = isProduction();\n  \n  if (!isProd || options.force) {\n    const prefix = options.component ? `[${options.component}]` : '';\n    console[level](`${prefix} ${message}`, data);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/fetchPlans.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/fileTypeUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/forms.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":216,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":216,"endColumn":21,"suggestions":[{"fix":{"range":[6294,6362],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":219,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":219,"endColumn":22,"suggestions":[{"fix":{"range":[6416,6501],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":236,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":236,"endColumn":21,"suggestions":[{"fix":{"range":[7091,7164],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":238,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":238,"endColumn":22,"suggestions":[{"fix":{"range":[7188,7278],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":247,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":247,"endColumn":21,"suggestions":[{"fix":{"range":[7538,7609],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":249,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":249,"endColumn":22,"suggestions":[{"fix":{"range":[7633,7906],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":266,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":266,"endColumn":19,"suggestions":[{"fix":{"range":[8267,8331],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":268,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":268,"endColumn":20,"suggestions":[{"fix":{"range":[8351,8465],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":293,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":293,"endColumn":17,"suggestions":[{"fix":{"range":[9000,9064],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":337,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":337,"endColumn":19,"suggestions":[{"fix":{"range":[10668,10831],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":355,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":355,"endColumn":23,"suggestions":[{"fix":{"range":[11415,11501],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":377,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":377,"endColumn":19,"suggestions":[{"fix":{"range":[12180,12247],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":406,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":406,"endColumn":18,"suggestions":[{"fix":{"range":[13393,13484],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":422,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":422,"endColumn":18,"suggestions":[{"fix":{"range":[13958,14010],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":450,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":450,"endColumn":25,"suggestions":[{"fix":{"range":[15268,15342],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":474,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":474,"endColumn":20,"suggestions":[{"fix":{"range":[16207,16370],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":491,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":491,"endColumn":18,"suggestions":[{"fix":{"range":[16840,16887],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  getPracticeClientIntakeCreateEndpoint,\n  getPracticeClientIntakeCheckoutSessionEndpoint,\n  getPracticeClientIntakeSettingsEndpoint\n} from '@/config/api';\nimport { asMinor, assertMinorUnits, toMinorUnitsValue, type MinorAmount } from '@/shared/utils/money';\nimport { getPublicPracticeDetails } from '@/shared/lib/apiClient';\n\nconst getTrimmedString = (value: unknown): string | undefined => {\n  if (typeof value !== 'string') return undefined;\n  const trimmed = value.trim();\n  return trimmed.length > 0 ? trimmed : undefined;\n};\n\n// Utility function to format form data for submission\nexport function formatFormData(formData: Record<string, unknown>, practiceSlug: string) {\n  const name = getTrimmedString(formData.name);\n  const email = getTrimmedString(formData.email);\n  if (!name || !email) {\n    throw new Error('Name and email are required fields');\n  }\n  const phone = getTrimmedString(formData.phoneNumber) ?? getTrimmedString(formData.phone);\n  const description =\n    getTrimmedString(formData.matterDetails) ??\n    getTrimmedString(formData.matterDescription) ??\n    getTrimmedString(formData.description);\n  const opposingParty = getTrimmedString(formData.opposingParty);\n\n  // Handle address field if present\n  const address = formData.address as {\n    address?: string;\n    apartment?: string;\n    city?: string;\n    state?: string;\n    postalCode?: string;\n    country?: string;\n  } | undefined;\n  let addressPayload: {\n    line1: string;\n    line2?: string;\n    city: string;\n    state?: string;\n    postal_code: string;\n    country: string;\n  } | undefined = undefined;\n  \n  if (address) {\n    const trimmedAddress = {\n      address: address.address?.trim(),\n      apartment: address.apartment?.trim(),\n      city: address.city?.trim(),\n      state: address.state?.trim(),\n      postalCode: address.postalCode?.trim(),\n      country: address.country?.trim()\n    };\n\n    const hasRequiredFields = [\n      trimmedAddress.address,\n      trimmedAddress.city,\n      trimmedAddress.country,\n      trimmedAddress.postalCode\n    ].every(field => field && field.length > 0);\n    \n    if (hasRequiredFields) {\n      addressPayload = {\n        line1: trimmedAddress.address,\n        line2: trimmedAddress.apartment,\n        city: trimmedAddress.city,\n        state: trimmedAddress.state,\n        postal_code: trimmedAddress.postalCode,\n        country: trimmedAddress.country\n      };\n    }\n  }\n\n  return {\n    slug: practiceSlug,\n    name,\n    email,\n    ...(phone ? { phone } : {}),\n    ...(description ? { description } : {}),\n    ...(opposingParty ? { opposing_party: opposingParty } : {}),\n    ...(addressPayload ? { address: addressPayload } : {}),\n  };\n}\n\ntype IntakeSettingsResponse = {\n  success?: boolean;\n  data?: {\n    organization?: {\n      name?: string;\n      logo?: string;\n    };\n    settings?: {\n      paymentLinkEnabled?: boolean;\n      payment_link_enabled?: boolean;\n      prefillAmount?: number;\n      prefill_amount?: number;\n    };\n  };\n  error?: string;\n};\n\ntype IntakeCreateResponse = {\n  success?: boolean;\n  data?: {\n    uuid?: string;\n    client_secret?: string;\n    payment_link_url?: string;\n    paymentLinkUrl?: string;\n    amount?: MinorAmount;\n    currency?: string;\n    status?: string;\n    organization?: {\n      name?: string;\n      logo?: string;\n    };\n  };\n  error?: string;\n};\n\ntype CheckoutSessionResponse = {\n  success?: boolean;\n  data?: {\n    url?: string;\n    session_id?: string;\n  };\n  error?: string;\n};\n\nexport type IntakeSubmissionResult = IntakeCreateResponse & {\n  intake?: {\n    uuid?: string;\n    clientSecret?: string;\n    paymentLinkUrl?: string;\n    checkoutSessionUrl?: string;\n    checkoutSessionId?: string;\n    amount?: MinorAmount;\n    currency?: string;\n    paymentLinkEnabled: boolean;\n    organizationName?: string;\n    organizationLogo?: string;\n  };\n};\n\n// Amounts are stored as integer cents (minor units).\nconst clampAmount = (amount: number): MinorAmount => {\n  const min = 50;\n  const max = 99999999;\n  if (Number.isNaN(amount)) return asMinor(min);\n  return asMinor(Math.min(max, Math.max(min, Math.round(amount))));\n};\n\nconst formatDescription = (description?: string) => {\n  return description?.trim() || undefined;\n};\n\ntype LoggedError = Error & { _logged?: boolean };\n\nconst sanitizeErrorBody = (raw: string): string => {\n  if (!raw) return raw;\n  const maxLength = 600;\n  const redactKey = (key: string) => /token|secret|password|ssn|email|phone|address|name|clientsecret/i.test(key);\n  const redactValue = (value: unknown): unknown => {\n    if (typeof value === 'string') {\n      return 'REDACTED';\n    }\n    return 'REDACTED';\n  };\n  const sanitizeObject = (input: unknown, depth: number): unknown => {\n    if (depth <= 0) return '[Truncated]';\n    if (Array.isArray(input)) {\n      return input.slice(0, 10).map((item) => sanitizeObject(item, depth - 1));\n    }\n    if (input && typeof input === 'object') {\n      const record = input as Record<string, unknown>;\n      const output: Record<string, unknown> = {};\n      Object.keys(record).slice(0, 50).forEach((key) => {\n        output[key] = redactKey(key)\n          ? redactValue(record[key])\n          : sanitizeObject(record[key], depth - 1);\n      });\n      return output;\n    }\n    return input;\n  };\n\n  try {\n    const parsed = JSON.parse(raw) as unknown;\n    const stringified = JSON.stringify(sanitizeObject(parsed, 3));\n    return stringified.length > maxLength\n      ? `${stringified.slice(0, maxLength)}[truncated]`\n      : stringified;\n  } catch {\n    return raw.length > maxLength ? `${raw.slice(0, maxLength)}[truncated]` : raw;\n  }\n};\n\nconst createCheckoutSession = async (intakeUuid: string): Promise<{ url?: string; sessionId?: string }> => {\n  try {\n    const response = await fetch(getPracticeClientIntakeCheckoutSessionEndpoint(intakeUuid), {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      credentials: 'include'\n    });\n    if (!response.ok) {\n      const errorBody = await response.text();\n      const safeErrorBody = import.meta.env.DEV ? errorBody : sanitizeErrorBody(errorBody);\n      const errorLog = {\n        status: response.status,\n        statusText: response.statusText,\n        errorBody: safeErrorBody,\n        intakeUuid\n      };\n      if (import.meta.env.DEV) {\n        console.warn('[Intake] Checkout session creation failed', errorLog);\n      } else {\n        // Production logging\n        console.error('[Intake] Checkout session creation failed', JSON.stringify(errorLog));\n      }\n      const error = new Error(`Failed to create checkout session: ${response.status} ${response.statusText}`) as LoggedError;\n      error._logged = true;\n      throw error;\n    }\n    let result: CheckoutSessionResponse;\n    try {\n      result = await response.json() as CheckoutSessionResponse;\n    } catch (parseError) {\n      const errorLog = {\n        status: response.status,\n        statusText: response.statusText,\n        parseError: parseError instanceof Error ? parseError.message : String(parseError),\n        intakeUuid\n      };\n      if (import.meta.env.DEV) {\n        console.warn('[Intake] Failed to parse checkout session JSON', errorLog);\n      } else {\n        console.error('[Intake] Failed to parse checkout session JSON', JSON.stringify(errorLog));\n      }\n      const error = new Error(`Invalid server response (invalid JSON): ${response.status}`) as LoggedError;\n      error._logged = true;\n      throw error;\n    }\n\n    if (!result.success || !result.data?.url) {\n      if (import.meta.env.DEV) {\n        console.warn('[Intake] Checkout session response missing url', result);\n      } else {\n        console.error('[Intake] Checkout session response missing url', JSON.stringify({\n          success: result.success,\n          hasUrl: Boolean(result.data?.url),\n          hasSessionId: Boolean(result.data?.session_id),\n          hasError: Boolean(result.error)\n        }));\n      }\n      const error = new Error(result.error || 'Checkout session response missing URL') as LoggedError;\n      error._logged = true;\n      throw error;\n    }\n    return { url: result.data.url, sessionId: result.data.session_id };\n  } catch (error) {\n    if ((error as LoggedError)._logged) {\n      throw error;\n    }\n    if (import.meta.env.DEV) {\n      console.warn('[Intake] Checkout session request failed', error);\n    } else {\n      console.error('[Intake] Checkout session request failed', error instanceof Error ? error.message : String(error));\n    }\n    throw error;\n  }\n};\n\nasync function fetchIntakeSettings(\n  practiceSlug: string\n): Promise<IntakeSettingsResponse | null> {\n  try {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json'\n    };\n    const response = await fetch(getPracticeClientIntakeSettingsEndpoint(practiceSlug), {\n      method: 'GET',\n      headers,\n      credentials: 'include'\n    });\n\n    if (!response.ok) {\n      return null;\n    }\n\n    return await response.json() as IntakeSettingsResponse;\n  } catch (error) {\n    console.warn('[Intake] Failed to fetch intake settings', error);\n    return null;\n  }\n}\n\nconst resolveIntakeCreateData = (\n  response: IntakeCreateResponse\n): IntakeCreateResponse['data'] | undefined => {\n  if (!response || typeof response !== 'object') return undefined;\n  if (response.data) return response.data;\n  const candidate = response as IntakeCreateResponse['data'];\n  if (candidate?.uuid || candidate?.payment_link_url || candidate?.paymentLinkUrl) {\n    return candidate;\n  }\n  return undefined;\n};\n\n// Submit contact form to API\nexport async function submitContactForm(\n  formData: Record<string, unknown>, \n  practiceSlug: string, \n  onLoadingMessage?: (messageId: string) => void,\n  onUpdateMessage?: (messageId: string, content: string, isLoading: boolean) => void,\n  onError?: (error: string) => void\n): Promise<IntakeSubmissionResult> {\n  const loadingMessageId = crypto.randomUUID();\n  \n  try {\n    onLoadingMessage?.(loadingMessageId);\n    \n    const formPayload = formatFormData(formData, practiceSlug);\n    const settings = await fetchIntakeSettings(practiceSlug);\n    const settingsRecord = settings?.data?.settings;\n    const prefillAmount = typeof settingsRecord?.prefillAmount === 'number'\n      ? settingsRecord.prefillAmount\n      : typeof settingsRecord?.prefill_amount === 'number'\n        ? settingsRecord.prefill_amount\n        : undefined;\n    const paymentLinkEnabled = typeof settingsRecord?.paymentLinkEnabled === 'boolean'\n      ? settingsRecord.paymentLinkEnabled\n      : typeof settingsRecord?.payment_link_enabled === 'boolean'\n        ? settingsRecord.payment_link_enabled\n        : false;\n    if (import.meta.env.DEV) {\n      console.info('[Intake] Settings resolved', {\n        practiceSlug,\n        paymentLinkEnabled,\n        prefillAmount,\n        rawSettings: settingsRecord\n      });\n    }\n    let resolvedPrefillAmount = prefillAmount;\n    if ((resolvedPrefillAmount === undefined || resolvedPrefillAmount <= 0) && paymentLinkEnabled) {\n      try {\n        const practiceDetails = await getPublicPracticeDetails(practiceSlug);\n        const consultationFee = practiceDetails?.details?.consultationFee;\n        const fallbackMinor = toMinorUnitsValue(consultationFee);\n        if (typeof fallbackMinor === 'number' && fallbackMinor > 0) {\n          resolvedPrefillAmount = fallbackMinor;\n        }\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.warn('[Intake] Failed to load consultation fee from practice details', error);\n        }\n      }\n    }\n\n    if (paymentLinkEnabled) {\n      if (typeof resolvedPrefillAmount !== 'number' || !Number.isFinite(resolvedPrefillAmount)) {\n        throw new Error('Consultation fee is not configured for this practice.');\n      }\n      if (resolvedPrefillAmount < 50) {\n        throw new Error('Consultation fee must be at least $0.50.');\n      }\n    }\n\n    const amount = clampAmount(\n      typeof resolvedPrefillAmount === 'number' && Number.isFinite(resolvedPrefillAmount)\n        ? resolvedPrefillAmount\n        : 0\n    );\n    assertMinorUnits(amount, 'intake.create.amount');\n\n    if (settings && settings.data?.settings?.paymentLinkEnabled === false) {\n      console.info('[Intake] Payment link disabled for practice intake');\n    }\n\n    const description = formatDescription(formPayload.description as string | undefined);\n    const resolvedUserId = typeof formData.userId === 'string' && formData.userId.trim().length > 0\n      ? formData.userId.trim()\n      : null;\n\n    const createPayload = {\n      slug: formPayload.slug,\n      amount,\n      email: formPayload.email,\n      name: formPayload.name,\n      ...(typeof formData.sessionId === 'string' && formData.sessionId.trim().length > 0\n        ? { conversation_id: formData.sessionId.trim() }\n        : {}),\n      ...(formPayload.phone ? { phone: formPayload.phone } : {}),\n      ...(description ? { description } : { description: '' }), // Always include description\n      ...(formPayload.opposing_party ? { opposing_party: formPayload.opposing_party } : { opposing_party: '' }), // Always include opposing_party\n      ...(formPayload.address ? { address: formPayload.address } : {}),\n      user_id: resolvedUserId,\n      on_behalf_of: '' // Always include on_behalf_of\n    };\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json'\n    };\n    \n    if (import.meta.env.DEV) {\n      console.log('[Forms] Sending payload to backend:', JSON.stringify(createPayload, null, 2));\n    }\n    \n    const response = await fetch(getPracticeClientIntakeCreateEndpoint(), {\n      method: 'POST',\n      headers,\n      credentials: 'include',\n      body: JSON.stringify(createPayload)\n    });\n\n    if (response.ok) {\n      const result = await response.json() as IntakeCreateResponse;\n      if (result.success === false) {\n        throw new Error(result.error || 'Form submission failed');\n      }\n      const intakeData = resolveIntakeCreateData(result);\n      console.log('Form submitted successfully:', result);\n      \n      // Create confirmation message for matter vs lead first\n      const baseMessage = ' Your lead has been submitted. The legal team will review and contact you.';\n      let confirmationContent = baseMessage;\n\n      // Check if this came from matter creation flow\n      const hasMatter = typeof formData.matterDescription === 'string' && formData.matterDescription.trim() !== '';\n\n      if (hasMatter) {\n        confirmationContent = ' Perfect! Your matter details have been submitted successfully and updated below.';\n      }\n\n      // Update the loading message with confirmation (if callback provided)\n      if (onUpdateMessage) {\n        onUpdateMessage(loadingMessageId, confirmationContent, false);\n      }\n\n      const paymentLinkUrl = intakeData?.payment_link_url ?? intakeData?.paymentLinkUrl;\n      let checkoutSessionUrl: string | undefined;\n      let checkoutSessionId: string | undefined;\n      if (paymentLinkEnabled && intakeData?.uuid) {\n        try {\n          const checkoutSession = await createCheckoutSession(intakeData.uuid);\n          checkoutSessionUrl = checkoutSession?.url;\n          checkoutSessionId = checkoutSession?.sessionId;\n        } catch (error) {\n          if (!(error as LoggedError)._logged) {\n            console.warn('[Intake] Optional checkout session creation failed', error);\n          }\n          // Do not rethrow. Fall back to paymentLinkUrl if available, or just proceed without checkout session.\n          // The form submission was successful.\n        }\n      }\n\n      return {\n        ...result,\n        intake: {\n          uuid: intakeData?.uuid,\n          clientSecret: intakeData?.client_secret,\n          paymentLinkUrl,\n          checkoutSessionUrl,\n          checkoutSessionId,\n          amount: typeof intakeData?.amount === 'number' ? intakeData?.amount : amount,\n          currency: intakeData?.currency ?? 'usd',\n          paymentLinkEnabled,\n          organizationName: intakeData?.organization?.name ?? settings?.data?.organization?.name,\n          organizationLogo: intakeData?.organization?.logo ?? settings?.data?.organization?.logo\n        }\n      };\n    } else {\n      const errorText = await response.text();\n      console.error('[Forms] Backend error response:', {\n        status: response.status,\n        statusText: response.statusText,\n        errorBody: errorText\n      });\n      \n      // Parse error text once to avoid double consumption\n      let errorData: { error?: string; message?: string } = {};\n      try {\n        errorData = JSON.parse(errorText) as { error?: string; message?: string };\n      } catch {\n        // If parsing fails, errorData remains empty object\n      }\n      \n      throw new Error(errorData.error || errorData.message || `Backend error: ${response.status} ${response.statusText}`);\n    }\n  } catch (error) {\n    console.error('Error submitting form:', error);\n    const errorMessage = error instanceof Error && error.message ? error.message : 'Form submission failed';\n    \n    // Update loading message with error content (if callback provided)\n    if (onUpdateMessage) {\n      setTimeout(() => {\n        onUpdateMessage(\n          loadingMessageId,\n          `Sorry, there was an error submitting your information: ${errorMessage}. Please try again or contact us directly.`,\n          false\n        );\n      }, 300);\n    }\n    \n    onError?.(errorMessage);\n    throw error instanceof Error ? error : new Error(errorMessage);\n  }\n} \n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/intakePayments.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":168,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":168,"endColumn":17,"suggestions":[{"fix":{"range":[5252,5321],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getPracticeClientIntakeStatusEndpoint } from '@/config/api';\nimport { assertMinorUnits, type MinorAmount } from '@/shared/utils/money';\n\nexport type IntakePaymentRequest = {\n  intakeUuid?: string;\n  clientSecret?: string;\n  paymentLinkUrl?: string;\n  checkoutSessionUrl?: string;\n  checkoutSessionId?: string;\n  amount?: MinorAmount;\n  currency?: string;\n  practiceName?: string;\n  practiceLogo?: string;\n  practiceSlug?: string;\n  practiceId?: string;\n  conversationId?: string;\n  returnTo?: string;\n};\n\ntype IntakeStatusResponse = {\n  success?: boolean;\n  data?: {\n    status?: string;\n  };\n};\n\nconst getQueryValue = (value?: string) => (value && value.trim().length > 0 ? value.trim() : undefined);\nconst sanitizeReturnTo = (value?: string) => {\n  const trimmed = getQueryValue(value);\n  if (!trimmed) return undefined;\n  return trimmed.startsWith('/') && !trimmed.startsWith('//') ? trimmed : undefined;\n};\n\nconst PAID_STATUSES = new Set(['succeeded', 'completed', 'paid', 'complete']);\nconst STRIPE_PAYMENT_HOSTS = ['checkout.stripe.com', '.stripe.com'];\n\nconst normalizeStatus = (value?: string | null) => {\n  if (!value) return null;\n  const trimmed = value.trim().toLowerCase();\n  return trimmed.length > 0 ? trimmed : null;\n};\n\nexport const isPaidIntakeStatus = (status?: string | null): boolean => {\n  const normalized = normalizeStatus(status);\n  return normalized ? PAID_STATUSES.has(normalized) : false;\n};\n\nexport const isValidStripePaymentLink = (url: string): boolean => {\n  try {\n    const parsed = new URL(url);\n    if (parsed.protocol !== 'https:') return false;\n    return STRIPE_PAYMENT_HOSTS.some((host) =>\n      host.startsWith('.')\n        ? parsed.hostname.endsWith(host)\n        : parsed.hostname === host\n    );\n  } catch {\n    return false;\n  }\n};\n\nexport const isValidStripeCheckoutSessionUrl = (url: string): boolean => {\n  try {\n    const parsed = new URL(url);\n    if (parsed.protocol !== 'https:') return false;\n    return STRIPE_PAYMENT_HOSTS.some((host) =>\n      host.startsWith('.')\n        ? parsed.hostname.endsWith(host)\n        : parsed.hostname === host\n    );\n  } catch {\n    return false;\n  }\n};\n\nexport const buildIntakePaymentUrl = (\n  request: IntakePaymentRequest,\n  options?: { includeClientSecret?: boolean }\n) => {\n  const params = new URLSearchParams();\n\n  if (options?.includeClientSecret) {\n    const clientSecret = getQueryValue(request.clientSecret);\n    if (clientSecret) params.set('client_secret', clientSecret);\n  }\n\n  if (typeof request.amount === 'number' && Number.isFinite(request.amount)) {\n    assertMinorUnits(request.amount, 'intake.payment.amount');\n    params.set('amount', String(request.amount));\n  }\n\n  const currency = getQueryValue(request.currency);\n  if (currency) params.set('currency', currency);\n\n  const practiceName = getQueryValue(request.practiceName);\n  if (practiceName) params.set('practice', practiceName);\n\n  const practiceLogo = getQueryValue(request.practiceLogo);\n  if (practiceLogo) params.set('logo', practiceLogo);\n\n  const practiceSlug = getQueryValue(request.practiceSlug);\n  if (practiceSlug) params.set('slug', practiceSlug);\n\n  const practiceId = getQueryValue(request.practiceId);\n  if (practiceId) params.set('practiceId', practiceId);\n\n  const conversationId = getQueryValue(request.conversationId);\n  if (conversationId) params.set('conversationId', conversationId);\n\n  const intakeUuid = getQueryValue(request.intakeUuid);\n  if (intakeUuid) params.set('uuid', intakeUuid);\n\n  const paymentLinkUrl = getQueryValue(request.paymentLinkUrl);\n  if (paymentLinkUrl && isValidStripePaymentLink(paymentLinkUrl)) {\n    params.set('payment_link_url', paymentLinkUrl);\n  }\n\n  const checkoutSessionUrl = getQueryValue(request.checkoutSessionUrl);\n  if (checkoutSessionUrl && isValidStripeCheckoutSessionUrl(checkoutSessionUrl)) {\n    params.set('checkout_session_url', checkoutSessionUrl);\n  }\n\n  const checkoutSessionId = getQueryValue(request.checkoutSessionId);\n  if (checkoutSessionId) {\n    const isValidCheckoutSessionId = /^cs_(test|live)_[A-Za-z0-9]+$/.test(checkoutSessionId);\n    if (isValidCheckoutSessionId) {\n      params.set('checkout_session_id', checkoutSessionId);\n    }\n  }\n\n  const returnTo = sanitizeReturnTo(request.returnTo);\n  if (returnTo) params.set('return_to', returnTo);\n\n  const query = params.toString();\n  return query.length > 0 ? `/pay?${query}` : '/pay';\n};\n\nexport const fetchIntakePaymentStatus = async (\n  intakeUuid?: string,\n  options?: { timeoutMs?: number }\n): Promise<string | null> => {\n  const trimmed = getQueryValue(intakeUuid);\n  if (!trimmed) return null;\n\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), options?.timeoutMs ?? 8000);\n  try {\n    const response = await fetch(\n      getPracticeClientIntakeStatusEndpoint(trimmed),\n      {\n        method: 'GET',\n        signal: controller.signal\n      }\n    );\n    clearTimeout(timeoutId);\n\n    if (!response.ok) {\n      return null;\n    }\n\n    const payload = await response.json() as IntakeStatusResponse;\n    return normalizeStatus(payload.data?.status);\n  } catch (error) {\n    clearTimeout(timeoutId);\n    if (error instanceof Error && error.name === 'AbortError') {\n      return null;\n    }\n    console.warn('[IntakePayment] Failed to fetch intake status', error);\n    return null;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/keyboard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/leadPermissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/matterAnalysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/mediaAggregation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/modalStack.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/money.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/navigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/practiceInvites.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/practiceLogoUpload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/practiceProfile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/practiceRoles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/stripeOnboarding.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/subscription.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/urlValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/shared/utils/workspace.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/types/onesignal.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/middleware/cors.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/middleware/practiceContext.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/middleware/rateLimit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/routes/conversations.participants.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/services/conversationConfig.tools.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/utils/dateTime.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/utils/domain.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/utils/forms.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/utils/piiSanitizer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/utils/retry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/worker/internal-routes.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/worker/services/ConversationService.addParticipants.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/tests/unit/worker/services/PDFGenerationService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/durable-objects/ChatCounterObject.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/durable-objects/ChatRoom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/durable-objects/MatterProgressRoom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/errorHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/lib/geoapify.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/lib/kvCounters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/lib/pdf.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/middleware/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/middleware/cors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/middleware/practiceContext.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/middleware/rateLimit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/queues/notificationProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/activity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/aiChat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/aiIntent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/analyze.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/api/geo/autocomplete.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/authProxy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/conversations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/debug.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/files.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/intakes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/notifications.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/paralegal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/pdf.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/practiceDetails.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/practices.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/root.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/routes/status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/schemas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/schemas/legal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/schemas/validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/ActivityService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/AdobeDocumentService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/ContactIntakeOrchestrator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/ConversationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/MatterService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/NotificationDeliveryStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/NotificationDestinationStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/NotificationPublisher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/NotificationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/OneSignalService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/PDFGenerationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/RemoteApiService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/SessionAuditService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/services/StatusService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/types/pdf-lib.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/types/ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/__tests__/domain.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/aiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/contactInfoUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/contactValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/domain.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/fileAnalysisUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/logging.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/money.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/piiSanitizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/practiceDetailsCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/responseUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/retry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/safeStringUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/paulchrisluke/Repos2025/preact-cloudflare-intake-chatbot/blawby-ai-chatbot/worker/utils/validationErrors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
