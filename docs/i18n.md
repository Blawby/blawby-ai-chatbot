# Internationalization Guide

This document explains the i18n foundations added in the `i18n-foundations` branch and how contributors can extend language coverage page by page.

## Current Stack

- **Library**: [`i18next`](https://www.i18next.com/) with [`react-i18next`](https://react.i18next.com/) via `preact/compat`
- **Supported locales**: English (`en`, default), Spanish (`es`), French (`fr`), German (`de`), Chinese/Simplified (`zh`), Japanese (`ja`), Vietnamese (`vi`)
- **Namespaces**: `common`, `settings`, `auth`, `profile`
- **Entry point**: `src/i18n/index.ts` (initialisation, locale helpers, dynamic loading)
- **Locale assets**: `src/locales/<locale>/<namespace>.json`
- **Validation**: `npm run lint:i18n` – ensures every locale has the same keys as the base (`en`)

## Provider & Runtime

`src/index.tsx` wraps the app with `I18nextProvider` and a `Suspense` loader. `initI18n()` ensures:

1. English resources ship in the initial bundle for SSR/hydration.
2. Additional locales load on demand through dynamic imports.
3. The active locale persists in `localStorage` (`blawby_locale`) and falls back to system detection when set to auto.

Helper exports from `src/i18n/index.ts`:

- `DEFAULT_LOCALE`, `SUPPORTED_LOCALES`
- `setLocale(locale: string)` – load resources (if necessary) and switch language.
- `detectBestLocale()` – returns the best effort from `navigator.language`.

## Adding Strings

1. Determine the namespace (`common`, `settings`, `auth`, …). When in doubt: use feature-based namespaces (e.g. `chat`, `pricing`) to keep files small.
2. Add the English key/value to `src/locales/en/<namespace>.json`.
3. Propagate the key to every other locale file. Use the English phrase as a placeholder if you do not have a translation yet.
4. Replace hard-coded text in the component with `const { t } = useTranslation('<namespace>');`.
5. Run `npm run lint:i18n` before pushing.

### Key Naming

```text
<namespace>.<feature>.<element>.<state>
```

Examples used in the initial migration:

- `settings:general.theme.options.dark`
- `settings:help.sections.helpCenter.description`

Camel-case keys are avoided to keep JSON grep-friendly.

## Sample Flow: Settings → Help / General

- `HelpPage.tsx` now pulls copy from `settings.help.*` keys, including aria labels.
- `GeneralPage.tsx` demonstrates
  - Using `common.language.*` helpers for dropdowns
  - Calling `setLocale()` when the interface language changes
  - Showing toast notifications with translated titles/bodies

Use these as references for future migrations (e.g. `AccountPage`, `PricingModal`).

## Locale Validation Script

`scripts/check-i18n.mjs` flattens every JSON file and compares keys against English. The script is intentionally strict so missing translations are caught during CI.

```bash
npm run lint:i18n
```

## Adding a New Locale

1. Duplicate `src/locales/en` → `src/locales/<new-locale>`.
2. Translate each namespace file.
3. Append the locale to `SUPPORTED_LOCALES` in `src/i18n/index.ts` and any UI select lists (e.g. `GeneralPage`).
4. Update docs/tests (see below) to cover the new language.

## Testing Tips

- **Smoke script**: run `npm run test:i18n` to ensure key translations differ between English and Spanish after changes.
- **Unit**: create component-level tests using `I18nextProvider` and the new `RootTestProviders` pattern (to be added) so strings render as expected.
- **Manual**: change languages via Settings → General, reload the app, and ensure the selection persists.
- **Automation**: extend Playwright flows to switch locales and snapshot key screens.

## Follow-up Backlog (suggested issues)

1. **Component migrations** – iterate through UI surfaces (chat, modals, pricing, auth, etc.). Track progress per namespace/route.
2. **Worker / API responses** – decide whether to internationalize server messages or expose machine-readable codes for client-side translation.
3. **Prompt localisation** – create per-locale AI prompts or copy decks (requires product/legal review).
4. **Translation workflow** – integrate a localisation platform (Crowdin, Lokalise, Tolgee…) and wire CI to validate imports.
5. **Manifest & SEO** – translate `SEOHead`, `index.html`, sitemap, and PWA manifest metadata.
6. **Testing harness** – introduce helper utilities (e.g. `renderWithI18n`) and update existing tests to avoid relying on raw English strings.

Keep discussions and PRs scoped per feature to make reviews approachable for new contributors.

## Auth Namespace Implementation

The `auth` namespace (`src/locales/<locale>/auth.json`) contains translations for authentication flows:

### Structure
- `signin.*` - Sign-in form labels, placeholders, and messages
- `signup.*` - Sign-up form labels, placeholders, and messages  
- `messages.*` - Success/status messages (account created, signed in, etc.)
- `errors.*` - Error messages (validation, network, etc.)
- `navigation.*` - Navigation elements (back buttons, etc.)
- `defaults.*` - Default user names and fallback values

### Error Handling Patterns

When implementing auth flows, follow these patterns:

1. **Validation Errors**: Use `t('errors.required')`, `t('errors.invalidEmail')`, etc.
2. **Success Messages**: Use `t('messages.accountCreated')`, `t('messages.signedIn')`, etc.
3. **Default Values**: Use `t('defaults.demoUserName')` for fallback user names
4. **Form Labels**: Use `t('signin.email')` vs `t('signup.email')` for context-specific labels

### Example Usage

```tsx
const { t } = useTranslation('auth');

// Form labels
<label>{t(isSignUp ? 'signup.email' : 'signin.email')}</label>

// Error messages
setError(t('errors.passwordsDoNotMatch'));

// Success messages
setMessage(t('messages.accountCreated'));

// Default values
name: formData.name || t('defaults.demoUserName')
```

### Mock Data Considerations

When creating mock users or default data, avoid hardcoded English strings:

- ✅ Use `t('defaults.demoUserName')` instead of `'Demo User'`
- ✅ Use `t('defaults.googleUserName')` instead of `'Google User'`
- ✅ Use translated error messages instead of hardcoded English strings

This ensures that even mock data respects the user's selected language.

## Profile Namespace Implementation

The `profile` namespace (`src/locales/<locale>/profile.json`) contains translations for user profile flows:

### Structure
- `menu.*` - Profile menu items (settings, upgrade, help, sign in/out)
- `status.*` - Status messages (loading, signing out)
- `aria.*` - Accessibility labels for screen readers

### Key Patterns

#### Interpolation for Dynamic Values

When user data needs to be displayed in translations, use interpolation:

```tsx
const { t } = useTranslation('profile');

// With interpolation
aria-label={t('aria.userProfile', { name: user.name })}
// Renders: "User profile for Steve Chris" (English)
// Renders: "Perfil de usuario para Steve Chris" (Spanish)
```

In the translation file:
```json
{
  "aria": {
    "userProfile": "User profile for {{name}}"
  }
}
```

#### Context-Specific Labels

Profile flows often need multiple versions of the same action:

```json
{
  "menu": {
    "upgrade": "Upgrade plan",
    "upgradeShort": "Upgrade"
  }
}
```

Use the full version in dropdowns/menus where space permits, and the short version for inline buttons.

#### Mock Data Services

Profile-related mock data services (like `mockUserDataService`) may contain hardcoded English strings. This is acceptable for:

- Test user names (e.g., `'Steve Chris'`, `'Demo User'`)
- Development-only bio text
- Mock team/organization names

These are not user-facing UI strings and don't need translation. However, any strings that appear in the actual UI (toast messages, button labels, form validation) must use translation keys.

### Example Usage

```tsx
const { t } = useTranslation(['profile', 'common']);

// Menu items
{t('profile:menu.signIn')}
{t('profile:menu.settings')}
{t('profile:menu.upgrade')}
{t('profile:menu.signOut')}

// Accessibility
title={isCollapsed ? t('profile:menu.signIn') : undefined}
aria-label={t('profile:aria.signInButton')}

// With user data interpolation
aria-label={t('profile:aria.userProfile', { name: user.name })}
```

### Future: Toast Messages in Profile Flows

When implementing toast notifications in profile flows (e.g., sign-out confirmation, profile update success), follow these patterns:

1. **Add keys to profile.json**:
```json
{
  "toasts": {
    "signOutSuccess": "Successfully signed out",
    "profileUpdateSuccess": "Profile updated successfully"
  }
}
```

2. **Use in toast calls**:
```tsx
showToast({
  title: t('profile:toasts.signOutSuccess'),
  type: 'success'
});
```
