# Internationalization Guide
 
 > Archived on: 2025-11-04 — This document is superseded by the canonical guide: [internationalization.md](../../internationalization.md)
 
 
 This document explains the i18n foundations added in the `i18n-foundations` branch and how contributors can extend language coverage page by page.

## Current Stack

- **Library**: [`i18next`](https://www.i18next.com/) with [`react-i18next`](https://react.i18next.com/) via `preact/compat`
- **Supported locales**: English (`en`, default), Spanish (`es`), French (`fr`), German (`de`), Chinese/Simplified (`zh`), Japanese (`ja`), Vietnamese (`vi`), Portuguese (`pt`), Arabic (`ar`), Russian (`ru`), Italian (`it`), Korean (`ko`), Dutch (`nl`), Polish (`pl`), Turkish (`tr`), Thai (`th`), Indonesian (`id`), Hindi (`hi`), Ukrainian (`uk`) (19 total)
- **Namespaces**: `common`, `settings`, `auth`, `profile`, `pricing`, `organization`
- **Entry point**: `src/i18n/index.ts` (initialisation, locale helpers, dynamic loading)
- **Locale assets**: `src/locales/<locale>/<namespace>.json`
- **Validation**: `npm run lint:i18n` – ensures every locale has the same keys as the base (`en`)

## Production Build Strategy

To ensure locale files are properly bundled in production builds, each locale directory contains an `index.ts` file that pre-imports all namespace JSON files:

```typescript
// src/locales/es/index.ts
import common from './common.json';
import settings from './settings.json';
import auth from './auth.json';
import profile from './profile.json';
import pricing from './pricing.json';
import organization from './organization.json';

export { common, settings, auth, profile, pricing, organization };
```

The `loadLocaleResources()` function in `src/i18n/index.ts` uses these index files to ensure Vite includes all translations in the production bundle. This solves the issue where dynamic imports with template literals were not being statically analyzed by the bundler.

## Provider & Runtime

`src/index.tsx` wraps the app with `I18nextProvider` and a `Suspense` loader. `initI18n()` ensures:

1. English resources ship in the initial bundle for SSR/hydration.
2. Additional locales load on demand through dynamic imports.
3. The active locale persists in `localStorage` (`blawby_locale`) and falls back to system detection when set to auto.

Helper exports from `src/i18n/index.ts`:

- `DEFAULT_LOCALE`, `SUPPORTED_LOCALES`
- `setLocale(locale: string)` – load resources (if necessary) and switch language.
- `detectBestLocale()` – returns the best effort from `navigator.language`.

## React Configuration

The i18next React configuration includes proper binding for component re-rendering:

```typescript
react: {
  useSuspense: true,
  bindI18n: 'languageChanged loaded',
  bindI18nStore: 'added removed'
}
```

This ensures that components automatically re-render when the language changes or new translations are loaded.

## Adding Strings

1. Determine the namespace (`common`, `settings`, `auth`, …). When in doubt: use feature-based namespaces (e.g. `chat`, `pricing`) to keep files small.
2. Add the English key/value to `src/locales/en/<namespace>.json`.
3. Propagate the key to every other locale file. Use the English phrase as a placeholder if you do not have a translation yet.
4. Replace hard-coded text in the component with `const { t } = useTranslation('<namespace>');`.
5. Run `npm run lint:i18n` before pushing.

### Key Naming

```text
<namespace>.<feature>.<element>.<state>
```

Examples used in the initial migration:

- `settings:general.theme.options.dark`
- `settings:help.sections.helpCenter.description`

Camel-case keys are avoided to keep JSON grep-friendly.

## Sample Flow: Settings → Help / General

- `HelpPage.tsx` now pulls copy from `settings.help.*` keys, including aria labels.
- `GeneralPage.tsx` demonstrates
  - Using `common.language.*` helpers for dropdowns
  - Calling `setLocale()` when the interface language changes
  - Showing toast notifications with translated titles/bodies

Use these as references for future migrations (e.g. `AccountPage`, `PricingModal`).

## Locale Validation Script

`scripts/check-i18n.mjs` flattens every JSON file and compares keys against English. The script is intentionally strict so missing translations are caught during CI.

```bash
npm run lint:i18n
```

## Adding a New Locale

1. Duplicate `src/locales/en` → `src/locales/<new-locale>`.
2. Translate each namespace file.
3. Create `src/locales/<new-locale>/index.ts` with exports for all namespaces:
   ```typescript
   import common from './common.json';
   import settings from './settings.json';
   import auth from './auth.json';
   import profile from './profile.json';
   import pricing from './pricing.json';
   import organization from './organization.json';
   
   export { common, settings, auth, profile, pricing, organization };
   ```
4. Append the locale to `SUPPORTED_LOCALES` in `src/i18n/index.ts` and any UI select lists (e.g. `GeneralPage`).
5. Update docs/tests (see below) to cover the new language.
6. Run `npm run build` to verify the locale files are properly bundled.

## Testing Tips

- **Smoke script**: run `npm run test:i18n` to ensure key translations differ between English and Spanish after changes.
- **Unit**: create component-level tests using `I18nextProvider` and the new `RootTestProviders` pattern (to be added) so strings render as expected.
- **Manual**: change languages via Settings → General, reload the app, and ensure the selection persists.
- **Automation**: extend Playwright flows to switch locales and snapshot key screens.

## Follow-up Backlog (suggested issues)

1. **Component migrations** – iterate through UI surfaces (chat, modals, pricing, auth, etc.). Track progress per namespace/route.
2. **Worker / API responses** – decide whether to internationalize server messages or expose machine-readable codes for client-side translation.
3. **Prompt localisation** – create per-locale AI prompts or copy decks (requires product/legal review).
4. **Translation workflow** – integrate a localisation platform (Crowdin, Lokalise, Tolgee…) and wire CI to validate imports.
5. **Manifest & SEO** – translate `SEOHead`, `index.html`, sitemap, and PWA manifest metadata.
6. **Testing harness** – introduce helper utilities (e.g. `renderWithI18n`) and update existing tests to avoid relying on raw English strings.

Keep discussions and PRs scoped per feature to make reviews approachable for new contributors.

## Auth Namespace Implementation

The `auth` namespace (`src/locales/<locale>/auth.json`) contains translations for authentication flows:

### Structure
- `signin.*` - Sign-in form labels, placeholders, and messages
- `signup.*` - Sign-up form labels, placeholders, and messages  
- `messages.*` - Success/status messages (account created, signed in, etc.)
- `errors.*` - Error messages (validation, network, etc.)
- `navigation.*` - Navigation elements (back buttons, etc.)
- `defaults.*` - Default user names and fallback values

### Error Handling Patterns

When implementing auth flows, follow these patterns:

1. **Validation Errors**: Use `t('errors.required')`, `t('errors.invalidEmail')`, etc.
2. **Success Messages**: Use `t('messages.accountCreated')`, `t('messages.signedIn')`, etc.
3. **Default Values**: Use `t('defaults.demoUserName')` for fallback user names
4. **Form Labels**: Use `t('signin.email')` vs `t('signup.email')` for context-specific labels

### Example Usage

```tsx
const { t } = useTranslation('auth');

// Form labels
<label>{t(isSignUp ? 'signup.email' : 'signin.email')}</label>

// Error messages
setError(t('errors.passwordsDoNotMatch'));

// Success messages
setMessage(t('messages.accountCreated'));

// Default values
name: formData.name || t('defaults.demoUserName')
```

### Mock Data Translation Rules

**General Rule for Mock Data**:

1. **User-facing UI strings MUST use `t()`** - Any text that appears in the UI (labels, messages, descriptions) must be translated
2. **Development/test-only identifiers MAY be hardcoded** - Test names, IDs, and internal-only data can remain in English
3. **Exempt mock data MUST be marked** - Add `// dev/test-only — not localized` comment to exempted items

**Examples**:
```typescript
// ✅ User-facing UI string - MUST be translated
const welcomeMessage = t('messages.welcomeUser', { name: userName });

// ✅ Test-only identifier - MAY be hardcoded (marked)
const testUserId = 'test-user-123'; // dev/test-only — not localized

// ✅ Mock organization name for testing - MAY be hardcoded (marked)
const mockOrgName = 'Test Law Firm'; // dev/test-only — not localized

// ❌ Unmarked hardcoded string - NOT allowed
const buttonLabel = 'Submit'; // Should use t('common.submit')
```

This rule ensures consistency across all namespaces while allowing flexibility for test data.

## Profile Namespace Implementation

The `profile` namespace (`src/locales/<locale>/profile.json`) contains translations for user profile flows:

### Structure
- `menu.*` - Profile menu items (settings, upgrade, help, sign in/out)
- `status.*` - Status messages (loading, signing out)
- `aria.*` - Accessibility labels for screen readers

### Key Patterns

#### Interpolation for Dynamic Values

When user data needs to be displayed in translations, use interpolation:

```tsx
const { t } = useTranslation('profile');

// With interpolation
aria-label={t('aria.userProfile', { name: user.name })}
// Renders: "User profile for Steve Chris" (English)
// Renders: "Perfil de usuario para Steve Chris" (Spanish)
```

In the translation file:
```json
{
  "aria": {
    "userProfile": "User profile for {{name}}"
  }
}
```

#### Context-Specific Labels

Profile flows often need multiple versions of the same action:

```json
{
  "menu": {
    "upgrade": "Upgrade plan",
    "upgradeShort": "Upgrade"
  }
}
```

Use the full version in dropdowns/menus where space permits, and the short version for inline buttons.

#### Mock Data Services

Profile-related mock data services should follow the **Mock Data Translation Rules** (see section above). For test-only data:

```typescript
// ✅ Test user name - marked as dev/test-only
const mockUser = {
  name: 'Steve Chris', // dev/test-only — not localized
  bio: 'Demo user for testing', // dev/test-only — not localized
  organizationId: 'test-org-123' // dev/test-only — not localized
};

// ✅ UI-facing data - must use translation
const profileMenuItem = {
  label: t('profile.menu.settings'),
  ariaLabel: t('profile.aria.userSettings')
};
```

### Example Usage

```tsx
const { t } = useTranslation(['profile', 'common']);

// Menu items
{t('profile:menu.signIn')}
{t('profile:menu.settings')}
{t('profile:menu.upgrade')}
{t('profile:menu.signOut')}

// Accessibility
title={isCollapsed ? t('profile:menu.signIn') : undefined}
aria-label={t('profile:aria.signInButton')}

// With user data interpolation
aria-label={t('profile:aria.userProfile', { name: user.name })}
```

### Future: Toast Messages in Profile Flows

When implementing toast notifications in profile flows (e.g., sign-out confirmation, profile update success), follow these patterns:

1. **Add keys to profile.json**:
```json
{
  "toasts": {
    "signOutSuccess": "Successfully signed out",
    "profileUpdateSuccess": "Profile updated successfully"
  }
}
```

2. **Use in toast calls**:
```tsx
showToast({
  title: t('profile:toasts.signOutSuccess'),
  type: 'success'
});
```

## Organization Namespace Implementation

The `organization` namespace (`src/locales/<locale>/organization.json`) contains translations for organization-related UI flows:

### Structure
- `notFound.*` - Organization not found page content (title, description, reasons, help text, actions)

### Purpose
This namespace handles translations for organization-specific error states and user flows, particularly when users encounter invalid or missing organization references.

### Example Usage

```tsx
const { t } = useTranslation('organization');

// Organization not found page
<h1>{t('notFound.title')}</h1>
<p>{t('notFound.description.prefix')} "{organizationId}" {t('notFound.description.suffix')}</p>

// Action buttons
<button>{t('notFound.actions.tryAgain')}</button>
<button>{t('notFound.actions.goToHome')}</button>
```

### Key Patterns

#### Error State Messaging

Organization-related error pages use structured messaging with prefixes, suffixes, and contextual help:

```json
{
  "notFound": {
    "description": {
      "prefix": "We couldn't find the organization",
      "suffix": "This could be because:"
    },
    "reasons": {
      "incorrectId": "The organization ID might be incorrect",
      "movedOrRemoved": "The organization may have been moved or removed",
      "outdatedLink": "You might have an outdated link"
    }
  }
}
```

This structure allows for flexible error messaging that can be adapted to different contexts while maintaining consistency across languages.

## Pricing Namespace Implementation

The `pricing` namespace (`src/locales/<locale>/pricing.json`) contains translations for pricing, billing, and subscription flows:

### Structure
- `plans.*` - Plan names, descriptions, and button text (free, plus, business)
- `features.*` - Feature names, descriptions, and tier-specific text
- `limitations.*` - Plan-specific limitations
- `benefits.*` - Plan-specific benefits
- `modal.*` - Pricing modal UI strings (title, tabs, labels)
- `billing.*` - Billing period labels and currency strings
- `comparison.*` - Feature comparison table labels

### Currency Formatting

All price displays use `Intl.NumberFormat` for locale-aware currency formatting via the `currencyFormatter` utility:

```tsx
import { formatCurrency } from '../utils/currencyFormatter';
import { useTranslation } from 'react-i18next';

const { i18n } = useTranslation();

// Format currency with locale awareness
const formattedPrice = formatCurrency(
  plan.priceAmount,  // 20
  plan.currency,     // 'USD'
  i18n.language      // 'es'
);
// Returns locale-appropriate format:
// en-US: "$20.00"
// es-ES: "20,00 US$" 
// fr-FR: "20,00 $US"
// de-DE: "20,00 $"
// Note: Exact formatting depends on Intl.NumberFormat for each locale
```

#### Currency Formatter Functions

**`formatCurrency(amount, currency, locale)`**
- Formats a price with currency symbol
- Automatically handles decimal places (0 for whole numbers, 2 for decimals)
- Falls back to `en-US` if locale is unsupported

**`getCurrencySymbol(currency, locale)`**
- Extracts just the currency symbol for a given currency and locale
- Useful for custom display patterns

**`formatPrice(amount, locale)`**
- Formats a number without currency symbol
- Useful for displaying amounts in tables or lists

**`buildPriceDisplay(amount, currency, billingPeriod, locale, t)`**
- Complete price string with currency and billing period
- Example: `"$20 USD / month"` or `"20 € EUR / mois"` (French)

### Translation Key Patterns

All pricing data follows the **Mock Data Translation Rules** (see section above). User-facing pricing information must use translation keys:

```typescript
// ❌ Before (hardcoded UI strings)
const PRICING_PLANS = [{
  id: 'free',
  name: 'Free', // User-facing - should use t()
  description: 'Legal AI assistance for everyday needs', // User-facing - should use t()
  buttonText: 'Your current plan' // User-facing - should use t()
}];

// ✅ After (translation keys for UI)
const PRICING_PLANS = [{
  id: 'free',
  name: 'pricing:plans.free.name',
  description: 'pricing:plans.free.description',
  buttonText: 'pricing:plans.free.buttonText'
}];

// ✅ Internal test data - may be hardcoded (marked)
const testPlanId = 'free-test-plan'; // dev/test-only — not localized
```

### Example Usage

```tsx
const { t, i18n } = useTranslation('pricing');

// Plan names and descriptions
<h3>{t('plans.plus.name')}</h3>
<p>{t('plans.plus.description')}</p>

// Feature text with tier-specific variants
<span>{t('features.aiAccess.text.free')}</span>
<span>{t('features.aiAccess.text.plus')}</span>
<span>{t('features.aiAccess.text.business')}</span>

// Modal UI strings
<h1>{t('modal.title')}</h1>
<button>{t('modal.tabs.personal')}</button>
<button>{t('modal.tabs.business')}</button>

// Currency formatting
const price = formatCurrency(20, 'USD', i18n.language) + ' ' + 
              'USD' + ' ' + 
              t('billing.perMonth');
// Examples (format varies by locale via Intl.NumberFormat):
// en-US: "$20.00 USD / month"
// es-ES: "20,00 US$ USD / mes"
// fr-FR: "20,00 $US USD / mois"
// Note: Actual output depends on browser's Intl.NumberFormat implementation
```

### Translating Plans Dynamically

When displaying pricing plans from `mockPricingDataService`, translate them at render time:

```tsx
const { t, i18n } = useTranslation('pricing');
const rawPlans = mockPricingDataService.getPricingPlans();

const translatedPlans = rawPlans.map(plan => ({
  ...plan,
  name: t(plan.name),
  description: t(plan.description),
  buttonText: t(plan.buttonText),
  price: formatCurrency(plan.priceAmount, plan.currency, i18n.language) + ' ' +
         plan.currency.toUpperCase() + ' ' +
         t(`billing.per${plan.billingPeriod === 'month' ? 'Month' : 'Year'}`),
  features: plan.features.map(f => ({
    ...f,
    text: t(f.text),
    description: f.description ? t(f.description) : undefined
  })),
  benefits: plan.benefits?.map(b => t(b)),
  limitations: plan.limitations?.map(l => t(l))
}));
```

### Mock Data Service Considerations

The `mockPricingDataService` returns translation keys, not translated text. This ensures:

1. **Separation of concerns**: Data structure is separate from presentation
2. **Dynamic language switching**: Plans update immediately when locale changes
3. **Consistent formatting**: Currency and dates format according to user's locale
4. **Easy maintenance**: Update translations without touching data structures

### Culturally Appropriate Formatting

Each language receives culturally appropriate translations:

- **Date formats**: Handled automatically by `Intl.NumberFormat`
- **Currency position**: `$20` (English), `20 $` (French), `20€` (German)
- **Professional terminology**: Legal terms translated appropriately for each market
- **Formal vs informal**: Appropriate formality level for business software

### Testing Pricing Translations

```bash
# Validate all pricing translations exist
npm run lint:i18n

# Test i18n implementation
npm run test:i18n

# Manual QA checklist:
# 1. Change language in settings
# 2. Open pricing modal
# 3. Verify plan names are translated
# 4. Verify feature descriptions are translated
# 5. Verify currency formats correctly (symbol position, separators)
# 6. Verify billing periods are translated
# 7. Verify button text is translated
```
