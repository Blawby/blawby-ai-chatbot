# ActivityTimeline Backend Integration Plan

## Overview
Connect the ActivityTimeline component to real backend data from `matter_events` and `session_audit_events` tables instead of using placeholder data.

## Current State
- ✅ Database schema exists (`matter_events`, `session_audit_events`)
- ❌ No API routes to fetch activity data
- ❌ No services to retrieve events
- ❌ ActivityTimeline uses hardcoded placeholder data
- ❌ No event creation when actions occur

## Implementation Plan

### Phase 1: Backend API Infrastructure

#### 1.1 Create Activity Service
**File:** `worker/services/ActivityService.ts`

```typescript
export interface ActivityEvent {
  id: string;
  type: 'matter_event' | 'session_event';
  eventType: string; // 'payment', 'status_change', 'document_added', etc.
  title: string;
  description: string;
  eventDate: string;
  actorType?: 'user' | 'lawyer' | 'system';
  actorId?: string;
  metadata?: Record<string, any>;
  createdAt: string;
}

export interface ActivityQueryOptions {
  matterId?: string;
  sessionId?: string;
  limit?: number; // default 25, max 50
  cursor?: string; // opaque pagination token
  since?: string; // ISO 8601 timestamp
  until?: string; // ISO 8601 timestamp
  type?: string[]; // event types to filter by
  actorType?: 'user' | 'lawyer' | 'system';
}

export interface ActivityQueryResult {
  items: ActivityEvent[];
  nextCursor?: string;
  total?: number;
  hasMore: boolean;
}

export class ActivityService {
  constructor(private env: Env) {}

  async getMatterEvents(matterId: string): Promise<ActivityEvent[]>
  async getSessionEvents(sessionId: string): Promise<ActivityEvent[]>
  async getCombinedActivity(matterId?: string, sessionId?: string): Promise<ActivityEvent[]>
  async queryActivity(options: ActivityQueryOptions): Promise<ActivityQueryResult>
  async createEvent(event: Omit<ActivityEvent, 'id' | 'createdAt'>): Promise<string>
  
  // Cursor management
  private encodeCursor(data: any): string
  private decodeCursor(cursor: string): any
  private generateNextCursor(lastItem: ActivityEvent, options: ActivityQueryOptions): string
}
```

#### 1.2 Create Activity API Route
**File:** `worker/routes/activity.ts`

```typescript
// GET /api/activity - Comprehensive activity endpoint with pagination, filtering, and caching
// POST /api/activity (create new event)
export async function handleActivity(request: Request, env: Env): Promise<Response>
```

**GET /api/activity Query Parameters:**
- `matterId` (optional): Filter events for specific matter
- `sessionId` (optional): Filter events for specific session  
- `limit` (optional, default: 25, max: 50): Number of events to return
- `cursor` (optional): Opaque pagination token for next page
- `since` (optional): ISO 8601 timestamp - only return events after this time
- `until` (optional): ISO 8601 timestamp - only return events before this time
- `type` (optional): Comma-separated event types to filter by (e.g., "payment_completed,image_added")
- `actorType` (optional): Filter by actor type ("user", "lawyer", "system")

**Response Format:**
```typescript
interface ActivityResponse {
  items: ActivityEvent[];
  nextCursor?: string; // Opaque token for next page, null if no more results
  total?: number; // Total count when feasible (not always available for performance)
  hasMore: boolean; // Convenience flag indicating if more results exist
}

interface ActivityEvent {
  id: string;
  type: 'matter_event' | 'session_event';
  eventType: string;
  title: string;
  description: string;
  eventDate: string; // ISO 8601
  actorType?: 'user' | 'lawyer' | 'system';
  actorId?: string;
  metadata?: Record<string, any>;
  createdAt: string; // ISO 8601
}
```

**Sorting:** Stable sort by `event_date DESC, created_at DESC` to ensure consistent pagination

**Caching:** 
- ETag header based on content hash of results
- If-None-Match conditional requests return 304 Not Modified
- Cache-Control: public, max-age=60 (1 minute for real-time feel)

**Rate Limiting:**
- 429 Too Many Requests when rate limit exceeded
- Rate limit: 100 requests per minute per IP
- Headers: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`
- Error response: `{"error": "Rate limit exceeded", "retryAfter": 60}`

**Cursor Implementation:**
- Opaque base64-encoded token containing: `{lastEventDate, lastCreatedAt, limit, filters}`
- Generated by encoding JSON object with pagination state
- Clients must not parse or modify cursor tokens
- nextCursor computed by taking last item's sort fields + current query params

**Example Requests:**
```bash
# Get first page of recent activity
GET /api/activity?matterId=123&limit=25

# Get next page using cursor
GET /api/activity?matterId=123&limit=25&cursor=eyJsYXN0RXZlbnREYXRlIjoiMjAyNC0wMS0xNVQxMDowMDowMFoiLCJsYXN0Q3JlYXRlZEF0IjoiMjAyNC0wMS0xNVQxMDowMDowMFoifQ==

# Filter by date range and event types
GET /api/activity?matterId=123&since=2024-01-01T00:00:00Z&until=2024-01-31T23:59:59Z&type=payment_completed,image_added&limit=10

# Get session events with conditional caching
GET /api/activity?sessionId=456&limit=50
# Response includes: ETag: "abc123", Cache-Control: public, max-age=60
```

**Example Response:**
```json
{
  "items": [
    {
      "id": "evt_123",
      "type": "matter_event",
      "eventType": "payment_completed",
      "title": "Payment Completed",
      "description": "Payment of $500.00 processed successfully",
      "eventDate": "2024-01-15T10:30:00Z",
      "actorType": "user",
      "actorId": "user_456",
      "metadata": {"amount": 500, "currency": "USD"},
      "createdAt": "2024-01-15T10:30:05Z"
    },
    {
      "id": "evt_124", 
      "type": "session_event",
      "eventType": "image_added",
      "title": "Image Added",
      "description": "Image added: profile_photo.jpg",
      "eventDate": "2024-01-15T09:15:00Z",
      "actorType": "user",
      "actorId": "user_456",
      "metadata": {"filename": "profile_photo.jpg", "size": 2048576},
      "createdAt": "2024-01-15T09:15:30Z"
    }
  ],
  "nextCursor": "eyJsYXN0RXZlbnREYXRlIjoiMjAyNC0wMS0xNVQwOToxNTowMFoiLCJsYXN0Q3JlYXRlZEF0IjoiMjAyNC0wMS0xNVQwOToxNTozMFoifQ==",
  "hasMore": true,
  "total": 47
}
```

#### 1.3 Add Event Creation Points
Update existing services to create activity events:

- **PaymentService**: Create events for payment completion/failure
- **SessionService**: Create events for session milestones
- **Legal Intake Agent**: Create events for matter creation, status changes
- **File Upload Service**: Create events for all media types (images, videos, audio, documents, other files)
- **Message Handling**: Track when different media types are shared in conversations

### Phase 2: Frontend Integration

#### 2.1 Create Activity Hook
**File:** `src/hooks/useActivity.ts`

```typescript
export interface UseActivityOptions {
  matterId?: string;
  sessionId?: string;
  limit?: number; // default 25, max 50
  since?: string; // ISO 8601 timestamp
  until?: string; // ISO 8601 timestamp
  type?: string[]; // event types to filter by
  actorType?: 'user' | 'lawyer' | 'system';
  autoRefresh?: boolean;
  refreshInterval?: number; // milliseconds
  enablePagination?: boolean; // default true
}

export interface UseActivityResult {
  events: ActivityEvent[];
  loading: boolean;
  error: string | null;
  hasMore: boolean;
  total?: number;
  refresh: () => Promise<void>;
  loadMore: () => Promise<void>; // Load next page using cursor
  reset: () => void; // Reset to first page
  // Caching support
  etag?: string;
  lastModified?: string;
}

export function useActivity(options: UseActivityOptions): UseActivityResult {
  // Fetch activity events with pagination support
  // Handle loading states (initial load, load more, refresh)
  // Implement cursor-based pagination
  // Support conditional caching with ETag/If-None-Match
  // Handle rate limiting (429 responses)
  // Return: { events, loading, error, hasMore, total, refresh, loadMore, reset, etag }
}
```

#### 2.2 Update ActivityTimeline Component
**File:** `src/components/ActivityTimeline.tsx`

```typescript
interface ActivityTimelineProps {
  matterId?: string;
  sessionId?: string;
  className?: string;
  // Pagination and filtering options
  limit?: number;
  since?: string;
  until?: string;
  type?: string[];
  actorType?: 'user' | 'lawyer' | 'system';
  // UI behavior
  enablePagination?: boolean;
  showLoadMore?: boolean;
  autoRefresh?: boolean;
  refreshInterval?: number;
}

// Remove hardcoded data
// Use useActivity hook with pagination support
// Handle loading/error states (initial load, load more, refresh)
// Display real events with proper formatting
// Implement "Load More" button for pagination
// Show loading indicators for different states
// Handle rate limiting gracefully
// Support conditional caching (304 responses)
// Display total count when available
```

#### 2.3 Add Activity to App Layout
**File:** `src/components/AppLayout.tsx`

```typescript
// Pass matterId/sessionId to ActivityTimeline
// Handle case when no matter/session exists
```

### Phase 3: Event Types & Mapping

#### 3.1 Define Event Types
```typescript
export const EVENT_TYPES = {
  // Matter Events
  MATTER_CREATED: 'matter_created',
  MATTER_STATUS_CHANGED: 'matter_status_changed',
  LAWYER_ASSIGNED: 'lawyer_assigned',
  PAYMENT_COMPLETED: 'payment_completed',
  PAYMENT_FAILED: 'payment_failed',
  
  // Media Events (comprehensive file type tracking)
  IMAGE_ADDED: 'image_added',
  VIDEO_ADDED: 'video_added', 
  AUDIO_ADDED: 'audio_added',
  DOCUMENT_ADDED: 'document_added',
  FILE_ADDED: 'file_added', // for "other" category files
  
  // Link Events (if implemented)
  LINK_SHARED: 'link_shared',
  
  // Session Events
  SESSION_STARTED: 'session_started',
  CONTACT_INFO_PROVIDED: 'contact_info_provided',
  INTAKE_COMPLETED: 'intake_completed',
  REVIEW_REQUESTED: 'review_requested',
} as const;
```

#### 3.2 Event Icon Mapping
```typescript
export const EVENT_ICONS = {
  [EVENT_TYPES.MATTER_CREATED]: ClockIcon,
  [EVENT_TYPES.CONTACT_INFO_PROVIDED]: UserIcon,
  [EVENT_TYPES.PAYMENT_COMPLETED]: CreditCardIcon,
  [EVENT_TYPES.LAWYER_ASSIGNED]: UserPlusIcon,
  [EVENT_TYPES.MATTER_STATUS_CHANGED]: ChatBubbleLeftRightIcon,
  
  // Media Events
  [EVENT_TYPES.IMAGE_ADDED]: PhotoIcon,
  [EVENT_TYPES.VIDEO_ADDED]: VideoCameraIcon,
  [EVENT_TYPES.AUDIO_ADDED]: MusicalNoteIcon,
  [EVENT_TYPES.DOCUMENT_ADDED]: DocumentTextIcon,
  [EVENT_TYPES.FILE_ADDED]: DocumentIcon,
  [EVENT_TYPES.LINK_SHARED]: LinkIcon,
  
  // Session Events
  [EVENT_TYPES.SESSION_STARTED]: ClockIcon,
  [EVENT_TYPES.INTAKE_COMPLETED]: CheckCircleIcon,
  [EVENT_TYPES.REVIEW_REQUESTED]: ChatBubbleLeftRightIcon,
} as const;
```

### Phase 4: Data Flow & Integration Points

#### 4.1 Event Creation Flow
```mermaid
graph TD
    A[User Action] --> B[Service Method]
    B --> C[Create Activity Event]
    C --> D[Store in Database]
    D --> E[Update UI via Hook]
```

#### 4.2 Integration Points
1. **Payment Completion**: `PaymentService.completePayment()` → Create payment event
2. **Matter Creation**: `LegalIntakeAgent.createMatter()` → Create matter_created event
3. **Status Changes**: `ReviewService.processReview()` → Create status_change event
4. **File Upload**: `FileService.uploadFile()` → Create specific media event based on file category:
   - Images (JPEG, PNG, GIF, etc.) → `image_added` event
   - Videos (MP4, WebM, etc.) → `video_added` event  
   - Audio (MP3, WAV, etc.) → `audio_added` event
   - Documents (PDF, DOC, etc.) → `document_added` event
   - Other files → `file_added` event
5. **Contact Form**: `ContactIntakeOrchestrator.submitForm()` → Create contact_info_provided event
6. **Message Handling**: Track media sharing in conversations using existing `mediaAggregation.ts` logic

### Phase 5: UI/UX Enhancements

#### 5.1 Loading States
- Skeleton loader for timeline items
- Progressive loading (show recent events first)
- Error states with retry functionality

#### 5.2 Event Formatting
- Relative timestamps ("2 hours ago", "Yesterday")
- Rich descriptions with context and file names:
  - "Image added: profile_photo.jpg"
  - "Video added: deposition_recording.mp4" 
  - "Audio added: voicemail_message.wav"
  - "Document added: employment_contract.pdf"
  - "File added: case_notes.txt"
- Clickable events (link to relevant documents/actions)
- Grouping by date
- File type-specific icons and styling

#### 5.3 Real-time Updates
- WebSocket connection for live updates
- Polling fallback for activity refresh
- Optimistic updates for user actions

## Implementation Order

### Week 1: Backend Foundation
1. Create `ActivityService.ts` with comprehensive media event support
2. Create `/api/activity` route
3. Add event creation to existing services with file type categorization
4. Integrate with existing `mediaAggregation.ts` logic for file categorization
5. Test with sample data across all media types

### Week 2: Frontend Integration
1. Create `useActivity` hook
2. Update `ActivityTimeline` component to handle all media types
3. Remove placeholder data
4. Add loading/error states
5. Implement file type-specific icons and descriptions

### Week 3: Polish & Testing
1. Add event type mappings
2. Implement proper formatting
3. Add real-time updates
4. Comprehensive testing

## Database Queries

### Get Matter Events
```sql
SELECT 
  id,
  event_type,
  title,
  description,
  event_date,
  created_by_lawyer_id,
  metadata,
  created_at
FROM matter_events 
WHERE matter_id = ? 
ORDER BY event_date DESC, created_at DESC
```

### Get Session Events
```sql
SELECT 
  id,
  event_type,
  actor_type,
  actor_id,
  payload,
  created_at
FROM session_audit_events 
WHERE session_id = ? 
ORDER BY created_at DESC
```

### Combined Activity Query with Pagination and Filtering
```sql
-- Union of matter and session events with proper typing, pagination, and filtering
WITH combined_events AS (
  SELECT 
    'matter_event' as type,
    id,
    event_type,
    title,
    description,
    event_date as event_date,
    created_by_lawyer_id as actor_id,
    'lawyer' as actor_type,
    metadata,
    created_at
  FROM matter_events 
  WHERE matter_id = ?
    AND (? IS NULL OR event_date >= ?) -- since filter
    AND (? IS NULL OR event_date <= ?) -- until filter
    AND (? IS NULL OR event_type IN (SELECT value FROM json_each(?))) -- type filter
    AND (? IS NULL OR 'lawyer' = ?) -- actorType filter

  UNION ALL

  SELECT 
    'session_event' as type,
    id,
    event_type,
    event_type as title,
    payload as description,
    created_at as event_date,
    actor_id,
    actor_type,
    json_object('payload', payload) as metadata, -- Safe JSON construction using SQLite's json_object()
    created_at
  FROM session_audit_events 
  WHERE session_id = ?
    AND (? IS NULL OR created_at >= ?) -- since filter
    AND (? IS NULL OR created_at <= ?) -- until filter
    AND (? IS NULL OR event_type IN (SELECT value FROM json_each(?))) -- type filter
    AND (? IS NULL OR actor_type = ?) -- actorType filter
),
filtered_events AS (
  SELECT * FROM combined_events
  WHERE (? IS NULL OR event_date >= ?) -- cursor-based pagination: since last event_date
    AND (? IS NULL OR (event_date = ? AND created_at < ?)) -- cursor-based pagination: since last created_at
  ORDER BY event_date DESC, created_at DESC
  LIMIT ? -- limit parameter
)
SELECT * FROM filtered_events;

-- Count query for total (when feasible)
SELECT COUNT(*) as total FROM combined_events;
```

### Cursor-Based Pagination Implementation
```typescript
// Cursor contains: {lastEventDate, lastCreatedAt, limit, filters}
const cursorData = {
  lastEventDate: "2024-01-15T09:15:00Z",
  lastCreatedAt: "2024-01-15T09:15:30Z", 
  limit: 25,
  filters: {matterId: "123", type: ["payment_completed"]}
};

// Encode cursor
const cursor = btoa(JSON.stringify(cursorData));

// Decode cursor for query
const decoded = JSON.parse(atob(cursor));
// Use decoded.lastEventDate and decoded.lastCreatedAt for WHERE clauses
```

## Testing Strategy

### Unit Tests
- `ActivityService` methods (queryActivity, cursor encoding/decoding)
- Event creation logic
- Data transformation functions
- Cursor-based pagination logic
- Rate limiting logic
- ETag generation and conditional caching

### Integration Tests
- API endpoint functionality with all query parameters
- Database queries with pagination and filtering
- Frontend hook behavior (useActivity with pagination)
- Cursor-based pagination flow
- Rate limiting enforcement (429 responses)
- Conditional caching (304 responses)
- Error handling for malformed cursors

### E2E Tests
- Complete activity timeline flow with pagination
- Load more functionality
- Filtering by date range and event types
- Real-time updates with caching
- Rate limiting scenarios
- Error handling scenarios (network failures, malformed responses)
- Performance testing with large datasets

## Success Metrics

1. **Functionality**: ActivityTimeline displays real events from database across all media types
2. **Performance**: Timeline loads within 500ms
3. **Accuracy**: Events are created for all major user actions including file uploads
4. **Media Coverage**: All supported file types (images, videos, audio, documents, other) are properly tracked
5. **UX**: Smooth loading states, error handling, and file type-specific visual indicators
6. **Maintainability**: Clean separation of concerns and integration with existing media aggregation logic

## Future Enhancements

1. **Event Filtering**: Filter by event type, date range, actor, media type
2. **Event Details**: Expandable event details with full context and media previews
3. **Event Actions**: Click to view related documents/actions, preview media files
4. **Media Previews**: Thumbnail previews for images/videos in timeline
5. **Export**: Export activity timeline as PDF with media references
6. **Notifications**: Real-time notifications for important events
7. **Analytics**: Activity metrics and insights by media type
8. **Link Tracking**: If link sharing is implemented, track and display link events

## Risk Mitigation

1. **Data Migration**: Ensure existing data is preserved
2. **Performance**: Index database tables properly
3. **Backwards Compatibility**: Maintain existing API contracts
4. **Error Handling**: Graceful degradation when events fail to load
5. **Security**: Validate event creation permissions
